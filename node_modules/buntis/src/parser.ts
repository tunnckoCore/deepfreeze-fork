import { Token, KeywordDescTable } from './token';
import { nextToken } from './scanner/scan';
import { Errors, report } from './errors';
import { scanTemplateTail } from './scanner/string';
import * as ESTree from './estree';
import { scanJSXIdentifier, scanJSXToken, scanJSXAttributeValue } from './scanner/jsx';
import {
  Context,
  Flags,
  Origin,
  BindingKind,
  TypeScriptMadness,
  CommentCallback,
  ErrorCallback,
  ParserState,
  PropertyKind,
  Options,
  optionalBit,
  consume,
  consumeOpt,
  consumeSemicolon,
  canParseSemicolon,
  reinterpretToPattern,
  isValidIdentifier,
  reinterpretToTypeLiteral,
  ModifierKind,
  TypeAssertionState,
  TypeAliasState,
  primaryTypes,
  tryScan,
  canFollowTypeArgumentsInExpression,
  isEqualTagName,
  ClassAndFunctionFlags,
  isStrictReservedWord,
  validateFunctionName,
  finishNode
} from './common';

/**
 * Create a new parser instance.
 */
export function create(source: string, onError?: ErrorCallback, onComment?: CommentCallback): ParserState {
  return {
    /**
     * The source code to be parsed
     */
    source,

    /**
     * The mutable parser flags, in case any flags need passed by reference.
     */
    flags: Flags.Empty,

    /**
     * The current index
     */
    index: 0,

    /**
     * Beginning of current line
     */
    line: 1,

    /**
     * Beginning of current column
     */
    column: 0,

    /**
     * Start position of text of current token
     */
    tokenPos: 0,

    /**
     * Start position of whitespace before current token
     */
    startPos: 0,

    /**
     * Start column position of whitespace before current token
     */
    startColumn: 0,

    /**
     * Start line position of whitespace before current token
     */
    startLine: 0,

    /**
     * End line position of whitespace before current token
     */
    endLine: 0,

    /**
     * End column position of whitespace before current token
     */
    endColumn: 0,

    /**
     * Sets to `1` if preciding line break
     */
    precedingLineBreak: 0,

    /**
     * The end of the source code
     */
    length: source.length,

    /**
     * The current token in the stream to consume
     */
    token: Token.EndOfSource,

    /**
     * Holds the scanned token value
     */
    tokenValue: undefined,

    /**
     * Holds the raw text that have been scanned by the lexer
     */
    tokenRaw: '',

    /**
     * Holds the regExp info text that have been collected by the lexer
     */
    tokenRegExp: undefined,

    /**
     * The code point at the current index
     */
    nextCodePoint: source.charCodeAt(0),

    /**
     * Counter for incremental uid
     */
    uid: 0,

    /**
     * Callback for comment attachment
     */
    onComment,

    /**
     * Callback for error recovery
     */
    onError
  };
}

export function parseSource(
  source: string,
  options: Options | void,
  context: Context,
  onError?: ErrorCallback
): ESTree.Program {
  let onComment: CommentCallback;

  if (options != null) {
    if (options.onComment != null) onComment = options.onComment;

    context |=
      (options.module ? Context.Module : 0) |
      (options.next ? Context.OptionsNext : 0) |
      (options.jsx ? Context.OptionsJSX : 0) |
      (options.ranges ? Context.OptionsRanges : 0) |
      (options.loc ? Context.OptionsLoc : 0) |
      (options.impliedStrict ? Context.Strict : 0) |
      (options.directives ? Context.OptionsDirectives | Context.OptionsRaw : 0) |
      (options.globalReturn ? Context.OptionsGlobalReturn : 0) |
      (options.disableWebCompat ? Context.DisableWebCompat : 0) |
      (options.raw ? Context.OptionsRaw : 0) |
      (options.ts ? Context.OptionsTS : 0);
  }

  let body: ESTree.Program[] = [];

  const parser = create(source, onError, onComment);

  const isModule = context & Context.Module;

  nextToken(parser, context | Context.AllowRegExp);

  context |= Context.InGlobal;

  body =
    context & Context.OptionsTS
      ? parseDeclarations(parser, context)
      : isModule
      ? parseModuleItemList(parser, context)
      : parseStatementList(parser, context);

  const node: any = {
    type: 'Program',
    sourceType: isModule ? 'module' : 'script',
    body
  };

  return node;
}

export function parseDeclarations(parser: ParserState, context: Context): ESTree.DeclarationStatement[] {
  const statements: ESTree.DeclarationStatement[] = [];

  while (parser.token === Token.StringLiteral) {
    // "use strict" must be the exact literal without escape sequences or line continuation.
    if (parser.index - parser.tokenPos < 13 && parser.tokenValue === 'use strict') {
      if ((parser.token & Token.IsAutoSemicolon) === Token.IsAutoSemicolon || parser.precedingLineBreak === 0) {
        context |= Context.Strict;
      }
    }
    statements.push(parseStatementListItem(parser, context, parser.tokenPos));
  }

  while (parser.token !== Token.EndOfSource) {
    statements.push(parseDeclarationList(parser, context, /* isModule */ 0, /* declared */ 0, /* isExport */ false));
  }
  return statements;
}

export function parseDeclarationList(
  parser: ParserState,
  context: Context,
  isModule: 0 | 1,
  declare: 0 | 1,
  isExport: boolean
): any {
  const { token } = parser;

  let decorators: ESTree.Decorator[] = [];

  switch (token) {
    // 'declare'
    case Token.DeclareKeyword: {
      const { tokenValue } = parser;
      switch (nextToken(parser, context)) {
        case Token.ClassKeyword:
          return parseTypescriptClassDeclaration(
            parser,
            context,
            ClassAndFunctionFlags.None,
            /* declare */ 1,
            /* abstract */ 0
          );
        case Token.FunctionKeyword:
          return parseFunctionDeclaration(
            parser,
            context,
            ClassAndFunctionFlags.None,
            Origin.Statement,
            /* isAsync */ 0,
            /* allowGen */ 1,
            /* declare */ true
          );
        default:
          if (
            parser.precedingLineBreak === 0 &&
            (parser.token & Token.IsDeclarationStatement) === Token.IsDeclarationStatement
          ) {
            return parseDeclarationList(parser, context, isModule, 1, parser.token === Token.ExportKeyword);
          }

          return parseExpressionOrLabelledStatement(
            parser,
            context,
            parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 0),
            token,
            0
          );
      }
    }

    // 'abstract'
    case Token.AbstractKeyword:
      return parseClassDeclarationOrIdentifier(parser, context, token, /* abstract */ 1, declare);

    // 'namespace'
    case Token.NamespaceKeyword:
      return parseNamespaceOrIdentifier(parser, context, token, declare);

    // 'enum'
    case Token.EnumKeyword:
      return parseEnumDeclarationOrIdentifier(parser, context, token, declare, /* isConst */ 0);

    // 'interface'
    case Token.InterfaceKeyword:
      return parseInterfaceOrIdentifier(parser, context, token, declare);

    // 'type'
    case Token.TypeKeyword:
      return parseTypeAliasOrIdentifier(parser, context, token, declare);

    // 'module', 'global'
    case Token.GlobalKeyword:
      return parseGlobalModuleDeclarationOrIdentifier(parser, context, token, declare);
    case Token.ModuleKeyword:
      return parseModuleDeclarationOrIdentifier(parser, context, token, declare);

    // 'const', 'const enum'
    case Token.ConstKeyword:
      return parseConstEnumOrVariableStatement(parser, context, declare);

    case Token.At:
      decorators = parseDecorators(parser, context);

      if (parser.token === Token.ClassKeyword) {
        return parseTypescriptClassDeclaration(
          parser,
          context,
          ClassAndFunctionFlags.None,
          /* declare */ 0,
          /* abstract */ 0,
          decorators as any,
          true
        );
      }

    // 'export'
    case Token.ExportKeyword: {
      if (isExport) report(parser, context, Errors.ExportAssignModifiers, /* early */ 0);
      switch (nextToken(parser, context | Context.AllowRegExp)) {
        case Token.DefaultKeyword:
          return parseExportDefaultDeclaration(parser, context, decorators);
        case Token.Assign:
          return parseExportAssignment(parser, context);
        case Token.DeclareKeyword:
        case Token.InterfaceKeyword:
          return parseExportNamedDeclaration(parser, context);
        case Token.AsKeyword:
          return parseNamespaceExportDeclaration(parser, context);
        case Token.ImportKeyword:
          return parseImportEqualsDeclaration(parser, context, /* isExport */ 1);
        default:
          return parseTypeScriptExportDeclaration(parser, context, decorators);
      }
    }
    // 'import
    case Token.ImportKeyword: {
      if ((context & Context.InGlobal) < 1) {
        report(parser, context, Errors.InvalidImportDeclNotGlobal, /* early */ 0);
      }
      return parseImportDeclaration(parser, context, /* isTS */ 1);
    }
    default:
      return parseStatementListItem(parser, context, 1);
  }
}

export function parseStatementList(parser: ParserState, context: Context): any {
  const statements: any[] = [];

  while (parser.token === Token.StringLiteral) {
    // "use strict" must be the exact literal without escape sequences or line continuation.
    if (parser.index - parser.tokenPos < 13 && parser.tokenValue === 'use strict') {
      if ((parser.token & Token.IsAutoSemicolon) === Token.IsAutoSemicolon || parser.precedingLineBreak === 0) {
        context |= Context.Strict;
      }
    }
    statements.push(parseStatementListItem(parser, context, parser.tokenPos));
  }

  while (parser.token !== Token.EndOfSource) {
    statements.push(parseStatementListItem(parser, context, parser.tokenPos));
  }
  return statements;
}

export function parseStatementListItem(parser: ParserState, context: Context, pos: number): any {
  switch (parser.token) {
    case Token.FunctionKeyword:
      return parseFunctionDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.None,
        Origin.Statement,
        /* isAsync */ 0,
        /* allowGen */ 1,
        /* declare */ false
      );
    case Token.At:
    case Token.ClassKeyword:
      return context & Context.OptionsTS
        ? parseTypescriptClassDeclaration(
            parser,
            context,
            ClassAndFunctionFlags.None,
            /* declare */ 0,
            /* abstract */ 0
          )
        : parseClassDeclaration(parser, context, ClassAndFunctionFlags.None);
    case Token.ConstKeyword:
      return parseLexicalDeclaration(parser, context, BindingKind.Const, Origin.None);
    case Token.LetKeyword:
      return parseLetIdentOrVarDeclarationStatement(parser, context);
    case Token.ExportKeyword:
      report(parser, context, Errors.Unexpected, 0);
    case Token.ImportKeyword:
      switch (nextToken(parser, context)) {
        case Token.LeftParen:
          return parseImportCallDeclaration(parser, context);
        default:
          report(parser, context, Errors.Unexpected, 0);
      }
    case Token.AsyncKeyword:
      return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context);
    default:
      return parseStatement(parser, context, pos);
  }
}

export function parseAsyncArrowOrAsyncFunctionDeclaration(parser: ParserState, context: Context): any {
  const { token } = parser;

  let expr: any = parseIdentifier(parser, context);

  if (parser.token === Token.Colon) {
    return parseLabelledStatement(parser, context, token, expr, 1);
  }

  const asyncNewLine = parser.precedingLineBreak;

  if (!asyncNewLine) {
    // async function ...
    if (parser.token === Token.FunctionKeyword) {
      return parseFunctionDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.None,
        Origin.Statement,
        /* isAsync */ 1,
        /* allowGen */ 1,
        /* declare */ false
      );
    }

    // async Identifier => ...
    if ((parser.token & Token.IsIdentifier) === Token.IsIdentifier) {
      expr = parseArrowFunctionExpression(
        parser,
        context,
        [parseIdentifier(parser, context)],
        null,
        null,
        /* isLHS */ 1,
        /* isAsync */ 1
      );
      if (parser.token === Token.Comma) expr = parseSequenceExpression(parser, context, expr);

      return parseExpressionStatement(parser, context, expr);
    }
  }
  let typeParameters: any = null;

  if (context & Context.OptionsTS && parser.token === Token.LessThan) {
    typeParameters = parseAsyncIdentifierOrParameterInstantiation(parser, context);
    if (typeParameters !== undefined && parser.token !== Token.LeftParen)
      report(parser, context, Errors.Unexpected, /* early */ 0);
  }

  if (parser.token === Token.LeftParen) {
    expr = parseAsyncArrowOrCallExpression(parser, context, 1, typeParameters, expr);
  } else if (parser.token === Token.Arrow) {
    expr = parseArrowFunctionExpression(parser, context, expr, null, null, /* isLHS */ 1, /* isAsync */ 1);
  }

  expr = parseMemberOrUpdateExpression(parser, context, expr);

  if (parser.token === Token.Comma) expr = parseSequenceExpression(parser, context, expr);

  expr = parseAssignmentExpression(parser, context, expr);

  return parseExpressionStatement(parser, context, expr);
}

export function parseAsyncIdentifierOrParameterInstantiation(
  parser: ParserState,
  context: Context
): ESTree.TypeParameterInstantiation | void {
  return tryScan(parser, context, function(): any {
    nextToken(parser, context);
    const params: any[] = [];
    while (parser.token !== Token.GreaterThan) {
      params.push(parseTypeParameter(parser, context | Context.Speculative));
      if (parser.token !== Token.GreaterThan) {
        if (!consumeOpt(parser, context, Token.Comma)) break;
      }
    }

    if (!consumeOpt(parser, context, Token.GreaterThan)) {
      return undefined;
    }

    return params && canFollowTypeArgumentsInExpression(parser)
      ? {
          type: 'TypeParameterDeclaration',
          params
        }
      : undefined;
  });
}
export function parseAsyncArrowOrCallExpression(
  parser: ParserState,
  context: Context,
  isLHS: 0 | 1,
  typeParameters: any,
  callee: ESTree.Identifier | void
): any {
  nextToken(parser, context | Context.AllowRegExp);

  context = (context | Context.DisallowIn) ^ Context.DisallowIn;

  if (consumeOpt(parser, context, Token.RightParen)) {
    let returnType: any[] | null = null;

    if (context & Context.OptionsTS && parser.token === Token.Colon) {
      returnType = parseTypeAnnotation(parser, context, /* restrictedTypes */ 0);
      if (parser.token !== Token.Arrow) report(parser, context, Errors.Unexpected, /* early */ 0);
    }

    if (parser.token === Token.Arrow) {
      if (isLHS) {
        return parseArrowFunctionExpression(
          parser,
          context,
          [],
          typeParameters,
          returnType,
          /* isLHS */ 1,
          /* isAsync */ 1
        );
      }
      report(parser, context, Errors.Unexpected, /* early */ 1);
    }

    return finishNode({
      type: 'CallExpression',
      callee,
      arguments: []
    } as any);
  }

  let expr: any = null;

  const params: ESTree.Expression[] = [];

  while (parser.token !== Token.RightParen) {
    const { token } = parser;

    if ((token & (Token.IsIdentifier | Token.FutureReserved)) > 0) {
      expr = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 1);
      if (parser.token === Token.QuestionMark) {
        nextToken(parser, context);
        if (parser.token === Token.Colon) {
          expr.typeAnnotation = parseTypeAnnotation(parser, context, /* restrictedTypes */ 0);
        }
        return parseOptionalNchanged(parser, context, params, /* isAsync */ 1);
      }
      if (parser.token === Token.RightParen || parser.token === Token.Comma) {
        // TODO
      } else {
        expr = parseMemberOrUpdateExpression(parser, context, expr);

        if (parser.token !== Token.RightParen && parser.token !== Token.Comma) {
          expr = parseAssignmentExpression(parser, context, expr);
        }
      }
    } else if (token & Token.IsPatternStart) {
      expr =
        token === Token.LeftBrace
          ? parseObjectLiteralOrPattern(parser, context, 0, /* isPattern */ 1, [])
          : parseArrayExpressionOrPattern(parser, context, 0, /* isPattern */ 1, []);

      if (parser.token !== Token.RightParen && parser.token !== Token.Comma) {
        expr = parseMemberOrUpdateExpression(parser, context, expr);

        if ((parser.token & Token.IsBinaryOp) === Token.IsBinaryOp) {
          expr = parseBinaryExpression(parser, context, 1, token, expr);
        }

        if (consumeOpt(parser, context | Context.AllowRegExp, Token.QuestionMark)) {
          expr = parseConditionalExpression(parser, context, expr);
        }
      }
    } else if (token === Token.Ellipsis) {
      expr = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, []);
    } else {
      expr = parseExpression(parser, context);

      params.push(expr);

      while (consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) {
        params.push(parseExpression(parser, context));
      }

      consume(parser, context, Token.RightParen);

      return finishNode({
        type: 'CallExpression',
        callee,
        arguments: params
      } as any);
    }

    params.push(expr as ESTree.Expression);

    if (!consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) break;
  }

  consume(parser, context, Token.RightParen);
  let returnType: any[] | null = null;
  if (context & Context.Conditional && parser.token === Token.Colon) {
    const returnType = tryScan(parser, context, function(): any {
      const returnType = parseTypeAnnotation(parser, context | Context.Speculative, /* restrictedTypes */ 0);
      if (parser.token === Token.Arrow) return returnType;
      return undefined;
    });
    return returnType
      ? parseArrowFunctionExpression(parser, context, params, null, returnType, isLHS, /* isAsync */ 1)
      : expr;
  } else if (parser.token === Token.Colon) {
    returnType = parseTypeAnnotation(parser, context, /* restrictedTypes */ 0);
    if (parser.token !== Token.Arrow) report(parser, context, Errors.Unexpected, /* early */ 0);
  }

  if (parser.token === Token.Arrow) {
    if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseArrowFunctionExpression(
      parser,
      context,
      params,
      typeParameters,
      returnType,
      /* isLHS */ 1,
      /* isAsync */ 1
    );
  }

  return finishNode({
    type: 'CallExpression',
    callee,
    arguments: params
  } as any);
}

export function parseModuleItemList(parser: ParserState, context: Context): any {
  const statements: any[] = [];
  while (parser.token !== Token.EndOfSource) {
    statements.push(parseModuleItem(parser, context));
  }
  return statements;
}

export function parseModuleItem(parser: ParserState, context: Context): any {
  // ecma262/#prod-ModuleItem
  // ModuleItem :
  //    ImportDeclaration
  //    ExportDeclaration
  //    StatementListItem

  switch (parser.token) {
    case Token.ExportKeyword:
      return parseExportDeclaration(parser, context);
    case Token.ImportKeyword:
      return parseImportDeclaration(parser, context, /* isTS */ 0);
    default:
      return parseStatementListItem(parser, context, 0);
  }
}

function parseImportDeclaration(
  parser: ParserState,
  context: Context,
  isTS: 0 | 1
): ESTree.ImportDeclaration | ESTree.ExpressionStatement {
  let source: ESTree.Literal | null = null;

  nextToken(parser, context);

  const specifiers: (ESTree.ImportSpecifier | ESTree.ImportDefaultSpecifier | ESTree.ImportNamespaceSpecifier)[] = [];

  // 'import' ModuleSpecifier ';'
  if (parser.token === Token.StringLiteral) {
    source = parseLiteral(parser, context);
  } else {
    if (parser.token & (Token.Keywords | Token.FutureReserved | Token.IsIdentifier)) {
      const local = parseIdentifier(parser, context);
      if (isTS && parser.token === Token.Assign) {
        nextToken(parser, context);
        const moduleReference: any = parseModuleReference(parser, context);
        consumeSemicolon(parser, context);
        return finishNode({
          type: 'ImportEqualsDeclaration',
          id: local,
          moduleReference,
          isExport: false
        } as any);
      }
      specifiers.push(
        finishNode({
          type: 'ImportDefaultSpecifier',
          local
        })
      );

      // NameSpaceImport
      if (consumeOpt(parser, context, Token.Comma)) {
        switch (parser.token) {
          case Token.Multiply:
            specifiers.push(parseImportNamespaceSpecifier(parser, context));
            break;

          case Token.LeftBrace:
            parseImportSpecifierOrNamedImports(parser, context, specifiers);
            break;

          default:
            report(parser, context, Errors.Unexpected, /* early */ 1);
        }
      }
    } else {
      // Parse NameSpaceImport or NamedImports if present
      switch (parser.token) {
        case Token.Multiply:
          specifiers.push(parseImportNamespaceSpecifier(parser, context));
          break;
        case Token.LeftBrace:
          parseImportSpecifierOrNamedImports(parser, context, specifiers);
          break;
        case Token.LeftParen:
          return parseImportCallDeclaration(parser, context);
        default:
          report(parser, context, Errors.UnexpectedToken, /* early */ 0, KeywordDescTable[parser.token & Token.Type]);
      }
    }

    source = parseModuleSpecifier(parser, context);
  }

  consumeSemicolon(parser, context | Context.AllowRegExp);

  return finishNode({
    type: 'ImportDeclaration',
    specifiers,
    source
  } as any);
}

export function parseImportCallDeclaration(parser: ParserState, context: Context): ESTree.ExpressionStatement {
  let expr = parseImportExpression(parser, context);

  expr = parseMemberOrUpdateExpression(parser, context, expr);

  return parseExpressionStatement(parser, context, expr);
}

/**
 * Parse binding identifier
 *
 * @see [Link](https://tc39.github.io/ecma262/#prod-NameSpaceImport)
 *
 * @param parser  Parser object
 * @param context Context masks
 * @param specifiers Array of import specifiers
 */
function parseImportNamespaceSpecifier(parser: ParserState, context: Context): ESTree.ImportNamespaceSpecifier {
  // NameSpaceImport:
  //  * as ImportedBinding

  nextToken(parser, context);
  consume(parser, context, Token.AsKeyword);

  return finishNode({
    type: 'ImportNamespaceSpecifier',
    local: parseIdentifier(parser, context)
  });
}

/**
 * Parse module specifier
 *
 * @see [Link](https://tc39.github.io/ecma262/#prod-ModuleSpecifier)
 *
 * @param parser  Parser object
 * @param context Context masks
 */
function parseModuleSpecifier(parser: ParserState, context: Context): ESTree.Literal {
  // ModuleSpecifier :
  //   StringLiteral
  consumeOpt(parser, context, Token.FromKeyword);

  if (parser.token !== Token.StringLiteral) report(parser, context, Errors.Unexpected, 0, 'Import');

  return parseLiteral(parser, context);
}

function parseImportSpecifierOrNamedImports(
  parser: ParserState,
  context: Context,
  specifiers: (ESTree.ImportSpecifier | ESTree.ImportDefaultSpecifier | ESTree.ImportNamespaceSpecifier)[]
): (ESTree.ImportSpecifier | ESTree.ImportDefaultSpecifier | ESTree.ImportNamespaceSpecifier)[] {
  // NamedImports :
  //   '{' '}'
  //   '{' ImportsList '}'
  //   '{' ImportsList ',' '}'
  //
  // ImportsList :
  //   ImportSpecifier
  //   ImportsList ',' ImportSpecifier
  //
  // ImportSpecifier :
  //   BindingIdentifier
  //   IdentifierName 'as' BindingIdentifier

  nextToken(parser, context);

  while ((parser.token & (Token.FutureReserved | Token.IdentifierOrKeyword)) !== 0) {
    const imported = parseIdentifier(parser, context);
    let local: ESTree.Identifier;

    if (consumeOpt(parser, context, Token.AsKeyword)) {
      local = parseIdentifier(parser, context);
    } else {
      local = imported;
    }

    specifiers.push(
      finishNode({
        type: 'ImportSpecifier',
        local,
        imported
      })
    );

    if (parser.token !== Token.RightBrace) consume(parser, context, Token.Comma);
  }

  consume(parser, context, Token.RightBrace);

  return specifiers;
}

export function parseExportAssignment(parser: ParserState, context: Context): any {
  nextToken(parser, context);
  const expression = parseExpression(parser, context);
  consumeSemicolon(parser, context);
  return finishNode({
    type: 'ExportAssignment',
    expression
  });
}

export function parseExportNamedDeclaration(parser: ParserState, context: Context) {
  return finishNode({
    type: 'ExportNamedDeclaration',
    declaration: parseDeclarationList(parser, context, /* isModule */ 1, 1, /* isExport */ false),
    specifiers: [],
    source: null
  });
}

export function parseNamespaceExportDeclaration(parser: ParserState, context: Context) {
  nextToken(parser, context);
  consumeOpt(parser, context, Token.NamespaceKeyword);
  const id = parseIdentifier(parser, context);
  consumeSemicolon(parser, context);
  return finishNode({
    type: 'NamespaceExportDeclaration',
    id
  });
}

export function parseTypeScriptExportDeclaration(
  parser: ParserState,
  context: Context,
  decrorators: ESTree.Decorator[]
) {
  if ((context & Context.InGlobal) < 1) report(parser, context, Errors.UnexpectedToken, 0, 'Export');

  const specifiers: any[] = [];
  let source = null;
  let declaration: any = null;

  switch (parser.token) {
    case Token.NamespaceKeyword:
      declaration = parseModuleOrNamespaceDeclaration(parser, context);
      break;
    case Token.ModuleKeyword:
      declaration = parseModuleDeclaration(parser, context, false);
      break;
    case Token.EnumKeyword:
      nextToken(parser, context);
      declaration = parseEnumDeclaration(parser, context, 0, 0);
      break;
    case Token.TypeKeyword:
      nextToken(parser, context);
      declaration = parseTypeAlias(parser, context, 0);
      break;
    case Token.AbstractKeyword:
      nextToken(parser, context);
      if (parser.token !== Token.ClassKeyword) {
        report(parser, context, Errors.UnexpectedToken, 0, KeywordDescTable[parser.token & Token.Type]);
      }
      declaration = parseTypescriptClassDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.Hoisted,
        /* declare */ 0,
        /* abstract */ 1
      );
      break;
    case Token.Multiply: {
      let ecma262PR: 0 | 1 = 0;

      nextToken(parser, context); // Skips: '*'

      if (context & Context.OptionsNext && consumeOpt(parser, context, Token.AsKeyword)) {
        ecma262PR = 1;
        specifiers.push(
          finishNode({
            type: 'ExportNamespaceSpecifier',
            specifier: parseIdentifier(parser, context)
          })
        );
      }

      consume(parser, context, Token.FromKeyword);

      source = parseLiteral(parser, context);

      consumeSemicolon(parser, context | Context.AllowRegExp);

      return ecma262PR
        ? {
            type: 'ExportNamedDeclaration',
            source,
            specifiers
          }
        : ({
            type: 'ExportAllDeclaration',
            source
          } as any);
    }
    case Token.LeftBrace: {
      nextToken(parser, context); // Skips: '{'

      while ((parser.token & (Token.FutureReserved | Token.IdentifierOrKeyword)) !== 0) {
        const local = parseIdentifier(parser, context);

        let exported: ESTree.Identifier | null;

        if (parser.token === Token.AsKeyword) {
          nextToken(parser, context);
          exported = parseIdentifier(parser, context);
        } else {
          exported = local;
        }

        specifiers.push(
          finishNode({
            type: 'ExportSpecifier',
            local,
            exported
          } as any)
        );

        if (parser.token !== Token.RightBrace) consume(parser, context, Token.Comma);
      }

      consume(parser, context, Token.RightBrace);

      if (consumeOpt(parser, context, Token.FromKeyword)) {
        //  The left hand side can't be a keyword where there is no
        // 'from' keyword since it references a local binding.
        if (parser.token !== Token.StringLiteral) report(parser, context, Errors.UnexpectedToken, 0, 'Export');

        source = parseLiteral(parser, context);
      }

      consumeSemicolon(parser, context | Context.AllowRegExp);

      break;
    }

    case Token.At:
    case Token.ClassKeyword:
      declaration =
        context & Context.OptionsTS
          ? parseTypescriptClassDeclaration(
              parser,
              context,
              ClassAndFunctionFlags.Hoisted,
              /* declare */ 0,
              /* abstract */ 0,
              decrorators as any
            )
          : parseClassDeclaration(parser, context, ClassAndFunctionFlags.Export);
      break;

    case Token.FunctionKeyword:
      declaration = parseFunctionDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.Export,
        Origin.TopLevel,
        0,
        /* allowGen */ 1,
        false
      );
      break;

    case Token.LetKeyword:
      declaration = parseLexicalDeclaration(parser, context, BindingKind.Let, Origin.Export);
      break;
    case Token.ConstKeyword:
      declaration = parseConstEnumOrVariableStatement(parser, context, 0);
      break;
    case Token.VarKeyword:
      declaration = parseVariableStatement(parser, context, Origin.Export);
      break;
    case Token.AsyncKeyword:
      nextToken(parser, context);
      if (parser.precedingLineBreak === 0 && parser.token === Token.FunctionKeyword) {
        declaration = parseFunctionDeclaration(
          parser,
          context,
          ClassAndFunctionFlags.Export,
          Origin.TopLevel,
          1,
          /* allowGen */ 1,
          false
        );
        break;
      }
    // falls through
    default:
      report(parser, context, Errors.UnexpectedToken, 0, KeywordDescTable[parser.token & Token.Type]);
  }

  return finishNode({
    type: 'ExportNamedDeclaration',
    source,
    specifiers,
    declaration
  });
}

export function parseModuleOrNamespaceDeclaration(parser: ParserState, context: Context): any {
  nextToken(parser, context);
  const id = parseIdentifier(parser, context);
  let body: any;
  if (consumeOpt(parser, context, Token.Period)) {
    body = parseModuleOrNamespaceDeclaration(parser, context);
  } else {
    body = parseModuleBlock(parser, context);
  }
  consumeSemicolon(parser, context);
  return finishNode({
    type: 'ModuleDeclaration',
    id,
    body
  });
}

function parseImportEqualsDeclaration(parser: ParserState, context: Context, isExport: 0 | 1): any {
  consume(parser, context, Token.ImportKeyword);
  const id = parseIdentifier(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.Assign);
  const moduleReference: any = parseModuleReference(parser, context);
  consumeSemicolon(parser, context);
  return finishNode({
    type: 'ImportEqualsDeclaration',
    id,
    isExport: isExport === 1,
    moduleReference
  });
}

function parseModuleReference(parser: ParserState, context: Context): any {
  if (parser.token === Token.RequireKeyword) {
    const { tokenValue } = parser;
    nextToken(parser, context);
    if (parser.token !== Token.LeftParen) {
      // 'Require' as identifier
      return parseQualifiedName(
        parser,
        context,
        parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 0)
      );
    }
    return parseExternalModuleReference(parser, context);
  }
  return parseEntityName(parser, context);
}

export function parseExternalModuleReference(parser: ParserState, context: Context): any {
  nextToken(parser, context);
  const expression = parseLiteral(parser, context);
  consume(parser, context, Token.RightParen);
  return finishNode({
    type: 'ExternalModuleReference',
    expression
  });
}

export function parseExportDefaultDeclaration(
  parser: ParserState,
  context: Context,
  decorators: ESTree.Decorator[] = []
): any {
  let declaration: any = null;
  nextToken(parser, context | Context.AllowRegExp);
  switch (parser.token) {
    // export default HoistableDeclaration[Default]
    case Token.FunctionKeyword: {
      declaration = parseFunctionDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.Hoisted,
        Origin.TopLevel,
        0,
        /* allowGen */ 1,
        false
      );
      break;
    }

    case Token.At:
    case Token.ClassKeyword:
      declaration =
        context & Context.OptionsTS
          ? parseTypescriptClassDeclaration(
              parser,
              context,
              ClassAndFunctionFlags.Hoisted,
              /* declare */ 0,
              /* abstract */ 0,
              decorators as any
            )
          : parseClassDeclaration(parser, context, ClassAndFunctionFlags.Hoisted);
      break;

    case Token.AsyncKeyword:
      declaration = parseIdentifier(parser, context);

      if (parser.precedingLineBreak === 0) {
        if (parser.token === Token.FunctionKeyword) {
          declaration = parseFunctionDeclaration(
            parser,
            context,
            ClassAndFunctionFlags.Hoisted,
            Origin.TopLevel,
            1,
            /* allowGen */ 1,
            false
          );
        } else {
          let typeParameters: any = null;

          if (context & Context.OptionsTS && parser.token === Token.LessThan) {
            typeParameters = parseTypeParameters(parser, context);
            if (parser.token !== Token.LeftParen) report(parser, context, Errors.Unexpected, /* early */ 0);
          }
          if (parser.token === Token.LeftParen) {
            declaration = parseAsyncArrowOrCallExpression(parser, context, 1, typeParameters, declaration);
            declaration = parseMemberOrUpdateExpression(parser, context, declaration as any);
            declaration = parseAssignmentExpression(parser, context, declaration as any);
          } else if ((parser.token & (Token.FutureReserved | Token.IdentifierOrKeyword)) !== 0) {
            declaration = parseIdentifier(parser, context);
            declaration = parseArrowFunctionExpression(parser, context, [declaration], null, null, 1, /* isAsync */ 1);
          }
        }
      }
      break;
    case Token.InterfaceKeyword:
      if (context & Context.OptionsTS) {
        declaration = parseDeclarationList(parser, context, /* isModule */ 1, 1, /* isExport */ false);
        break;
      }
    default:
      declaration = parseExpression(parser, context);
      consumeSemicolon(parser, context | Context.AllowRegExp);
  }

  return finishNode({
    type: 'ExportDefaultDeclaration',
    declaration
  });
}
export function parseExportDeclaration(parser: ParserState, context: Context): any {
  nextToken(parser, context | Context.AllowRegExp);

  const specifiers: any[] = [];

  let declaration: any = null;
  let source: ESTree.Literal | null = null;

  if (parser.token === Token.DefaultKeyword) {
    return parseExportDefaultDeclaration(parser, context) as any;
  }

  switch (parser.token) {
    case Token.Multiply: {
      let ecma262PR: 0 | 1 = 0;

      nextToken(parser, context); // Skips: '*'

      if (context & Context.OptionsNext && consumeOpt(parser, context, Token.AsKeyword)) {
        ecma262PR = 1;
        specifiers.push(
          finishNode({
            type: 'ExportNamespaceSpecifier',
            specifier: parseIdentifier(parser, context)
          })
        );
      }

      consume(parser, context, Token.FromKeyword);

      source = parseLiteral(parser, context);

      consumeSemicolon(parser, context | Context.AllowRegExp);

      return ecma262PR
        ? {
            type: 'ExportNamedDeclaration',
            source,
            specifiers
          }
        : ({
            type: 'ExportAllDeclaration',
            source
          } as any);
    }
    case Token.LeftBrace: {
      nextToken(parser, context); // Skips: '{'

      while ((parser.token & (Token.FutureReserved | Token.Keywords | Token.IdentifierOrKeyword)) !== 0) {
        const local = parseIdentifier(parser, context);

        let exported: ESTree.Identifier | null;

        if (parser.token === Token.AsKeyword) {
          nextToken(parser, context);
          exported = parseIdentifier(parser, context);
        } else {
          exported = local;
        }

        specifiers.push(
          finishNode({
            type: 'ExportSpecifier',
            local,
            exported
          } as any)
        );

        if (parser.token !== Token.RightBrace) consume(parser, context, Token.Comma);
      }

      consume(parser, context, Token.RightBrace);

      if (consumeOpt(parser, context, Token.FromKeyword)) {
        //  The left hand side can't be a keyword where there is no
        // 'from' keyword since it references a local binding.
        if (parser.token !== Token.StringLiteral) report(parser, context, Errors.UnexpectedToken, 0, 'Export');

        source = parseLiteral(parser, context);
      }

      consumeSemicolon(parser, context | Context.AllowRegExp);

      break;
    }

    case Token.At:
    case Token.ClassKeyword:
      declaration =
        context & Context.OptionsTS
          ? parseTypescriptClassDeclaration(
              parser,
              context,
              ClassAndFunctionFlags.None,
              /* declare */ 0,
              /* abstract */ 0
            )
          : parseClassDeclaration(parser, context, ClassAndFunctionFlags.None);
      break;

    case Token.FunctionKeyword:
      declaration = parseFunctionDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.Export,
        Origin.TopLevel,
        0,
        /* allowGen */ 1,
        false
      );
      break;

    case Token.LetKeyword:
      declaration = parseLexicalDeclaration(parser, context, BindingKind.Let, Origin.Export);
      break;
    case Token.ConstKeyword:
      declaration = parseLexicalDeclaration(parser, context, BindingKind.Const, Origin.Export | Origin.Declare);
      break;
    case Token.VarKeyword:
      declaration = parseVariableStatement(parser, context, Origin.Export);
      break;
    case Token.AsyncKeyword:
      nextToken(parser, context);
      if (parser.precedingLineBreak === 0 && parser.token === Token.FunctionKeyword) {
        declaration = parseFunctionDeclaration(
          parser,
          context,
          ClassAndFunctionFlags.Export,
          Origin.TopLevel,
          1,
          /* allowGen */ 1,
          false
        );
        break;
      }
    // falls through
    default:
      report(parser, context, Errors.UnexpectedToken, 0, KeywordDescTable[parser.token & Token.Type]);
  }

  return finishNode({
    type: 'ExportNamedDeclaration',
    source,
    specifiers,
    declaration
  });
}

export function parseStatement(parser: ParserState, context: Context, pos: number): any {
  switch (parser.token) {
    case Token.VarKeyword:
      return parseVariableStatement(parser, context, Origin.None);
    // [+Return] ReturnStatement[?Yield]
    case Token.ReturnKeyword:
      return parseReturnStatement(parser, context);
    case Token.IfKeyword:
      return parseIfStatement(parser, context);
    case Token.ForKeyword:
      return parseForStatement(parser, context);
    // BreakableStatement[Yield, Return]:
    //   IterationStatement[?Yield, ?Return]
    //   SwitchStatement[?Yield, ?Return]
    case Token.DoKeyword:
      return parseDoWhileStatement(parser, context);
    case Token.WhileKeyword:
      return parseWhileStatement(parser, context);
    case Token.SwitchKeyword:
      return parseSwitchStatement(parser, context);
    case Token.Semicolon:
      // EmptyStatement
      return parseEmptyStatement(parser, context);
    // BlockStatement[?Yield, ?Return]
    case Token.LeftBrace:
      return parseBlock(parser, context);
    // ThrowStatement[?Yield]
    case Token.ThrowKeyword:
      return parseThrowStatement(parser, context);
    case Token.BreakKeyword:
      // BreakStatement[?Yield]
      return parseBreakStatement(parser, context);
    // ContinueStatement[?Yield]
    case Token.ContinueKeyword:
      return parseContinueStatement(parser, context);
    // TryStatement[?Yield, ?Return]
    case Token.TryKeyword:
      return parseTryStatement(parser, context);
    // WithStatement[?Yield, ?Return]
    case Token.WithKeyword:
      return parseWithStatement(parser, context);
    case Token.DebuggerKeyword:
      // DebuggerStatement
      return parseDebuggerStatement(parser, context);
    case Token.AsyncKeyword:
      return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context);
    case Token.CatchKeyword:
    case Token.FinallyKeyword:
    case Token.FunctionKeyword:
    case Token.ClassKeyword:
      report(parser, context, Errors.Unexpected, /* early */ 0);
    default:
      const { token } = parser;
      const expr = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);
      return parseExpressionOrLabelledStatement(parser, context, expr, token, pos);
  }
}

export function parseExpressionOrLabelledStatement(
  parser: ParserState,
  context: Context,
  expr: any,
  token: Token,
  pos: number
): any {
  if (parser.token === Token.Colon) return parseLabelledStatement(parser, context, token, expr, pos);

  expr = parseMemberOrUpdateExpression(parser, context, expr);

  expr = parseAssignmentExpression(parser, context, expr);

  if (parser.token === Token.Comma) expr = parseSequenceExpression(parser, context, expr);

  return parseExpressionStatement(parser, context, expr);
}

function parseLetIdentOrVarDeclarationStatement(parser: ParserState, context: Context): any {
  const { token } = parser;

  let expr: any = parseIdentifier(parser, context);

  if (parser.token & (Token.IsIdentifier | Token.IsPatternStart)) {
    /* VariableDeclarations ::
     *  ('let') (Identifier ('=' AssignmentExpression)?)+[',']
     */

    const declarations = parseVariableDeclarationList(parser, context, BindingKind.Let, Origin.None);

    consumeSemicolon(parser, context | Context.AllowRegExp);

    return finishNode({
      type: 'VariableDeclaration',
      kind: 'let',
      declarations
    });
  }

  // 'Let' as identifier
  if (parser.token === Token.Colon) {
    return parseLabelledStatement(parser, context, token, expr, 1);
  }

  if (parser.token === Token.Arrow) {
    expr = parseArrowFunctionExpression(parser, context, [expr], null, null, 1, /* isAsync */ 0);
  } else {
    expr = parseMemberOrUpdateExpression(parser, context, expr);

    expr = parseAssignmentExpression(parser, context, expr);
  }

  /** Sequence expression
   */
  if (parser.token === Token.Comma) {
    expr = parseSequenceExpression(parser, context, expr);
  }

  return parseExpressionStatement(parser, context, expr);
}

export function parseReturnStatement(parser: ParserState, context: Context): ESTree.ReturnStatement {
  // ReturnStatement ::
  //   'return' [no line terminator] Expression? ';'
  nextToken(parser, context | Context.AllowRegExp);
  const argument =
    parser.precedingLineBreak || parser.token & Token.IsAutoSemicolon ? null : parseExpressions(parser, context);

  consumeSemicolon(parser, context | Context.AllowRegExp);

  return finishNode({
    type: 'ReturnStatement',
    argument
  });
}

export function parseEmptyStatement(parser: ParserState, context: Context): ESTree.EmptyStatement {
  nextToken(parser, context | Context.AllowRegExp);
  return finishNode({
    type: 'EmptyStatement'
  });
}

export function parseThrowStatement(parser: ParserState, context: Context): any {
  // ThrowStatement ::
  //   'throw' Expression ';'
  nextToken(parser, context | Context.AllowRegExp);

  const argument: ESTree.Expression = parseExpressions(parser, context);
  consumeSemicolon(parser, context | Context.AllowRegExp);
  return finishNode({
    type: 'ThrowStatement',
    argument
  } as any);
}

export function parseIfStatement(parser: ParserState, context: Context): ESTree.IfStatement {
  // IfStatement ::
  //   'if' '(' Expression ')' Statement ('else' Statement)?
  nextToken(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.LeftParen);
  const test = parseExpressions(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.RightParen);
  const consequent = parseConsequentOrAlternative(parser, context);
  let alternate: ESTree.Statement | null = null;
  if (parser.token === Token.ElseKeyword) {
    nextToken(parser, context | Context.AllowRegExp);
    alternate = parseConsequentOrAlternative(parser, context);
  }

  return finishNode({
    type: 'IfStatement',
    test,
    consequent,
    alternate
  });
}

export function parseForStatement(
  parser: ParserState,
  context: Context
): ESTree.ForStatement | ESTree.ForInStatement | ESTree.ForOfStatement {
  nextToken(parser, context);

  const forAwait = (context & Context.InAwaitContext) > 0 && consumeOpt(parser, context, Token.AwaitKeyword);

  consume(parser, context | Context.AllowRegExp, Token.LeftParen);

  let test: ESTree.Expression | null = null;
  let update: ESTree.Expression | null = null;
  let init = null;
  let isVarDecl =
    parser.token === Token.VarKeyword || parser.token === Token.LetKeyword || parser.token === Token.ConstKeyword;
  let right;

  const { token } = parser;

  if (isVarDecl) {
    if (token === Token.LetKeyword) {
      init = parseIdentifier(parser, context);
      if (parser.token & (Token.IsIdentifier | Token.IsPatternStart)) {
        if (parser.token === Token.InKeyword) {
          if (context & Context.Strict) report(parser, context, Errors.Unexpected, /* early */ 0);
        } else {
          init = {
            type: 'VariableDeclaration',
            kind: 'let',
            declarations: parseVariableDeclarationList(
              parser,
              context | Context.DisallowIn,
              BindingKind.Let,
              Origin.ForStatement
            )
          };
        }
      } else if (context & Context.Strict) {
        report(parser, context, Errors.Unexpected, /* early */ 0);
      } else {
        isVarDecl = false;

        init = parseMemberOrUpdateExpression(parser, context, init);

        // `for of` only allows LeftHandSideExpressions which do not start with `let`, and no other production matches
        if (parser.token === Token.OfKeyword) report(parser, context, Errors.Unexpected, /* early */ 1);
      }
    } else {
      nextToken(parser, context);

      init =
        token === Token.VarKeyword
          ? {
              type: 'VariableDeclaration',
              kind: 'var',
              declarations: parseVariableDeclarationList(
                parser,
                context | Context.DisallowIn,
                BindingKind.Variable,
                Origin.ForStatement
              )
            }
          : {
              type: 'VariableDeclaration',
              kind: 'const',
              declarations: parseVariableDeclarationList(
                parser,
                context | Context.DisallowIn,
                BindingKind.Const,
                Origin.ForStatement
              )
            };
    }
  } else if (token === Token.Semicolon) {
    if (forAwait) report(parser, context, Errors.Unexpected, /* early */ 1);
  } else if ((token & Token.IsPatternStart) === Token.IsPatternStart) {
    init =
      token === Token.LeftBrace
        ? parseObjectLiteralOrPattern(parser, context, 0, /* isPattern */ 0, [])
        : parseArrayExpressionOrPattern(parser, context, 0, /* isPattern */ 0, []);

    init = parseMemberOrUpdateExpression(parser, context | Context.DisallowIn, init as ESTree.Expression);
  } else {
    init = parseLeftHandSideExpression(parser, context | Context.DisallowIn, /* isLHS */ 1);
  }

  if (parser.token === Token.OfKeyword || parser.token === Token.InKeyword) {
    if (parser.token === Token.OfKeyword) {
      reinterpretToPattern(parser, init);
      nextToken(parser, context | Context.AllowRegExp);

      // IterationStatement:
      //  for(LeftHandSideExpression of AssignmentExpression) Statement
      //  forawait(LeftHandSideExpression of AssignmentExpression) Statement
      right = parseExpression(parser, context);

      consume(parser, context | Context.AllowRegExp, Token.RightParen);

      const body = parseIterationStatementBody(parser, context);

      return finishNode({
        type: 'ForOfStatement',
        body,
        left: init,
        right,
        await: forAwait
      });
    }

    reinterpretToPattern(parser, init);
    nextToken(parser, context | Context.AllowRegExp);

    // IterationStatement:
    //  for(LeftHandSideExpression in Expression) Statement
    right = parseExpressions(parser, context);

    consume(parser, context | Context.AllowRegExp, Token.RightParen);
    const body = parseIterationStatementBody(parser, context);

    return finishNode({
      type: 'ForInStatement',
      body,
      left: init,
      right
    });
  }

  if (!isVarDecl) {
    init = parseAssignmentExpression(parser, context | Context.DisallowIn, init);
  }

  if (parser.token === Token.Comma) init = parseSequenceExpression(parser, context, init);

  consume(parser, context | Context.AllowRegExp, Token.Semicolon);

  if (parser.token !== Token.Semicolon) test = parseExpressions(parser, context);

  consume(parser, context | Context.AllowRegExp, Token.Semicolon);

  if (parser.token !== Token.RightParen) update = parseExpressions(parser, context);

  consume(parser, context | Context.AllowRegExp, Token.RightParen);

  const body = parseIterationStatementBody(parser, context);

  return finishNode({
    type: 'ForStatement',
    body,
    init,
    test,
    update
  });
}

export function parseConsequentOrAlternative(
  parser: ParserState,
  context: Context
): ESTree.Statement | ESTree.FunctionDeclaration {
  return context & Context.Strict ||
    // Disallow if web compability is off
    //  context & Context.DisableWebCompat ||
    parser.token !== Token.FunctionKeyword
    ? parseStatement(parser, context, 0)
    : parseFunctionDeclaration(
        parser,
        context,
        ClassAndFunctionFlags.None,
        Origin.None,
        /* isAsync */ 0,
        /* allowGen */ 0,
        /* declare */ true
      );
}

export function parseSwitchStatement(parser: ParserState, context: Context): ESTree.SwitchStatement {
  // SwitchStatement ::
  //   'switch' '(' Expression ')' '{' CaseClause* '}'
  // CaseClause ::
  //   'case' Expression ':' StatementList
  //   'default' ':' StatementList
  nextToken(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.LeftParen);
  const discriminant = parseExpressions(parser, context);
  consume(parser, context, Token.RightParen);
  consume(parser, context, Token.LeftBrace);
  const cases: ESTree.SwitchCase[] = [];
  let seenDefault: 0 | 1 = 0;
  while (parser.token !== Token.RightBrace) {
    let test: ESTree.Expression | null = null;
    const consequent: ESTree.Statement[] = [];
    if (consumeOpt(parser, context | Context.AllowRegExp, Token.CaseKeyword)) {
      test = parseExpressions(parser, context);
    } else {
      consume(parser, context | Context.AllowRegExp, Token.DefaultKeyword);
      if (seenDefault) report(parser, context, Errors.Unexpected, /* early */ 0);
      seenDefault = 1;
    }
    consume(parser, context | Context.AllowRegExp, Token.Colon);
    while (
      parser.token !== Token.CaseKeyword &&
      parser.token !== Token.RightBrace &&
      parser.token !== Token.DefaultKeyword
    ) {
      consequent.push(parseStatementListItem(parser, context | Context.InSwitch, 0) as ESTree.Statement);
    }

    cases.push(
      finishNode({
        type: 'SwitchCase',
        test,
        consequent
      })
    );
  }

  consume(parser, context | Context.AllowRegExp, Token.RightBrace);
  return finishNode({
    type: 'SwitchStatement',
    discriminant,
    cases
  });
}

export function parseWhileStatement(parser: ParserState, context: Context): ESTree.WhileStatement {
  // WhileStatement ::
  //   'while' '(' Expression ')' Statement
  nextToken(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.LeftParen);
  const test = parseExpressions(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.RightParen);
  const body = parseIterationStatementBody(parser, context);
  return finishNode({
    type: 'WhileStatement',
    test,
    body
  });
}

export function parseIterationStatementBody(parser: ParserState, context: Context): ESTree.Statement {
  return parseStatement(parser, ((context | Context.DisallowIn) ^ Context.DisallowIn) | Context.InIteration, 0);
}

export function parseContinueStatement(parser: ParserState, context: Context): ESTree.ContinueStatement {
  // ContinueStatement ::
  //   'continue' Identifier? ';'
  nextToken(parser, context);
  let label: any = null;
  if (parser.precedingLineBreak === 0 && parser.token & Token.IsIdentifier) {
    label = parseIdentifier(parser, context | Context.AllowRegExp);
  }
  consumeSemicolon(parser, context | Context.AllowRegExp);
  return finishNode({
    type: 'ContinueStatement',
    label
  });
}

export function parseBreakStatement(parser: ParserState, context: Context): ESTree.BreakStatement {
  // BreakStatement ::
  //   'break' Identifier? ';'
  nextToken(parser, context | Context.AllowRegExp);
  let label: any = null;
  if (parser.precedingLineBreak === 0 && parser.token & Token.IsIdentifier) {
    label = parseIdentifier(parser, context | Context.AllowRegExp);
  } else if ((context & (Context.InSwitch | Context.InIteration)) < 1) {
    report(parser, context, Errors.Unexpected, /* early */ 1);
  }

  consumeSemicolon(parser, context | Context.AllowRegExp);
  return finishNode({
    type: 'BreakStatement',
    label
  });
}

export function parseWithStatement(parser: ParserState, context: Context): ESTree.WithStatement {
  // WithStatement ::
  //   'with' '(' Expression ')' Statement

  nextToken(parser, context);

  if (context & Context.Strict) report(parser, context, Errors.Unexpected, /* early */ 1);

  consume(parser, context | Context.AllowRegExp, Token.LeftParen);
  const object = parseExpressions(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.RightParen);
  const body = parseStatement(parser, context, 0);
  return finishNode({
    type: 'WithStatement',
    object,
    body
  });
}

export function parseDebuggerStatement(parser: ParserState, context: Context): ESTree.DebuggerStatement {
  // DebuggerStatement ::
  //   'debugger' ';'
  nextToken(parser, context | Context.AllowRegExp);
  consumeSemicolon(parser, context | Context.AllowRegExp);
  return finishNode({
    type: 'DebuggerStatement'
  });
}

export function parseTryStatement(parser: ParserState, context: Context): ESTree.TryStatement {
  nextToken(parser, context | Context.AllowRegExp);

  const block = parseBlock(parser, context);

  const handler = consumeOpt(parser, context | Context.AllowRegExp, Token.CatchKeyword)
    ? parseCatchBlock(parser, context)
    : null;

  let finalizer: any = null;

  if (parser.token === Token.FinallyKeyword) {
    nextToken(parser, context | Context.AllowRegExp);
    finalizer = parseBlock(parser, context);
  }

  if (!handler && !finalizer) {
    report(parser, context, Errors.Unexpected, /* early */ 0);
  }

  return finishNode({
    type: 'TryStatement',
    block,
    handler,
    finalizer
  });
}

export function parseCatchBlock(parser: ParserState, context: Context): ESTree.CatchClause {
  let param: any = null;

  if (consumeOpt(parser, context, Token.LeftParen)) {
    param = parseBindingPattern(parser, context);

    consume(parser, context | Context.AllowRegExp, Token.RightParen);
  }

  const body = parseBlock(parser, context);

  return finishNode({
    type: 'CatchClause',
    param,
    body
  });
}

export function parseDoWhileStatement(parser: ParserState, context: Context): ESTree.DoWhileStatement {
  // DoStatement ::
  //   'do Statement while ( Expression ) ;'

  nextToken(parser, context | Context.AllowRegExp);
  const body = parseIterationStatementBody(parser, context);
  consume(parser, context, Token.WhileKeyword);
  consume(parser, context | Context.AllowRegExp, Token.LeftParen);
  const test = parseExpressions(parser, context);
  consume(parser, context | Context.AllowRegExp, Token.RightParen);
  consumeSemicolon(parser, context | Context.AllowRegExp);
  return finishNode({
    type: 'DoWhileStatement',
    body,
    test
  });
}

export function parseLexicalDeclaration(
  parser: ParserState,
  context: Context,
  kind: BindingKind,
  origin: Origin
): ESTree.VariableDeclaration {
  // BindingList ::
  //  LexicalBinding
  //    BindingIdentifier
  //    BindingPattern
  nextToken(parser, context);

  const declarations = parseVariableDeclarationList(parser, context, kind, origin);

  consumeSemicolon(parser, context | Context.AllowRegExp);

  return finishNode({
    type: 'VariableDeclaration',
    kind: kind & BindingKind.Let ? 'let' : 'const',
    declarations
  });
}

export function parseVariableStatement(
  parser: ParserState,
  context: Context,
  origin: Origin
): ESTree.VariableDeclaration {
  // VariableDeclarations ::
  //  ('var') (Identifier ('=' AssignmentExpression)?)+[',']
  //
  const token = parser.token;
  nextToken(parser, context);
  const declarations = parseVariableDeclarationList(parser, context, BindingKind.Variable, origin);

  consumeSemicolon(parser, context | Context.AllowRegExp);

  return finishNode({
    type: 'VariableDeclaration',
    kind: KeywordDescTable[token & Token.Type] as 'var' | 'let' | 'const',
    declarations
  });
}

export function parseVariableDeclarationList(
  parser: ParserState,
  context: Context,
  kind: BindingKind,
  origin: Origin
): ESTree.VariableDeclarator[] {
  const list: any[] = [parseVariableDeclaration(parser, context, kind, origin)];
  while (consumeOpt(parser, context, Token.Comma)) {
    list.push(parseVariableDeclaration(parser, context, kind, origin));
  }

  return list;
}

export function parseVariableDeclaration(
  parser: ParserState,
  context: Context,
  kind: BindingKind,
  origin: Origin
): ESTree.VariableDeclarator {
  let init: ESTree.Expression | null = null;
  let definite = false;
  const token = parser.token;

  const id = parseBindingPattern(parser, context);

  if (context & Context.OptionsTS && token & Token.IsIdentifier && id.name & TypeScriptMadness.Definite) {
    id.name = id.name ^ TypeScriptMadness.Definite;
    definite = true;
  }

  if (parser.token === Token.Assign) {
    nextToken(parser, context | Context.AllowRegExp);
    init = parseExpression(parser, context);
    if (origin & Origin.ForStatement || (token & Token.IsPatternStart) < 1) {
      // Lexical declarations in for-in / for-of loops can't be initialized

      if (
        parser.token === Token.OfKeyword ||
        (parser.token === Token.InKeyword &&
          (token & Token.IsPatternStart ||
            (kind & BindingKind.Variable) < 1 ||
            context & Context.DisableWebCompat ||
            context & Context.Strict))
      ) {
        report(
          parser,
          context,
          Errors.ForInOfLoopInitializer,
          /* early */ 1,
          parser.token === Token.OfKeyword ? 'of' : 'in'
        );
      }
    }
    // Normal const declarations, and const declarations in for(;;) heads, must be initialized.
  } else if (
    (token & Token.IsPatternStart) > 0 &&
    (context & Context.OptionsTS &&
      (origin & Origin.Declare) === 0 &&
      (parser.token !== Token.OfKeyword && parser.token !== Token.InKeyword))
  ) {
    report(
      parser,
      context,
      Errors.DeclarationMissingInitializer,
      /* early */ 1,
      kind & BindingKind.Const ? 'const' : 'destructuring'
    );
  }

  return context & Context.OptionsTS
    ? {
        type: 'VariableDeclarator',
        init,
        id,
        definite
      }
    : {
        type: 'VariableDeclarator',
        init,
        id
      };
}

export function parseBindingPattern(parser: ParserState, context: Context): any {
  if ((parser.token & Token.IdentifierOrKeyword) > 0) {
    return context & Context.OptionsTS
      ? parseBindingIdentifier(parser, context, /* requireTypeAnnotation */ 0, /* canBeOptionalParam */ 1)
      : parseIdentifier(parser, context);
  }

  if ((parser.token & Token.IsPatternStart) !== Token.IsPatternStart)
    report(parser, context, Errors.UnexpectedToken, /* early */ 1, KeywordDescTable[parser.token & Token.Type]);

  let left: any;

  if (parser.token === Token.LeftBrace) {
    left = parseObjectLiteralOrPattern(parser, context, 1, /* isPattern */ 1, []);
  } else if (parser.token === Token.LeftBracket) {
    left = parseArrayExpressionOrPattern(parser, context, 1, /* isPattern */ 1, []);
  }
  reinterpretToPattern(parser, left);
  return left;
}

export function parseSequenceExpression(parser: ParserState, context: Context, expr: any): ESTree.SequenceExpression {
  const expressions: any[] = [expr];
  while (consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) {
    expressions.push(parseExpression(parser, context));
  }

  return finishNode({
    type: 'SequenceExpression',
    expressions
  });
}

export function parseExpression(parser: ParserState, context: Context): any {
  const expr = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

  return parseAssignmentExpression(parser, context, expr);
}

export function parseExpressions(parser: ParserState, context: Context): ESTree.Expression {
  const expr = parseExpression(parser, context);
  return parser.token === Token.Comma ? parseSequenceExpression(parser, context, expr) : expr;
}

export function parseLeftHandSideExpression(parser: ParserState, context: Context, isLHS: 0 | 1): any {
  const expr = parsePrimaryExpression(parser, context, isLHS, /* inParen */ 0);

  return parseMemberOrUpdateExpression(parser, context, expr);
}

export function parseAssignmentExpression(parser: ParserState, context: Context, left: any): ESTree.Expression {
  if ((parser.token & Token.IsAssignOp) === Token.IsAssignOp) {
    const token = parser.token;
    if (
      (token === Token.Assign && ((left as ESTree.Expression).type as string) === 'ArrayExpression') ||
      ((left as ESTree.Expression).type as string) === 'ObjectExpression'
    ) {
      reinterpretToPattern(parser, left);
    }
    nextToken(parser, context | Context.AllowRegExp);
    const right = parseExpression(parser, context);

    return finishNode({
      type: 'AssignmentExpression',
      left,
      operator: KeywordDescTable[token & Token.Type] as ESTree.AssignmentOperator,
      right
    });
  }

  if ((parser.token & Token.IsBinaryOp) === Token.IsBinaryOp) {
    left = parseBinaryExpression(parser, context, 4, parser.token, left);
  }

  if (consumeOpt(parser, context | Context.AllowRegExp, Token.QuestionMark)) {
    left = parseConditionalExpression(parser, context, left);
  }

  return left;
}

export function parseConditionalExpression(
  parser: ParserState,
  context: Context,
  test: ESTree.Expression
): ESTree.Expression {
  const consequent = parseExpression(parser, (context | Context.DisallowIn | Context.Conditional) ^ Context.DisallowIn);
  consume(parser, context | Context.AllowRegExp, Token.Colon);
  const alternate = parseExpression(parser, context);

  return finishNode({
    type: 'ConditionalExpression',
    test,
    consequent,
    alternate
  });
}

export function parseBinaryExpression(
  parser: ParserState,
  context: Context,
  minPrec: number,
  operator: Token,
  left: any
): ESTree.Expression {
  const bit = -((context & Context.DisallowIn) > 0) & Token.InKeyword;
  const isTS = context & Context.OptionsTS;
  let t: Token;
  let prec: number;

  while (parser.token & Token.IsBinaryOp) {
    t = parser.token;
    prec = t & Token.Precedence;

    if ((t & Token.IsLogical && operator & Token.IsCoalesc) || (operator & Token.IsLogical && t & Token.IsCoalesc)) {
      report(parser, context, Errors.InvalidCoalescing, /* early */ 1);
    }

    if (prec + (((t === Token.Exponentiate) as any) << 8) - (((bit === t) as any) << 12) <= minPrec) break;

    if (isTS && t === Token.AsKeyword) {
      if (parser.precedingLineBreak) return left;
      nextToken(parser, context | Context.AllowRegExp);
      left = parseAsExpression(parser, context, left);
    } else {
      nextToken(parser, context | Context.AllowRegExp);
      left = {
        type:
          t & Token.IsLogical ? 'LogicalExpression' : t & Token.IsCoalesc ? 'CoalesceExpression' : 'BinaryExpression',
        left,
        right: parseBinaryExpression(
          parser,
          context,
          prec,
          t,
          parseLeftHandSideExpression(parser, context, /* isLHS */ 1)
        ),
        operator: KeywordDescTable[t & Token.Type]
      };
    }
  }
  return left;
}

function parseAsExpression(parser: ParserState, context: Context, expression: any): ESTree.AsExpression {
  const typeAnnotation = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
  return finishNode({
    type: 'AsExpression',
    expression,
    typeAnnotation
  });
}

export function parseMemberOrUpdateExpression(
  parser: ParserState,
  context: Context,
  expr: any,
  isOptional: 0 | 1 = 0,
  optionalChaining: 0 | 1 = 0
): any {
  if ((parser.token & Token.IsUpdateOp) === Token.IsUpdateOp && !parser.precedingLineBreak) {
    const { token } = parser;

    nextToken(parser, context);

    return finishNode({
      type: 'UpdateExpression',
      argument: expr,
      operator: KeywordDescTable[token & Token.Type] as ESTree.UpdateOperator,
      prefix: false
    });
  }

  context = (context | Context.DisallowIn | Context.InGlobal) ^ (Context.DisallowIn | Context.InGlobal);

  switch (parser.token) {
    /* Property */
    case Token.Period: {
      nextToken(parser, context);

      if (
        isOptional &&
        (parser.token & (Token.Contextual | Token.Keywords | Token.FutureReserved | Token.IsIdentifier)) === 0
      ) {
        report(
          parser,
          context,
          Errors.UnexpectedToken,
          /* early */ 1,
          'Nchanged does not like optional chaning with number literals'
        );
      }

      const property = parseIdentifier(parser, context);

      return parseMemberOrUpdateExpression(
        parser,
        context,
        finishNode({
          type: isOptional ? 'OptionalMemberExpression' : 'MemberExpression',
          object: expr,
          computed: false,
          optional: isOptional === 1,
          property
        } as any)
      );
    }

    /* Property */
    case Token.LeftBracket: {
      if (context & Context.InDecoratorContext) return expr;

      nextToken(parser, context | Context.AllowRegExp);

      const property = parseExpressions(parser, context);

      consume(parser, context, Token.RightBracket);
      return parseMemberOrUpdateExpression(
        parser,
        context,
        finishNode({
          type: isOptional ? 'OptionalMemberExpression' : 'MemberExpression',
          optional: isOptional === 1,
          object: expr,
          computed: true,
          property
        } as any)
      );
    }

    /* Call */
    case Token.LeftParen: {
      const args = parseArguments(parser, context);
      return parseMemberOrUpdateExpression(
        parser,
        context,
        context & Context.OptionsTS
          ? finishNode({
              type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
              callee: expr,
              arguments: args,
              optional: isOptional === 1,
              typeParameters: null
            } as any)
          : finishNode({
              type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
              callee: expr,
              optional: isOptional === 1,
              arguments: args
            } as any)
      );
    }

    case Token.LessThan: {
      if ((context & Context.OptionsTS) === 0) return expr;
      const typeParameters: any = tryScan(parser, context, function(): any {
        nextToken(parser, context);
        const params: any[] = [];
        while (parser.token !== Token.GreaterThan) {
          params.push(
            parseType(
              parser,
              context | Context.Speculative,
              /* restrictedTypes */ 0,
              /* isMappedType */ 0,
              TypeAliasState.None
            )
          );
          if (parser.token !== Token.GreaterThan) {
            if (!consumeOpt(parser, context, Token.Comma)) break;
          }
        }

        if (!consumeOpt(parser, context, Token.GreaterThan)) {
          return undefined;
        }

        return params && canFollowTypeArgumentsInExpression(parser)
          ? finishNode({
              type: 'TypeParameterInstantiation',
              params
            })
          : undefined;
      });

      if (typeParameters === undefined) return expr;
      let node: any;
      if (parser.token === Token.LeftParen) {
        const args = parseArguments(parser, context);
        node =
          context & Context.OptionsTS
            ? {
                type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
                callee: expr,
                optional: isOptional === 1,
                arguments: args,
                typeParameters
              }
            : {
                type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
                callee: expr,
                optional: isOptional === 1,
                arguments: args
              };
      } else if (parser.token === Token.TemplateTail) {
        node = parseTaggedTemplateExpression(parser, context, expr, typeParameters);
      }

      return parseMemberOrUpdateExpression(parser, context, node);
    }

    case Token.Negate: {
      if ((context & Context.OptionsTS) === 0 || parser.precedingLineBreak) return expr;
      nextToken(parser, context);

      return parseMemberOrUpdateExpression(parser, context, {
        type: 'NonNullExpression',
        expression: expr
      });
    }
    case Token.TemplateCont:
    case Token.TemplateTail:
      /* Tagged Template */
      return parseMemberOrUpdateExpression(parser, context, parseTaggedTemplateExpression(parser, context, expr, []));

    case Token.QuestionMarkPeriod:
      nextToken(parser, context); // skips: '?.'

      isOptional = 1;
      optionalChaining = 1;

      /* Optional Property */
      if (parser.token & Token.IsIdentifier) {
        const property = parseIdentifier(parser, context);
        return parseMemberOrUpdateExpression(
          parser,
          context,
          {
            type: 'OptionalMemberExpression',
            object: expr,
            computed: false,
            property,
            optional: true
          },
          isOptional,
          optionalChaining
        );
      }

      return parseMemberOrUpdateExpression(parser, context, expr, isOptional, optionalChaining);

    default:
      return expr;
  }
}

export function parseTaggedTemplateExpression(
  parser: ParserState,
  context: Context,
  expr: any,
  typeParameters: any
): any {
  return context & Context.OptionsTS
    ? {
        type: 'TaggedTemplateExpression',
        typeParameters,
        tag: expr,
        quasi:
          parser.token === Token.TemplateCont
            ? parseTemplateLiteral(parser, context)
            : parseNoSubstitutionTemplate(parser, context | Context.TaggedTemplate)
      }
    : {
        type: 'TaggedTemplateExpression',
        tag: expr,
        quasi:
          parser.token === Token.TemplateCont
            ? parseTemplateLiteral(parser, context)
            : parseNoSubstitutionTemplate(parser, context | Context.TaggedTemplate)
      };
}

export function parseArguments(parser: ParserState, context: Context): any[] {
  nextToken(parser, context | Context.AllowRegExp);

  const args: any[] = [];

  if (consumeOpt(parser, context, Token.RightParen)) return args;

  while (parser.token !== Token.RightParen) {
    if (parser.token === Token.Ellipsis) {
      args.push(parseSpreadElement(parser, context));
    } else {
      args.push(parseExpression(parser, context));
    }

    if (parser.token !== Token.Comma) break;

    nextToken(parser, context | Context.AllowRegExp);

    if (parser.token === Token.RightParen) break;
  }

  consume(parser, context, Token.RightParen);

  return args;
}

export function parseSpreadElement(parser: ParserState, context: Context): ESTree.SpreadElement {
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  consume(parser, context | Context.AllowRegExp, Token.Ellipsis);
  const argument = parseExpression(parser, context);
  return finishNode({
    type: 'SpreadElement',
    argument
  });
}

export function parseLabelledStatement(
  parser: ParserState,
  context: Context,
  _t: Token,
  expr: any,
  pos: number
): ESTree.LabeledStatement {
  nextToken(parser, context | Context.AllowRegExp); // skip: ':'

  const body =
    (context & Context.Strict) < 1 &&
    (context & Context.DisableWebCompat) < 1 &&
    // In sloppy mode, Annex B.3.2 allows labelled function declarations.
    // Otherwise it's a parse error.
    parser.token === Token.FunctionKeyword
      ? parseFunctionDeclaration(
          parser,
          context,
          ClassAndFunctionFlags.None,
          Origin.Statement,
          /* isAsync */ 0,
          /* allowGen */ 0,
          /* declare */ false
        )
      : parseStatement(parser, context, pos);

  return finishNode({
    type: 'LabeledStatement',
    label: expr as any,
    body
  });
}

export function parseExpressionStatement(
  parser: ParserState,
  context: Context,
  expression: any
): ESTree.ExpressionStatement {
  consumeSemicolon(parser, context | Context.AllowRegExp);

  return finishNode({
    type: 'ExpressionStatement',
    expression
  });
}

export function parseFunctionDeclaration(
  parser: ParserState,
  context: Context,
  flags: ClassAndFunctionFlags,
  origin: Origin,
  isAsync: 0 | 1,
  allowGen: 0 | 1,
  declare: boolean
): ESTree.FunctionDeclaration | ESTree.DeclareFunction {
  nextToken(parser, context); // skip: 'function'

  let id: any = null;

  const isTypescript = context & Context.OptionsTS;
  const isGenerator = allowGen && optionalBit(parser, context, Token.Multiply);

  if (parser.token === Token.LeftParen) {
    if ((flags & ClassAndFunctionFlags.Hoisted) < 1)
      report(parser, context, Errors.DeclNoName, /* early */ 1, 'Function');
  } else {
    validateFunctionName(parser, context | ((context & 0b0000000000000000000_1100_00000000) << 11), parser.token);
    id = parseIdentifier(parser, context);
  }
  const typeParameters = isTypescript && parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;

  context =
    ((context | 0b0000001111011000000_0000_00000000) ^ 0b0000001111011000000_0000_00000000) |
    Context.AllowNewTarget |
    ((isAsync * 2 + isGenerator) << 21);

  let params: any;
  let returnType: any = null;

  if (isTypescript) {
    params = parseTypeScriptFormalParametersOrFormalList(parser, context);
    returnType =
      parser.token === Token.Colon ? parseTypeOrTypePredicate(parser, context, /* restrictedTypes */ 0) : null;
  } else {
    params = parseFormalParametersOrFormalList(parser, context);
  }

  const body = parseFunctionBody(
    parser,
    (context | Context.InGlobal | Context.InSwitch | Context.InIteration) ^
      (Context.InGlobal | Context.InSwitch | Context.InIteration),
    origin
  );

  if (isTypescript) {
    return finishNode({
      type: body ? 'FunctionDeclaration' : 'DeclareFunction',
      params,
      body,
      async: isAsync === 1,
      generator: isGenerator === 1,
      id,
      typeParameters,
      returnType,
      declare
    } as any);
  }

  return finishNode({
    type: 'FunctionDeclaration',
    params,
    body,
    async: isAsync === 1,
    generator: isGenerator === 1,
    id
  });
}

export function parseFunctionExpression(parser: ParserState, context: Context, isAsync: 0 | 1): any {
  nextToken(parser, context); // skip: 'function'

  let id: ESTree.Identifier | null = null;

  const isTypescript = context & Context.OptionsTS;
  const isGenerator = optionalBit(parser, context, Token.Multiply);
  const generatorAndAsyncFlags = (isAsync * 2 + isGenerator) << 21;

  if ((parser.token & (Token.Keywords | Token.FutureReserved | Token.IsIdentifier)) !== 0) {
    validateFunctionName(parser, ((context | 0x1ec0000) ^ 0x1ec0000) | generatorAndAsyncFlags, parser.token);
    id = parseIdentifier(parser, context);
  }
  const typeParameters = isTypescript && parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;

  context =
    ((context | 0b0000001111011000000_0000_00000000) ^ 0b0000001111011000000_0000_00000000) |
    Context.AllowNewTarget |
    generatorAndAsyncFlags;

  let params: any;
  let returnType: any = null;

  if (isTypescript) {
    params = parseTypeScriptFormalParametersOrFormalList(parser, context);
    returnType =
      parser.token === Token.Colon ? parseTypeOrTypePredicate(parser, context, /* restrictedTypes */ 0) : null;
  } else {
    params = parseFormalParametersOrFormalList(parser, context);
  }

  const body = parseFunctionBody(
    parser,
    context & ~(0x8001000 | Context.InGlobal | Context.InSwitch | Context.InIteration | Context.InClass),
    Origin.None
  );

  if (isTypescript) {
    return finishNode({
      type: body ? 'FunctionExpression' : 'EmptyBodyFunctionExpression',
      params,
      body,
      async: isAsync === 1,
      generator: isGenerator === 1,
      id,
      typeParameters,
      returnType,
      declare: false
    } as any);
  }

  return finishNode({
    type: 'FunctionExpression',
    params,
    body,
    async: isAsync === 1,
    generator: isGenerator === 1,
    id
  });
}

export function parseTypeFromNonArray(
  parser: ParserState,
  context: Context,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
) {
  const type = parseNonArrayType(parser, context, /* isReadOnly */ 0, restrictedTypes, isMappedType, typeAlias);
  return parseUnionAndIntersectionType(parser, context, type, restrictedTypes, isMappedType, typeAlias);
}

export function parseUnionAndIntersectionType(
  parser: ParserState,
  context: Context,
  type: any,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): ESTree.IntersectionType | ESTree.UnionType {
  type = parsePostFixTypeOrHigher(parser, context, type);

  if (parser.token === Token.BitwiseAnd) {
    const types = [type];
    while (consumeOpt(parser, context, Token.BitwiseAnd)) {
      types.push(
        parseTypeOperatorOrHigher(parser, context, /* isReadOnly */ 0, restrictedTypes, isMappedType, typeAlias)
      );
    }
    type = finishNode({
      type: 'IntersectionType',
      types
    });
  }

  if (parser.token === Token.BitwiseOr) {
    const types = [type];
    while (consumeOpt(parser, context, Token.BitwiseOr)) {
      types.push(parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias));
    }
    type = finishNode({
      type: 'UnionType',
      types
    });
  }

  return type;
}
export function parseTypeFromValue(parser: ParserState, context: Context, value: string) {
  let type: any = primaryTypes[value];

  if (type) return { type };

  type = parseIdentifierFromValue(parser, context, value, /* allowAnnotations */ 0);
  type = parseQualifiedName(parser, context, type);

  return parseTypeReferenceFromExpression(parser, context, type);
}

export function parseTypeOrTypePredicate(parser: ParserState, context: Context, restrictedTypes: 0 | 1): any {
  consumeOpt(parser, context, Token.Colon); // nextToken(parser, context); // skip: ':'
  const { token, tokenValue } = parser;
  let type: any;
  if (parser.token === Token.InferKeyword || (token & Token.IsIdentifier) === 0) {
    type = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
  } else {
    nextToken(parser, context);
    type = parseIdentifierFromValue(parser, context, tokenValue, 0);
    if (parser.token === Token.IsKeyword && !parser.precedingLineBreak) {
      type = finishNode({
        type: 'TypePredicate',
        assertsModifier: false,
        parameterName: type,
        typeAnnotation: parseTypeAnnotation(parser, context, restrictedTypes)
      });
    } else {
      type = parseTypeFromValue(parser, context, tokenValue);
      type = parseUnionAndIntersectionType(parser, context, type, restrictedTypes, 0, 0);

      if (parser.precedingLineBreak === 0 && consumeOpt(parser, context, Token.ExtendsKeyword)) {
        type = parseConditionalType(parser, context, restrictedTypes, 0, 0, type);
      }
    }
  }

  return finishNode({
    type: 'TypeAnnotation',
    typeAnnotation: type
  });
}

export function parseTypescriptClassDeclaration(
  parser: ParserState,
  context: Context,
  flags: ClassAndFunctionFlags,
  declare: 0 | 1,
  abstract: 0 | 1,
  exportDecorators = [],
  decl = false
): ESTree.ClassDeclaration {
  const decorators: ESTree.Decorator[] =
    flags & (ClassAndFunctionFlags.Export | ClassAndFunctionFlags.Hoisted) || decl
      ? exportDecorators
      : parseDecorators(parser, context);

  nextToken(parser, context);

  context =
    (context | Context.InConstructor | Context.Strict | Context.DisallowIn) ^
    (Context.DisallowIn | Context.InConstructor);

  let id: ESTree.Identifier | null = null;

  if (
    ((parser.token & 0b0000000000000000001_0000_11111111) ^ 0b0000000000000000000_0000_01010100) >
    0b0000000000000000001_0000_00000000
  ) {
    if (isStrictReservedWord(parser, context, parser.token)) {
      report(parser, context, Errors.UnexpectedStrictReserved, /* early */ 1);
    }
    id = parseIdentifier(parser, context);
  } else {
    if ((flags & ClassAndFunctionFlags.Hoisted) < 1) report(parser, context, Errors.DeclNoName, /* early */ 1, 'Class');
  }
  return parseTypescriptClassDeclarationOrExpression(
    parser,
    context,
    id as ESTree.Identifier,
    decorators,
    Origin.Declaration,
    /* isExpr */ 0,
    declare,
    abstract,
    'ClassDeclaration',
    'ClassImplements'
  ) as ESTree.ClassDeclaration;
}

export function parseTypescriptClassDeclarationOrExpression(
  parser: ParserState,
  context: Context,
  id: ESTree.Identifier,
  decorators: ESTree.Decorator[],
  origin: Origin,
  isExpr: 0 | 1,
  declare: 0 | 1,
  abstract: 0 | 1,
  type: 'ClassDeclaration' | 'ClassExpression',
  heritage: 'ClassImplements' | 'InterfaceHeritage'
): ESTree.ClassDeclaration | ESTree.ClassExpression {
  let superClass: ESTree.LeftHandSideExpression | null = null;
  let superTypeParameters: ESTree.TypeParameterInstantiation[] = [];

  const implement: ESTree.ExpressionWithTypeArguments[] = [];

  const typeParameters = parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;

  let inheritedContext = context;

  if (parser.token === Token.ExtendsKeyword) {
    nextToken(parser, context | Context.AllowRegExp);
    inheritedContext |= Context.SuperCall;
    superClass = parseLeftHandSideExpression(parser, context, /* isLHS */ 0);
  } else {
    inheritedContext = (inheritedContext | Context.SuperCall) ^ Context.SuperCall;
  }

  if (parser.token === Token.LessThan) superTypeParameters = parseTypeParameterInstantiation(parser, context);

  if (parser.token === Token.ImplementsKeyword) {
    nextToken(parser, context | Context.AllowRegExp);
    let delimitedCount = 0;
    while ((parser.token & Token.IdentifierOrKeyword) > 0) {
      implement.push(parseHeritageClausesOrClassImplements(parser, inheritedContext, heritage));
      delimitedCount++;
      if (parser.token !== Token.Comma) break;
      consume(parser, context, Token.Comma);
    }
    if (!delimitedCount) report(parser, context, Errors.EmptyImplementList, /* early */ 0);
  }

  const body = parseClassMembers(parser, inheritedContext, context, origin, isExpr, abstract, declare);

  return finishNode({
    type,
    id,
    superClass,
    body,
    typeParameters,
    superTypeParameters,
    implements: implement,
    abstract: abstract === 1,
    declare: declare === 1,
    decorators
  } as any);
}

export function parseClassDeclaration(
  parser: ParserState,
  context: Context,
  flags: ClassAndFunctionFlags
): ESTree.ClassDeclaration {
  nextToken(parser, context);

  context = (context | Context.InConstructor | Context.DisallowIn) ^ (Context.DisallowIn | Context.InConstructor);

  let id: ESTree.Identifier | null = null;

  if (
    ((parser.token & 0b0000000000000000001_0000_11111111) ^ 0b0000000000000000000_0000_01010100) >
    0b0000000000000000001_0000_00000000
  ) {
    if (isStrictReservedWord(parser, context, parser.token)) {
      report(parser, context, Errors.UnexpectedStrictReserved, /* early */ 1);
    }

    id = parseIdentifier(parser, context);
  } else {
    if ((flags & ClassAndFunctionFlags.Hoisted) < 1) report(parser, context, Errors.DeclNoName, /* early */ 1, 'Class');
  }

  return parseClassDeclarationOrExpression(
    parser,
    context,
    id,
    Origin.Declaration,
    'ClassDeclaration'
  ) as ESTree.ClassDeclaration;
}

export function parseClassDeclarationOrExpression(
  parser: ParserState,
  context: Context,
  id: any,
  origin: Origin,
  type: 'ClassDeclaration' | 'ClassExpression'
): ESTree.ClassDeclaration | ESTree.ClassExpression {
  let inheritedContext = context | Context.Strict;
  let superClass: ESTree.LeftHandSideExpression | null = null;

  if (parser.token === Token.ExtendsKeyword) {
    nextToken(parser, context | Context.AllowRegExp);
    superClass = parseLeftHandSideExpression(parser, context, /* isLHS */ 0);
    inheritedContext |= Context.SuperCall;
  } else {
    inheritedContext = (inheritedContext | Context.SuperCall) ^ Context.SuperCall;
  }

  const body = parseClassBody(parser, inheritedContext, context, origin);

  return finishNode({
    type,
    id,
    superClass,
    body
  });
}

export function parseTypescriptClassExpression(parser: ParserState, context: Context): ESTree.ClassExpression {
  nextToken(parser, context);

  // All class code is always strict mode implicitly
  context =
    (context | Context.InConstructor | Context.Strict | Context.DisallowIn) ^
    (Context.DisallowIn | Context.InConstructor);
  const decorators: ESTree.Decorator[] = [];

  let id: ESTree.Identifier | null = null;

  if (((parser.token & 0x10ff) ^ 0x54) > 0x1000 && parser.token !== Token.ImplementsKeyword) {
    if (isStrictReservedWord(parser, context, parser.token)) {
      report(parser, context, Errors.UnexpectedStrictReserved, /* early */ 1);
    }

    id = parseIdentifier(parser, context);
  }
  return parseTypescriptClassDeclarationOrExpression(
    parser,
    context,
    id as ESTree.Identifier,
    decorators,
    Origin.None,
    /* isExpr */ 1,
    0,
    0,
    'ClassExpression',
    'InterfaceHeritage'
  ) as ESTree.ClassExpression;
}

export function parseClassExpression(parser: ParserState, context: Context): any {
  let id: ESTree.Identifier | null = null;

  // All class code is always strict mode implicitly
  context =
    (context | Context.InConstructor | Context.Strict | Context.DisallowIn) ^
    (Context.DisallowIn | Context.InConstructor);

  if (parser.token === Token.At) report(parser, context, Errors.DecoratorESNext, /* early */ 0);

  nextToken(parser, context);

  if (((parser.token & 0x10ff) ^ 0x54) > 0x1000) {
    id = parseIdentifier(parser, context);
  }

  return parseClassDeclarationOrExpression(
    parser,
    context,
    id,
    Origin.None,
    'ClassExpression'
  ) as ESTree.ClassExpression;
}

export function parseClassBody(
  parser: ParserState,
  context: Context,
  inheritedContext: Context,
  origin: Origin
): ESTree.ClassBody {
  consume(parser, context | Context.AllowRegExp, Token.LeftBrace);
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  const body: any[] = [];

  parser.flags = (parser.flags | Flags.HasConstructor) ^ Flags.HasConstructor;

  while (parser.token !== Token.RightBrace) {
    if (consumeOpt(parser, context, Token.Semicolon)) {
      continue;
    }
    body.push(parseClassElementList(parser, context, inheritedContext, ModifierKind.None));
  }

  consume(parser, origin & Origin.Declaration ? inheritedContext | Context.AllowRegExp : context, Token.RightBrace);

  return finishNode({
    type: 'ClassBody',
    body
  });
}

export function parseClassMembers(
  parser: ParserState,
  context: Context,
  inheritedContext: Context,
  origin: Origin,
  isExpr: 0 | 1,
  isAbstract: 0 | 1,
  isDeclared: 0 | 1
): ESTree.ClassBody {
  consume(parser, context | Context.AllowRegExp, Token.LeftBrace);

  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  let decorators: ESTree.Decorator[] = [];
  parser.flags = (parser.flags | Flags.HasConstructor) ^ Flags.HasConstructor;

  const body: any[] = [];
  if (isExpr && parser.token === Token.At) report(parser, context, Errors.DisallowDecorator, /* early */ 0);
  while (parser.token !== Token.RightBrace) {
    if (consumeOpt(parser, context, Token.Semicolon)) {
      continue;
    }
    decorators = parseDecorators(parser, context);
    body.push(
      parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, ModifierKind.None)
    );
  }

  consume(parser, origin & Origin.Declaration ? inheritedContext | Context.AllowRegExp : context, Token.RightBrace);

  return finishNode({
    type: 'ClassBody',
    body
  });
}

export function parseClassElementList(
  parser: ParserState,
  context: Context,
  inheritedContext: Context,
  modifiers: ModifierKind
): any {
  let kind: PropertyKind = PropertyKind.None;
  let key: ESTree.Expression | null = null;

  const { token } = parser;

  if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
    key = parseIdentifier(parser, context);

    switch (token) {
      case Token.StaticKeyword:
        if ((modifiers & ModifierKind.Static) === 0 && parser.token !== Token.LeftParen) {
          return parseClassElementList(parser, context, inheritedContext, modifiers | ModifierKind.Static);
        }
        break;

      case Token.AsyncKeyword:
        if (parser.token !== Token.LeftParen && parser.precedingLineBreak === 0) {
          kind |= PropertyKind.Async | (optionalBit(parser, context, Token.Multiply) ? PropertyKind.Generator : 0);
        }
        break;

      case Token.GetKeyword:
        if (parser.token !== Token.LeftParen) {
          kind |= PropertyKind.Getter;
        }
        break;

      case Token.SetKeyword:
        if (parser.token !== Token.LeftParen) {
          kind |= PropertyKind.Setter;
        }
        break;

      default: // ignore
    }
  } else if (token === Token.LeftBracket) {
    kind |= PropertyKind.Computed;
    key = parseComputedPropertyName(parser, inheritedContext);
  } else if ((token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
    key = parseLiteral(parser, context);
  } else if (token === Token.Multiply) {
    kind |= PropertyKind.Generator;
    nextToken(parser, context); // skip: '*'
  } else {
    report(parser, context, Errors.UnexpectedToken, /* early */ 0, KeywordDescTable[parser.token & Token.Type]);
  }

  if (kind & (PropertyKind.Generator | PropertyKind.Async | PropertyKind.GetSet)) {
    if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
      key = parseIdentifier(parser, context);
    } else if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
      key = parseLiteral(parser, context);
    } else if (parser.token === Token.LeftBracket) {
      kind |= PropertyKind.Computed;
      key = parseComputedPropertyName(parser, context);
    } else {
      report(parser, context, Errors.Unexpected, /* early */ 0);
    }
  }

  if ((kind & PropertyKind.Computed) < 1) {
    if (parser.tokenValue === 'constructor') {
      if ((modifiers & ModifierKind.Static) < 1 && parser.token === Token.LeftParen) {
        if (kind & (PropertyKind.GetSet | PropertyKind.Async | PropertyKind.Generator)) {
          report(parser, context, Errors.InvalidConstructor, /* early */ 1, 'accessor');
        } else if ((context & Context.SuperCall) < 1) {
          if (parser.flags & Flags.HasConstructor) report(parser, context, Errors.DuplicateConstructor, /* early */ 1);
          else parser.flags |= Flags.HasConstructor;
        }
      }
      kind |= PropertyKind.Constructor;
    }
  }

  const value = parseMethodDefinition(parser, context, kind);

  return finishNode({
    type: 'MethodDefinition',
    kind:
      (modifiers & ModifierKind.Static) < 1 && kind & PropertyKind.Constructor
        ? 'constructor'
        : kind & PropertyKind.Getter
        ? 'get'
        : kind & PropertyKind.Setter
        ? 'set'
        : 'method',
    static: (modifiers & ModifierKind.Static) > 0,
    computed: (kind & PropertyKind.Computed) > 0,
    key,
    value
  } as any);
}

export function parseClassElements(
  parser: ParserState,
  context: Context,
  inheritedContext: Context,
  decorators: any,
  isAbstract: 0 | 1,
  isDeclared: 0 | 1,
  modifiers: ModifierKind
): any {
  let key: any = null;
  let kind: PropertyKind = PropertyKind.None;
  let value: any;
  let isUnambiguouslyIndexSignature: 0 | 1 = 0;

  const { token } = parser;

  const isConstructor = token === Token.ConstructorKeyword;

  if (token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) {
    key = parseOptionalIdentifier(parser, context);

    switch (token) {
      // 'static'
      case Token.StaticKeyword: {
        if (
          (ModifierKind.Static & modifiers) === 0 &&
          // The '[' check isn't necessary, but it help us throwing a good error message for index signatures
          (parser.token & (Token.FutureReserved | Token.IsIdentifier) || parser.token === Token.LeftBracket)
        ) {
          return parseClassElements(
            parser,
            context,
            inheritedContext,
            decorators,
            isAbstract,
            isDeclared,
            modifiers | ModifierKind.Static
          );
        }
        break;
      }

      // 'private'
      case Token.PrivateKeyword: {
        if (ModifierKind.Static & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'private', 'static');
        if (ModifierKind.Readonly & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'private', 'readonly');
        if (
          (ModifierKind.Private & modifiers) === 0 &&
          (parser.token & (Token.FutureReserved | Token.IsIdentifier) || parser.token === Token.LeftBracket)
        ) {
          return parseClassElements(
            parser,
            context,
            inheritedContext,
            decorators,
            isAbstract,
            isDeclared,
            modifiers | ModifierKind.Private
          );
        }
        break;
      }

      // 'protected'
      case Token.ProtectedKeyword: {
        if (ModifierKind.Abstract & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'protected', 'abstract');
        if (ModifierKind.Static & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'protected', 'static');
        if (ModifierKind.Readonly & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'protected', 'readonly');
        if (
          (ModifierKind.Protected & modifiers) === 0 &&
          (parser.token & (Token.FutureReserved | Token.IsIdentifier) || parser.token === Token.LeftBracket)
        ) {
          return parseClassElements(
            parser,
            context,
            inheritedContext,
            decorators,
            isAbstract,
            isDeclared,
            modifiers | ModifierKind.Protected
          );
        }
        break;
      }

      // 'public'
      case Token.PublicKeyword: {
        if (ModifierKind.Abstract & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'public', 'abstract');
        if (ModifierKind.Static & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'public', 'static');
        if (ModifierKind.Readonly & modifiers)
          report(parser, context, Errors.ModifierMustPrecede, /* early */ 0, 'public', 'readonly');
        if (ModifierKind.Accessibility & modifiers)
          report(parser, context, Errors.AlreadySeenModifier, /* early */ 0, 'Accessibility');
        if (
          (ModifierKind.Public & modifiers) === 0 &&
          (parser.token & (Token.FutureReserved | Token.IsIdentifier) || parser.token === Token.LeftBracket)
        ) {
          return parseClassElements(
            parser,
            context,
            inheritedContext,
            decorators,
            isAbstract,
            isDeclared,
            modifiers | ModifierKind.Public
          );
        }
        break;
      }

      // 'readonly'
      case Token.ReadOnlyKeyword: {
        if (
          (ModifierKind.Readonly & modifiers) === 0 &&
          parser.token !== Token.Semicolon &&
          parser.token !== Token.Assign &&
          parser.token !== Token.RightBrace &&
          parser.token !== Token.LeftParen
        ) {
          return parseClassElements(
            parser,
            context,
            inheritedContext,
            decorators,
            isAbstract,
            isDeclared,
            modifiers | ModifierKind.Readonly
          );
        }
        break;
      }

      // 'abstract'
      case Token.AbstractKeyword: {
        if (!isAbstract && parser.token & Token.IsIdentifier)
          report(parser, context, Errors.AbstractMethodNoAbstractClass, /* early */ 0);
        if (
          (ModifierKind.Abstract & modifiers) === 0 &&
          (parser.token & (Token.FutureReserved | Token.IsIdentifier) || parser.token === Token.LeftBracket)
        ) {
          return parseClassElements(
            parser,
            context,
            inheritedContext,
            decorators,
            isAbstract,
            isDeclared,
            modifiers | ModifierKind.Abstract
          );
        }
        break;
      }

      case Token.AsyncKeyword:
        if (
          parser.token !== Token.LeftParen && // TODO! Bitmasks!
          parser.token !== Token.LessThan &&
          parser.token !== Token.Colon &&
          parser.token !== Token.Comma &&
          parser.token !== Token.Assign &&
          parser.token !== Token.RightBrace &&
          parser.token !== Token.Semicolon &&
          !parser.precedingLineBreak
        ) {
          kind |= PropertyKind.Async | (optionalBit(parser, context, Token.Multiply) ? PropertyKind.Generator : 0);
        }
        break;

      case Token.GetKeyword:
        if (
          parser.token !== Token.LeftParen && // TODO! Bitmasks!
          parser.token !== Token.LessThan &&
          parser.token !== Token.Colon &&
          parser.token !== Token.Assign &&
          parser.token !== Token.RightBrace &&
          parser.token !== Token.Semicolon
        ) {
          kind |= PropertyKind.Getter;
        }
        break;

      case Token.SetKeyword:
        if (
          parser.token !== Token.LeftParen &&
          parser.token !== Token.LessThan &&
          parser.token !== Token.Colon &&
          parser.token !== Token.Assign &&
          parser.token !== Token.RightBrace &&
          parser.token !== Token.Semicolon
        ) {
          kind |= PropertyKind.Setter;
        }
        break;

      default: // ignore
    }
  } else if (token === Token.LeftBracket) {
    let hasTypeAnnotation: 0 | 1 = 0;
    nextToken(parser, context); // skips: '['
    if ((parser.token & Token.IsModifier) === Token.IsModifier) {
      report(parser, context, Errors.InvalidIndexSignatureModifier, /* early */ 0, 'Accessibility');
    }

    kind |= PropertyKind.Computed;

    if ((parser.token & Token.IsIdentifier) === Token.IsIdentifier) {
      const { tokenValue } = parser;

      nextToken(parser, context);

      if (parser.token === Token.QuestionMark) {
        report(parser, context, Errors.InvalidIndexSignatureOptional, /* early */ 0);
      }

      // The only allowed sequence in a 'IndexSignature' is:
      //
      //   [id:
      //
      if (parser.token === Token.Colon) {
        isUnambiguouslyIndexSignature = 1;
        hasTypeAnnotation = 1;
        let typeAnnotation: any = [];

        if (consumeOpt(parser, context, Token.Colon)) {
          if (parser.token & Token.IsPatternStart || parser.token === Token.LeftParen) {
            report(parser, context, Errors.InvalidIndexSignatureParam, /* early */ 0);
          }
          typeAnnotation = parseTypeAnnotationNoConsume(parser, context, /* restrictedTypes */ 1);
        }

        if (parser.token === Token.Comma) {
          report(parser, context, Errors.IndexSignatureOneParam, /* early */ 0);
        }

        if (parser.token === Token.InKeyword) report(parser, context, Errors.InvalidComputedInterface, /* early */ 0);

        key = {
          type: 'Identifier',
          name: tokenValue,
          optional: false,
          typeAnnotation
        };
      }
      // This is a computed property name
      else {
        if (parser.token === Token.Comma) {
          report(parser, context, Errors.IndexSignatureOneParam, /* early */ 0);
        }

        kind |= PropertyKind.Computed;

        key = parseIdentifierFromValue(parser, context, tokenValue, /*allowAnnotations */ 0) as ESTree.Identifier;
      }

      if (parser.token !== Token.RightBracket) {
        key = parseMemberOrUpdateExpression(parser, context, key);

        key = parseAssignmentExpression(parser, context, key);
      }
    } else {
      if (parser.token === Token.Ellipsis) {
        report(parser, context, Errors.IndexSignatureNoRest, /* early */ 0);
      }
      key = parseExpression(parser, context);
    }

    consume(parser, context, Token.RightBracket);
    if (hasTypeAnnotation && parser.token !== Token.Colon)
      report(parser, context, Errors.InvalidIndexSignatureAnnotation, /* early */ 0);
    consumeOpt(parser, context, Token.QuestionMark);
  } else if ((token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
    key = parseLiteral(parser, context);
  } else if (token === Token.Multiply) {
    if (isDeclared) report(parser, context, Errors.InvalidGeneratorAmbientContext, /* early */ 0);
    kind |= PropertyKind.Generator;
    nextToken(parser, context); // skip: '*'
  } else {
    report(parser, context, Errors.Unexpected, /* early*/ 0); //throw 'Unexpected class elem';
  }

  if (kind & (PropertyKind.Generator | PropertyKind.Async | PropertyKind.GetSet) && parser.token !== Token.LessThan) {
    if (parser.token & (Token.IsIdentifier | Token.FutureReserved)) {
      key = parseIdentifier(parser, context);
    } else if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
      key = parseLiteral(parser, context);
    } else if (parser.token === Token.LeftBracket) {
      kind |= PropertyKind.Computed;
      key = parseComputedPropertyName(parser, context);
    } else {
      report(parser, context, Errors.Unexpected, /* early*/ 0); //throw 'InvalidKeyToken';
    }
  }

  if (isUnambiguouslyIndexSignature) {
    if (modifiers & ModifierKind.Static) {
      report(parser, context, Errors.InvalidIndexSignatureModifier, /* early */ 0, 'static');
    }
    if (modifiers & (ModifierKind.Accessibility | ModifierKind.Abstract)) {
      report(parser, context, Errors.InvalidIndexSignatureModifier, /* early */ 0, 'Accessibility and abstract');
    }
    consume(parser, context, Token.Colon);

    const typeAnnotation = parseType(
      parser,
      context,
      /* restrictedTypes */ 0,
      /* isMappedType */ 0,
      TypeAliasState.None
    );

    return finishNode({
      type: 'IndexSignature',
      parameters: [key],
      typeAnnotation,
      readonly: (kind & PropertyKind.Readonly) < 1,
      accessibility: null,
      export: false,
      static: false
    });
  }

  if ((kind & PropertyKind.Computed) < 1) {
    if (parser.tokenValue === 'constructor') {
      if ((modifiers & ModifierKind.Static) < 1 && parser.token === Token.LeftParen) {
        if (kind & (PropertyKind.GetSet | PropertyKind.Async | PropertyKind.ClassField | PropertyKind.Generator)) {
          // report(parser, context, Errors.InvalidConstructor, /* early */ 1, 'accessor');
        } else if ((context & Context.SuperCall) < 1) {
          parser.flags |= Flags.HasConstructor;
        }
      }
      kind |= PropertyKind.Constructor;
    }
  }
  if (parser.token === Token.LessThan || parser.token === Token.LeftParen) {
    if (ModifierKind.Readonly & modifiers) report(parser, context, Errors.ReadOnlyModifierNoMethod, /* early*/ 0);
    value = parseTypeScriptMethodDefinition(parser, context, isConstructor, kind, modifiers, isDeclared);

    return finishNode({
      type: ModifierKind.Abstract & modifiers ? 'AbstractMethodDefinition' : 'MethodDefinition',
      kind:
        (modifiers & ModifierKind.Static) < 1 && kind & PropertyKind.Constructor
          ? 'constructor'
          : kind & PropertyKind.Getter
          ? 'get'
          : kind & PropertyKind.Setter
          ? 'set'
          : 'method',
      static: (modifiers & ModifierKind.Static) > 0,
      computed: (kind & PropertyKind.Computed) > 0,
      key,
      decorators,
      value,
      accessibility:
        modifiers & ModifierKind.Public
          ? 'public'
          : modifiers & ModifierKind.Private
          ? 'private'
          : modifiers & ModifierKind.Protected
          ? 'protected'
          : null,
      typeParameters: null
    } as any);
  }

  return parseClassProperty(parser, context, key, kind, modifiers, decorators);
}

export function parseClassProperty(
  parser: ParserState,
  context: Context,
  key: ESTree.Identifier | ESTree.Literal,
  kind: PropertyKind,
  modifiers: ModifierKind,
  decorators: ESTree.Decorator[]
): ESTree.ClassProperty {
  if (kind & (PropertyKind.Generator | PropertyKind.Async)) {
    report(
      parser,
      context,
      kind & PropertyKind.Generator ? Errors.MissingFuncDecl : Errors.InvalidAsyncModifier,
      /* early */ 1
    );
  }

  if ((modifiers & ModifierKind.Static) === 0 && kind & PropertyKind.Constructor) {
    report(parser, context, Errors.NonStaticConstructorField, /* early */ 1);
  }

  const optional = consumeOpt(parser, context, Token.QuestionMark);
  const definite = consumeOpt(parser, context, Token.Negate);

  if (!optional && definite && parser.token !== Token.Colon)
    report(parser, context, Errors.UnexpectedDefiniteInCtx, /* early */ 0);

  const typeAnnotation =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];

  let value: ESTree.Expression | null = null;

  if (parser.token === Token.Assign) {
    nextToken(parser, context);
    if (modifiers & ModifierKind.Static && parser.token === Token.ThisKeyword)
      report(parser, context, Errors.InvalidThisRefStaticProp, /* early */ 1);
    value = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);
    value = parseAssignmentExpression(parser, context, value);
  }
  return finishNode({
    type: modifiers & ModifierKind.Abstract ? 'AbstractClassProperty' : ('ClassProperty' as any),
    key,
    value: value as ESTree.Expression,
    computed: (kind & PropertyKind.Computed) > 0,
    static: (modifiers & ModifierKind.Static) > 0,
    readonly: (kind & PropertyKind.Readonly) > 0,
    decorators,
    accessibility:
      modifiers & ModifierKind.Public
        ? 'public'
        : modifiers & ModifierKind.Private
        ? 'private'
        : modifiers & ModifierKind.Protected
        ? 'protected'
        : null,
    optional,
    definite,
    typeAnnotation
  });
}

export function parseConstructorFormals(parser: ParserState, context: Context, declare: 0 | 1): ESTree.Parameter[] {
  consume(parser, context, Token.LeftParen); // skip: '('
  const params: ESTree.Parameter[] = [];
  let left: any;
  let hasInitializer: 0 | 1 = 0;

  while (parser.token !== Token.RightParen) {
    if (parser.token & (Token.IsIdentifier | Token.FutureReserved)) {
      const { token } = parser;

      left = parseBindingIdentifier(parser, context, 0, 1);

      if (
        (token & Token.IsModifier) === Token.IsModifier &&
        (parser.token & (Token.FutureReserved | Token.IsIdentifier)) > 0
      ) {
        left = parseParameterProperty(parser, context, token, []);
      }
    } else {
      const decorators = parser.token === Token.At ? parseDecorators(parser, context | Context.InDecoratorContext) : [];
      const { token } = parser;
      if (parser.token === Token.LeftBrace) {
        left = parseObjectLiteralOrPattern(parser, context, 1, /* isPattern */ 1, decorators);
      } else if (parser.token === Token.LeftBracket) {
        left = parseArrayExpressionOrPattern(parser, context, 1, /* isPattern */ 1, decorators);
      } else if (parser.token === Token.Ellipsis) {
        left = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, decorators);
      } else if ((parser.token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) > 0) {
        left = parseBindingIdentifier(parser, context, /* requireTypeAnnotation */ 0, /* canBeOptionalParam */ 1);
        left.decorators = decorators;
      } else {
        report(parser, context, Errors.Unexpected, 0);
      }

      if (
        (token & Token.IsModifier) === Token.IsModifier &&
        (parser.token & (Token.FutureReserved | Token.IsIdentifier)) > 0
      ) {
        left = parseParameterProperty(parser, context, token, decorators);
      }
    }

    if (parser.token === Token.Assign) {
      nextToken(parser, context | Context.AllowRegExp);
      hasInitializer = 1;

      left = finishNode({
        type: 'AssignmentPattern',
        left,
        right: parseExpression(parser, context)
      });
    }

    params.push(left);

    if (parser.token !== Token.RightParen) consume(parser, context, Token.Comma);
  }

  consume(parser, context, Token.RightParen);
  if (parser.token !== Token.LeftBrace) {
    if (hasInitializer && parser.token !== Token.LeftBrace)
      report(parser, context, Errors.MissingInitInConstructor, /* early */ 0);
    if (declare) report(parser, context, Errors.InvalidImplmentAmbientContext, /* early */ 0);
  }

  return params;
}

export function parseParameterProperty(
  parser: ParserState,
  context: Context,
  token: Token,
  decorators: any
): ESTree.ParameterProperty {
  if (parser.token === Token.StaticKeyword) report(parser, context, Errors.InvalidStaticOnParam, /* early */ 0);

  let parameter: any = null;

  const { tokenValue } = parser;

  const modifiers =
    (token === Token.PrivateKeyword ? ModifierKind.Private : 0) |
    (token === Token.PublicKeyword ? ModifierKind.Public : 0) |
    (token === Token.ProtectedKeyword ? ModifierKind.Protected : 0) |
    (consumeOpt(parser, context, Token.ReadOnlyKeyword) ? ModifierKind.Readonly : 0);

  if (parser.token === Token.RightParen) {
    parameter = parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 1) as ESTree.Identifier;
  } else {
    const { token } = parser;

    parameter = parseBindingIdentifier(parser, context, 0, 1);

    if ((parser.token & (Token.Contextual | Token.Keywords | Token.FutureReserved | Token.IsIdentifier)) > 0) {
      parameter = parseBindingIdentifier(parser, context, 0, 1);
    } else if ((token & Token.IsModifier) === Token.IsModifier) {
      report(parser, context, Errors.StrictReservedInClass, /* early */ 0, KeywordDescTable[token & Token.Type]);
    }
  }

  if (parser.token === Token.Assign) {
    nextToken(parser, context | Context.AllowRegExp);

    parameter = finishNode({
      type: 'AssignmentPattern',
      left: parameter,
      right: parseExpression(parser, context)
    });
  }

  return finishNode({
    type: 'ParameterProperty',
    accessibility:
      modifiers & ModifierKind.Public
        ? 'public'
        : modifiers & ModifierKind.Private
        ? 'private'
        : modifiers & ModifierKind.Protected
        ? 'protected'
        : null,
    readonly: (modifiers & ModifierKind.Readonly) > 0,
    static: false,
    export: false,
    parameter,
    decorators
  } as any);
}

export function parseTypeScriptFormalParametersOrFormalList(parser: ParserState, context: Context): ESTree.Parameter[] {
  const params: ESTree.Parameter[] = [];
  let left: any;

  context = (context | Context.DisallowIn) ^ Context.DisallowIn;

  nextToken(parser, context);
  while (parser.token !== Token.RightParen) {
    const { tokenValue, token } = parser;

    if ((token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) > 0) {
      if ((token & Token.IsModifier) === Token.IsModifier) {
        nextToken(parser, context);
        if ((parser.token & (Token.IsIdentifier | Token.FutureReserved)) > 0) {
          report(parser, context, Errors.ParamPropertyNoConstructor, /* early */ 0);
        }
        left = parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 1) as any;
      } else {
        left = parseBindingIdentifier(parser, context, /* requireTypeAnnotation */ 0, /* canBeOptionalParam */ 1);
      }
    } else {
      const decorators = token === Token.At ? parseDecorators(parser, context | Context.InDecoratorContext) : [];
      if (parser.token === Token.LeftBrace) {
        left = parseObjectLiteralOrPattern(parser, context, 1, /* isPattern */ 1, decorators);
      } else if (parser.token === Token.LeftBracket) {
        left = parseArrayExpressionOrPattern(parser, context, 1, /* isPattern */ 1, decorators);
      } else if (parser.token === Token.Ellipsis) {
        left = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, decorators);
      } else if ((parser.token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) > 0) {
        left = parseBindingIdentifier(parser, context, /* requireTypeAnnotation */ 0, /* canBeOptionalParam */ 1);
        left.decorators = decorators;
      } else {
        report(parser, context, Errors.Unexpected, 0);
      }

      reinterpretToPattern(parser, left);
    }

    if (parser.token === Token.Assign) {
      nextToken(parser, context | Context.AllowRegExp);

      const right = parseExpression(parser, context);

      left = finishNode({
        type: 'AssignmentPattern',
        left,
        right
      });
    }

    params.push(left);

    if (parser.token !== Token.RightParen) consume(parser, context, Token.Comma);
  }
  consume(parser, context, Token.RightParen);
  return params;
}

export function parseFormalParametersOrFormalList(parser: ParserState, context: Context): ESTree.Parameter[] {
  const params: ESTree.Parameter[] = [];
  let left: any;

  context = (context | Context.DisallowIn) ^ Context.DisallowIn;

  nextToken(parser, context);
  while (parser.token !== Token.RightParen) {
    const { token } = parser;

    if ((token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) > 0) {
      left = parseIdentifier(parser, context);
    } else {
      if (token === Token.LeftBrace) {
        left = parseObjectLiteralOrPattern(parser, context, 1, /* isPattern */ 1, []);
      } else if (token === Token.LeftBracket) {
        left = parseArrayExpressionOrPattern(parser, context, 1, /* isPattern */ 1, []);
      } else if (token === Token.Ellipsis) {
        left = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, []);
      } else {
        report(parser, context, Errors.Unexpected, 0);
      }

      reinterpretToPattern(parser, left);
    }
    if (parser.token === Token.Assign) {
      nextToken(parser, context | Context.AllowRegExp);

      const right = parseExpression(parser, context);

      left = finishNode({
        type: 'AssignmentPattern',
        left,
        right
      });
    }

    params.push(left);

    if (parser.token !== Token.RightParen) consume(parser, context, Token.Comma);
  }
  consume(parser, context, Token.RightParen);
  return params;
}

export function parseFunctionBody(parser: ParserState, context: Context, origin: Origin): ESTree.BlockStatement | null {
  if (context & Context.OptionsTS && parser.token !== Token.LeftBrace) {
    if (canParseSemicolon(parser)) {
      consumeSemicolon(parser, context);
      return null;
    }
    report(parser, context, Errors.UnexpectedToken, /* early */ 0, ';'); // block or ';' expected
  }

  consume(parser, context | Context.AllowRegExp, Token.LeftBrace);

  const body: ESTree.Statement[] = [];

  if (parser.token !== Token.RightBrace) {
    while (parser.token === Token.StringLiteral) {
      // "use strict" must be the exact literal without escape sequences or line continuation.
      if (parser.index - parser.tokenPos < 13 && parser.tokenValue === 'use strict') {
        if ((parser.token & Token.IsAutoSemicolon) === Token.IsAutoSemicolon || parser.precedingLineBreak === 0) {
          context |= Context.Strict;
        }
      }
      body.push(parseStatementListItem(parser, context, parser.tokenPos));
    }

    while (parser.token !== Token.RightBrace) {
      body.push(parseStatementListItem(parser, context, 1) as ESTree.Statement);
    }
  }
  consume(
    parser,
    origin & (Origin.Arrow | Origin.Declaration) ? context | Context.AllowRegExp : context,
    Token.RightBrace
  );

  return finishNode({
    type: 'BlockStatement',
    body
  });
}

export function parseBlock(parser: ParserState, context: Context): ESTree.BlockStatement {
  const body: ESTree.Statement[] = [];

  consume(parser, context | Context.AllowRegExp, Token.LeftBrace);

  while (parser.token !== Token.RightBrace) {
    body.push(parseStatementListItem(parser, context, parser.startPos));
  }

  consume(parser, context | Context.AllowRegExp, Token.RightBrace);

  return finishNode({
    type: 'BlockStatement',
    body
  });
}

export function parsePrimaryExpression(parser: ParserState, context: Context, isLHS: 0 | 1, inParens: 0 | 1): any {
  if (parser.token === Token.AsyncKeyword) {
    return parseAsyncExpression(parser, context, isLHS, 0);
  }

  if (parser.token === Token.YieldKeyword) return parseYieldExpression(parser, context);
  if ((parser.token & Token.IsIdentifier) > 0) {
    if (parser.token === Token.AwaitKeyword) return parseAwaitExpression(parser, context);

    const expr =
      inParens && context & Context.OptionsTS
        ? parseBindingIdentifier(parser, context, 0, 0)
        : parseIdentifier(parser, context);
    if (parser.token === Token.Arrow) {
      return parseArrowFunctionExpression(parser, context, [expr], null, null, isLHS, /* isAsync */ 0);
    }
    return expr;
  }

  if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
    return parseLiteral(parser, context);
  }

  if ((parser.token & Token.IsUpdateOp) === Token.IsUpdateOp) {
    if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseUpdateExpressionPrefixed(parser, context, 0);
  }

  if ((parser.token & Token.IsUnaryOp) === Token.IsUnaryOp) {
    if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseUnaryExpression(parser, context);
  }

  switch (parser.token) {
    case Token.FalseKeyword:
    case Token.TrueKeyword:
    case Token.NullKeyword:
      return parseNullOrTrueOrFalseLiteral(parser, context);
    case Token.ThisKeyword:
      return parseThisExpression(parser, context);
    case Token.RegularExpression:
      return parseRegExpLiteral(parser, context);
    case Token.FunctionKeyword:
      return parseFunctionExpression(parser, context, /* isAsync */ 0);
    case Token.LeftBrace:
      return parseObjectLiteral(parser, context, 0);
    case Token.LeftBracket:
      return parseArrayLiteral(parser, context, 0);
    case Token.LeftParen:
      return context & Context.OptionsTS
        ? parseTypescriptParenthesizedExpression(parser, context, isLHS, [], 0)
        : parseParenthesizedExpression(parser, context, isLHS);
    case Token.At:
    case Token.ClassKeyword:
      return context & Context.OptionsTS
        ? parseTypescriptClassExpression(parser, context)
        : parseClassExpression(parser, context);
    case Token.SuperKeyword:
      return parseSuperExpression(parser, context);
    case Token.TemplateTail:
      return parseNoSubstitutionTemplate(parser, context);
    case Token.TemplateCont:
      return parseTemplateLiteral(parser, context);
    case Token.NewKeyword:
      return parseNewExpression(parser, context);
    case Token.BigIntLiteral:
      return parseBigIntLiteral(parser, context);
    case Token.ImportKeyword:
      return parseImportCallOrMetaExpression(parser, context);
    case Token.LessThan:
      return parseJSXOrTypeAssertion(parser, context);
    default:
      if (isValidIdentifier(context, parser.token)) return parseIdentifierOrArrow(parser, context);
      report(parser, context, Errors.UnexpectedToken, /* early */ 0, KeywordDescTable[parser.token & Token.Type]);
      nextToken(parser, context);
  }
}

export function parseImportCallOrMetaExpression(parser: ParserState, context: Context): ESTree.ImportExpression {
  // ImportCall[Yield, Await]:
  //  import(AssignmentExpression[+In, ?Yield, ?Await])

  let expr: any = parseIdentifier(parser, context);

  expr = parseImportExpression(parser, context);

  return parseMemberOrUpdateExpression(parser, context, expr);
}

export function parseImportExpression(parser: ParserState, context: Context): ESTree.ImportExpression {
  consume(parser, context | Context.AllowRegExp, Token.LeftParen);

  if (parser.token === Token.Ellipsis) report(parser, context, Errors.Unexpected, /* early */ 1);

  const source = parseExpression(parser, context);

  consume(parser, context, Token.RightParen);

  return finishNode({
    type: 'ImportExpression',
    source
  });
}

export function parseTypeParameterFromValue(
  parser: ParserState,
  context: Context,
  value: string
): ESTree.TypeParameter {
  return finishNode({
    type: 'TypeParameter',
    name: parseIdentifierFromValue(parser, context, value, /* allowAnnotations */ 1) as ESTree.Identifier,
    constraint: consumeOpt(parser, context, Token.ExtendsKeyword)
      ? parseType(parser, context, 0, 0, TypeAliasState.None)
      : null,
    default: consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)
      ? parseType(parser, context, 0, 0, TypeAliasState.None)
      : null
  });
}

export function parseJSXOrTypeAssertion(
  parser: ParserState,
  context: Context
): ESTree.TypeParameterDeclaration | ESTree.TypeAssertion | ESTree.JSXElement | ESTree.JSXFragment {
  if (context & Context.OptionsJSX && ((parser.token & Token.IsIdentifier) | Token.IsKeyword) !== 0) {
    return parseJSXRootElementOrFragment(parser, context, /*inJSXChild*/ 1);
  }
  if ((context & Context.OptionsTS) < 1) report(parser, context, Errors.UnexpectedToken, /* early */ 0, '<');
  nextToken(parser, context | Context.AllowRegExp); // skip: '<'

  const params: ESTree.TypeParameter[] = [];
  let isTypeParameter: 0 | 1 = 0;
  while (parser.token !== Token.GreaterThan) {
    const { token, tokenValue } = parser;

    context = context | Context.InTSTypes;

    if ((token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) !== 0) {
      nextToken(parser, context | Context.AllowRegExp);

      if (parser.token === Token.Comma || parser.token === Token.ExtendsKeyword || parser.token === Token.Assign) {
        isTypeParameter = 1;
        params.push(parseTypeParameterFromValue(parser, context, tokenValue));
        if (parser.token !== Token.GreaterThan) consume(parser, context | Context.AllowRegExp, Token.Comma);
      } else if (isTypeParameter) {
        params.push(parseTypeParameterFromValue(parser, context, tokenValue));
      } else {
        if (consumeOpt(parser, context | Context.AllowRegExp, Token.GreaterThan)) {
          if (parser.token === Token.LeftParen) {
            return parseTypescriptParenthesizedExpression(parser, context, 1, tokenValue, TypeAssertionState.UnKnown);
          } else {
            return parseTypeAssertion(parser, context, parseTypeFromValue(parser, context, tokenValue));
          }
        } else {
          let type = parseTypeFromValue(parser, context, parser.tokenValue);
          type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
          consume(parser, context | Context.AllowRegExp, Token.GreaterThan);
          return parser.token === Token.LeftParen
            ? parseTypescriptParenthesizedExpression(parser, context, 1, type as any, TypeAssertionState.Unfinished)
            : parseTypeAssertion(parser, context, type);
        }
      }
    } else {
      const type = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
      consume(parser, context | Context.AllowRegExp, Token.GreaterThan);
      if (parser.token === Token.LeftParen) {
        return parseTypescriptParenthesizedExpression(parser, context, 1, type as any, TypeAssertionState.Unfinished);
      }
      return finishNode({
        type: 'TypeAssertion',
        typeAnnotation: type,
        expression: parsePrimaryExpression(parser, context, 1, 0)
      });
    }
  }

  consume(parser, context | Context.AllowRegExp, Token.GreaterThan);

  if (parser.token !== Token.LeftParen) report(parser, context, Errors.Unexpected, /* early */ 0);

  return parseTypescriptParenthesizedExpression(
    parser,
    context,
    1,
    finishNode({
      type: 'TypeParameterDeclaration',
      params
    } as any),
    TypeAssertionState.TypeParameter
  );
}

export function parseTypeAssertion(parser: ParserState, context: Context, typeAnnotation: any): ESTree.TypeAssertion {
  return finishNode({
    type: 'TypeAssertion',
    typeAnnotation,
    expression: parsePrimaryExpression(parser, context, 1, 0)
  });
}

export function parseAsyncExpression(
  parser: ParserState,
  context: Context,
  isLHS: 0 | 1,
  inNew: 0 | 1
): ESTree.FunctionExpression | ESTree.ArrowFunctionExpression | ESTree.CallExpression | ESTree.Identifier {
  let expr: any = parseIdentifier(parser, context);

  if (parser.precedingLineBreak === 0) {
    // async function ...
    if (parser.token === Token.FunctionKeyword) {
      return parseFunctionExpression(parser, context, /* isAsync */ 1);
    }

    // async Identifier => ...
    if ((parser.token & Token.IsIdentifier) === Token.IsIdentifier) {
      if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 0);
      expr = parseArrowFunctionExpression(
        parser,
        context,
        [parseIdentifier(parser, context)],
        null,
        null,
        /* isLHS */ 1,
        /* isAsync */ 1
      );
    }
  }

  // async (...) => ...

  let typeParameters: any = null;

  if (context & Context.OptionsTS && parser.token === Token.LessThan) {
    typeParameters = parseAsyncIdentifierOrParameterInstantiation(parser, context);
    if (typeParameters !== undefined && parser.token !== Token.LeftParen)
      report(parser, context, Errors.Unexpected, /* early */ 0);
  }

  if (!inNew && parser.token === Token.LeftParen) {
    expr = parseAsyncArrowOrCallExpression(parser, context, isLHS, typeParameters, expr);
  }

  if (parser.token === Token.Arrow) {
    return parseArrowFunctionExpression(parser, context, [expr], null, [], /* isLHS */ 1, /* isAsync */ 0);
  }

  return expr;
}

export function parseAwaitExpression(
  parser: ParserState,
  context: Context
): ESTree.AwaitExpression | ESTree.Identifier | ESTree.ArrowFunctionExpression {
  if (context & Context.InAwaitContext) {
    nextToken(parser, context | Context.AllowRegExp);

    const argument = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

    return finishNode({
      type: 'AwaitExpression',
      argument
    });
  }

  return parseIdentifierOrArrow(parser, context);
}

export function parseYieldExpression(
  parser: ParserState,
  context: Context
): ESTree.YieldExpression | ESTree.Identifier | ESTree.ArrowFunctionExpression {
  if (context & Context.InYieldContext) {
    nextToken(parser, context | Context.AllowRegExp);

    let argument = null;
    let delegate = false; // yield*

    if (parser.precedingLineBreak === 0) {
      delegate = consumeOpt(parser, context | Context.AllowRegExp, Token.Multiply);
      if (parser.token & Token.IsExpressionStart || delegate) {
        argument = parseExpression(parser, context);
      }
    }

    return finishNode({
      type: 'YieldExpression',
      argument,
      delegate
    });
  }

  return parseIdentifierOrArrow(parser, context);
}

export function parseIdentifierOrArrow(
  parser: ParserState,
  context: Context
): ESTree.Identifier | ESTree.ArrowFunctionExpression {
  const expr = parseIdentifier(parser, context);

  if (parser.token === Token.Arrow) {
    return parseArrowFunctionExpression(parser, context, [expr], null, null, /* isLHS */ 1, /* isAsync */ 0);
  }
  return expr;
}

export function parseObjectLiteral(parser: ParserState, context: Context, skipInitializer: 0 | 1): any {
  return parseObjectLiteralOrPattern(parser, context, skipInitializer, /* isPattern */ 0, /* decorators */ []);
}

export function parseObjectLiteralOrPattern(
  parser: ParserState,
  context: Context,
  skipInitializer: 0 | 1,
  isPattern: 0 | 1,
  decorators: ESTree.Decorator[]
): any {
  nextToken(parser, context); // skips: '{'
  const properties: any[] = [];
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  while (parser.token !== Token.RightBrace) {
    const { token } = parser;

    if (token === Token.Ellipsis) {
      properties.push(parseSpreadOrRestElement(parser, context, Token.RightBrace, /* allowTypeAnnotation */ 0, []));
    } else {
      let state = PropertyKind.None;
      let key: any = null;
      let value;

      if (token & (Token.Keywords | Token.Contextual | Token.IsIdentifier | Token.FutureReserved)) {
        key = parseIdentifier(parser, context);

        if (parser.token === Token.Comma || parser.token === Token.RightBrace || parser.token === Token.Assign) {
          state |= PropertyKind.Shorthand;

          if (consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)) {
            const right = parseExpression(parser, context);

            value = finishNode({
              type: 'AssignmentPattern',
              left: key,
              right
            });
          } else {
            value = key;
          }
        } else if (consumeOpt(parser, context | Context.AllowRegExp, Token.Colon)) {
          if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
            value = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);

            const { token } = parser;

            value = parseMemberOrUpdateExpression(parser, context, value);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              if (token === Token.Assign || token === Token.RightBrace || token === Token.Comma) {
                // TODO
              } else {
                // TODO
              }
            } else if (parser.token === Token.Assign) {
              value = parseAssignmentExpression(parser, context, value);
            } else {
              value = parseAssignmentExpression(parser, context, value);
            }
          } else if ((parser.token & Token.IsPatternStart) === Token.IsPatternStart) {
            value =
              parser.token === Token.LeftBrace
                ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, isPattern, decorators)
                : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, isPattern, []);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              const { token } = parser;

              if (token !== Token.Comma && token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              } else if (token !== Token.Assign) {
                // TODO
              }
            }
          } else {
            value = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              const { token } = parser;

              if (token !== Token.Comma && token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              }
            }
          }
        } else if (parser.token === Token.LeftBracket) {
          if (token === Token.AsyncKeyword) state |= PropertyKind.Async;
          state |=
            (token === Token.GetKeyword
              ? PropertyKind.Getter
              : token === Token.SetKeyword
              ? PropertyKind.Setter
              : PropertyKind.Method) | PropertyKind.Computed;

          key = parseComputedPropertyName(parser, context);

          value = parseMethodDefinition(parser, context, state);
        } else if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
          key = parseIdentifier(parser, context);

          if (token === Token.AsyncKeyword) state |= PropertyKind.Async;

          state |=
            token === Token.GetKeyword
              ? PropertyKind.Getter
              : token === Token.SetKeyword
              ? PropertyKind.Setter
              : PropertyKind.Method;

          value = parseMethodDefinition(parser, context, state);
        } else if (parser.token === Token.LeftParen) {
          state |= PropertyKind.Method;
          value = parseMethodDefinition(parser, context, state);
        } else if (parser.token === Token.Multiply) {
          nextToken(parser, context);

          state |=
            PropertyKind.Generator | PropertyKind.Method | (token === Token.AsyncKeyword ? PropertyKind.Async : 0);

          if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
            key = parseIdentifier(parser, context);
          } else if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
            key = parseLiteral(parser, context);
          } else if (parser.token === Token.LeftBracket) {
            state |= PropertyKind.Computed;
            key = parseComputedPropertyName(parser, context);
          } else {
            report(parser, context, Errors.Unexpected, /* early */ 0);
          }
          value = parseMethodDefinition(parser, context, state);
        } else if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
          if (token === Token.AsyncKeyword) state |= PropertyKind.Async;

          state |=
            token === Token.GetKeyword
              ? PropertyKind.Getter
              : token === Token.SetKeyword
              ? PropertyKind.Setter
              : PropertyKind.Method;

          key = parseLiteral(parser, context);

          value = parseMethodDefinition(parser, context, state);
        } else if (context & Context.OptionsTS && parser.token === Token.LessThan) {
          value = parseMethodDefinition(parser, context, state);
        } else {
          report(parser, context, Errors.Unexpected, /* early */ 0);
        }
      } else if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
        key = parseLiteral(parser, context);

        if (parser.token === Token.Colon) {
          consume(parser, context | Context.AllowRegExp, Token.Colon);

          if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
            value = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);

            value = parseMemberOrUpdateExpression(parser, context, value);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else if (parser.token === Token.Assign) {
              value = parseAssignmentExpression(parser, context, value);
            } else {
              value = parseAssignmentExpression(parser, context, value);
            }
          } else if ((parser.token & Token.IsPatternStart) === Token.IsPatternStart) {
            value =
              parser.token === Token.LeftBrace
                ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, isPattern, decorators)
                : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, isPattern, []);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              if (parser.token !== Token.Comma && parser.token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              } else if (parser.token !== Token.Assign) {
                // TODO
              }
            }
          } else {
            value = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              if (parser.token !== Token.Comma && parser.token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              }
            }
          }
        } else if (parser.token === Token.LeftParen) {
          state |= PropertyKind.Method;
          value = parseMethodDefinition(parser, context, state);
        } else if (context & Context.OptionsTS && parser.token === Token.LessThan) {
          value = parseMethodDefinition(parser, context, state);
        } else {
          report(parser, context, Errors.Unexpected, /* early */ 0);
        }
      } else if (parser.token === Token.LeftBracket) {
        key = parseComputedPropertyName(parser, context);
        state |= PropertyKind.Computed;

        if (parser.token === Token.Colon) {
          nextToken(parser, context | Context.AllowRegExp); // skip ':'

          if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
            value = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);

            const { token } = parser;

            value = parseMemberOrUpdateExpression(parser, context, value);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              if (token === Token.Assign || token === Token.RightBrace || token === Token.Comma) {
                // TODO
              } else {
                // TODO
              }
            } else if (parser.token === Token.Assign) {
              value = parseAssignmentExpression(parser, context, value);
            } else {
              value = parseAssignmentExpression(parser, context, value);
            }
          } else if ((parser.token & Token.IsPatternStart) === Token.IsPatternStart) {
            value =
              parser.token === Token.LeftBrace
                ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, isPattern, decorators)
                : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, isPattern, []);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              const { token } = parser;

              if (parser.token !== Token.Comma && parser.token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              } else if (token !== Token.Assign) {
                // TODO
              }
            }
          } else {
            value = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              if (parser.token !== Token.Comma && parser.token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              }
            }
          }
        } else if (parser.token === Token.LeftParen) {
          state |= PropertyKind.Method;
          value = parseMethodDefinition(parser, context, state);
        } else {
          report(parser, context, Errors.Unexpected, /* early */ 0);
        }
      } else if (token === Token.Multiply) {
        consume(parser, context, Token.Multiply);

        state |= PropertyKind.Generator;

        if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
          key = parseIdentifier(parser, context);

          state |= PropertyKind.Method;

          if (parser.token === Token.LeftParen) {
            value = parseMethodDefinition(parser, context, state);
          } else if (context & Context.OptionsTS && parser.token === Token.LessThan) {
            value = parseMethodDefinition(parser, context, state);
          } else {
            report(parser, context, Errors.Unexpected, /* early */ 0);
          }
        } else if ((parser.token & Token.IsStringOrNumber) === Token.IsStringOrNumber) {
          key = parseLiteral(parser, context);
          state |= PropertyKind.Method;
          value = parseMethodDefinition(parser, context, state);
        } else if (parser.token === Token.LeftBracket) {
          state |= PropertyKind.Computed | PropertyKind.Method;
          key = parseComputedPropertyName(parser, context);
          value = parseMethodDefinition(parser, context, state);
        } else {
          report(parser, context, Errors.Unexpected, /* early */ 0);
        }
      } else {
        report(parser, context, Errors.Unexpected, /* early */ 0);
      }

      properties.push(
        finishNode({
          type: 'Property',
          key,
          value,
          kind: !(state & PropertyKind.GetSet) ? 'init' : state & PropertyKind.Setter ? 'set' : 'get',
          computed: (state & PropertyKind.Computed) > 0,
          method: (state & PropertyKind.Method) > 0,
          shorthand: (state & PropertyKind.Shorthand) > 0
        })
      );
    }

    if (parser.token !== Token.Comma) break;

    nextToken(parser, context);
  }

  consume(parser, context, Token.RightBrace);

  let node: any = null;

  if (context & Context.OptionsTS) {
    const optional = !!isPattern && consumeOpt(parser, context, Token.QuestionMark);
    const typeAnnotation =
      isPattern && parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];

    node = finishNode({
      type: 'ObjectExpression',
      properties,
      typeAnnotation,
      optional,
      decorators
    });
  } else {
    node = finishNode({
      type: 'ObjectExpression',
      properties
    });
  }

  if (!skipInitializer && parser.token & Token.IsAssignOp) {
    return parseArrayOrObjectAssignmentPattern(parser, context, node) as any;
  }

  return node;
}

export function parseArrayOrObjectAssignmentPattern(
  parser: ParserState,
  context: Context,
  node: any
): ESTree.AssignmentExpression {
  nextToken(parser, context | Context.AllowRegExp);

  reinterpretToPattern(parser, node);
  const right = parseExpression(parser, context);

  return finishNode({
    type: 'AssignmentExpression',
    left: node,
    operator: '=',
    right
  });
}

export function parseComputedPropertyName(parser: ParserState, context: Context): ESTree.Expression {
  // ComputedPropertyName :
  //   [ AssignmentExpression ]
  nextToken(parser, context | Context.AllowRegExp);
  //const key = this.parseExpression(isTS, 1);

  let key = parsePrimaryExpression(
    parser,
    (context | Context.DisallowIn) ^ Context.DisallowIn,
    /* isLHS */ 1,
    /* inParen */ 0
  );
  key = parseMemberOrUpdateExpression(parser, context, key);
  key = parseAssignmentExpression(parser, context, key);
  consume(parser, context, Token.RightBracket);
  return key;
}

export function parseTypeScriptMethodDefinition(
  parser: ParserState,
  context: Context,
  isConstructor: boolean,
  kind: PropertyKind,
  modifiers: ModifierKind,
  declare: 0 | 1 = 0
): ESTree.FunctionExpression | ESTree.EmptyBodyFunctionExpression {
  let body: any = null;
  let typeParameters: any = null;
  if (parser.token === Token.LessThan) {
    if (kind & (PropertyKind.Getter | PropertyKind.Setter)) report(parser, context, Errors.Unexpected, 0);
    typeParameters = parseTypeParameters(parser, context);
  }

  const modifierFlags =
    (kind & PropertyKind.Constructor) < 1 ? 0b0000001111010000000_0000_00000000 : 0b0000000111000000000_0000_00000000;

  context =
    ((context | modifierFlags) ^ modifierFlags) |
    ((kind & 0b0000000000000000000_0000_01011000) << 18) |
    0b0000110000001000000_0000_00000000;

  const params =
    isConstructor && !declare
      ? parseConstructorFormals(parser, context, declare)
      : parseTypescriptMethodFormals(parser, context, kind);

  const returnType =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : null;

  if (parser.token !== Token.LeftBrace) {
    if (!declare && isConstructor) {
      //report(parser, context, Errors.MissingConstructorImplement, /* early */ 0);
    } else if ((modifiers & ModifierKind.Abstract) === 0 && (kind & PropertyKind.GetSet) === 0) {
      if (modifiers & ModifierKind.Accessibility) {
        //report(parser, context, Errors.MissingFuncDecl, /* early */ 0);
      }
    }

    consumeSemicolon(parser, context);
  } else {
    if (declare) report(parser, context, Errors.InvalidImplmentAmbientContext, /* early */ 0);

    if (modifiers & ModifierKind.Abstract)
      report(
        parser,
        context,
        kind & PropertyKind.GetSet ? Errors.NoImplementAbstractAccessor : Errors.NoClassImplementation,
        /* early */ 0
      );
    body = parseFunctionBody(parser, context & ~(0x8001000 | Context.InGlobal), Origin.None);
  }

  return finishNode({
    type: body ? 'FunctionExpression' : 'EmptyBodyFunctionExpression',
    params,
    body,
    async: (kind & PropertyKind.Async) > 0,
    generator: (kind & PropertyKind.Generator) > 0,
    id: null,
    returnType,
    typeParameters,
    declare: false
  });
}

export function parseMethodDefinition(parser: ParserState, context: Context, kind: PropertyKind): any {
  let body: any = null;
  let typeParameters: any = null;
  const isTS = context & Context.OptionsTS;

  if (isTS) {
    if (parser.token === Token.LessThan) {
      if (kind & (PropertyKind.Getter | PropertyKind.Setter)) report(parser, context, Errors.Unexpected, 0);
      typeParameters = parseTypeParameters(parser, context);
    }
  }

  const modifierFlags =
    (kind & PropertyKind.Constructor) < 1 ? 0b0000001111010000000_0000_00000000 : 0b0000000111000000000_0000_00000000;

  context =
    ((context | modifierFlags) ^ modifierFlags) |
    ((kind & 0b0000000000000000000_0000_01011000) << 18) |
    0b0000110000001000000_0000_00000000;

  const params = isTS ? parseTypescriptMethodFormals(parser, context, kind) : parseMethodFormals(parser, context, kind);

  const returnType =
    isTS && parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : null;

  if (isTS && parser.token !== Token.LeftBrace) {
    consumeSemicolon(parser, context);
  } else {
    body = parseFunctionBody(parser, context & ~(0x8001000 | Context.InGlobal), Origin.None);
  }

  return isTS
    ? finishNode({
        type: body ? 'FunctionExpression' : 'EmptyBodyFunctionExpression',
        params,
        body,
        async: (kind & PropertyKind.Async) > 0,
        generator: (kind & PropertyKind.Generator) > 0,
        id: null,
        returnType,
        typeParameters,
        declare: false
      } as any)
    : finishNode({
        type: 'FunctionExpression',
        params,
        body,
        async: (kind & PropertyKind.Async) > 0,
        generator: (kind & PropertyKind.Generator) > 0,
        id: null
      });
}

export function parseTypescriptMethodFormals(
  parser: ParserState,
  context: Context,
  kind: PropertyKind
): ESTree.Parameter[] {
  consume(parser, context, Token.LeftParen);
  if (parser.token === Token.RightParen) {
    if (kind & PropertyKind.Setter) {
      report(parser, context, Errors.AccessorWrongArgs, /* early */ 1, 'Setter', 'one', '');
    }
    nextToken(parser, context);
    return [];
  }

  let isThisKeyword = 0;
  let params: ESTree.Parameter[] = [];
  let setterArgs = 0;
  let left: any;

  if (parser.token === Token.ThisKeyword) {
    params = [parseBindingIdentifier(parser, context, 1, 1)];
    if (!consumeOpt(parser, context, Token.Comma)) {
      nextToken(parser, context);
      return params;
    }

    isThisKeyword++;
  }

  while (parser.token !== Token.RightParen) {
    if ((parser.token & (Token.FutureReserved | Token.Keywords | Token.IsIdentifier)) > 0) {
      if (parser.token === Token.ThisKeyword) isThisKeyword++;
      left = parseBindingIdentifier(parser, context, /* requireTypeAnnotation */ 0, /* canBeOptionalParam */ 1);
    } else {
      const decorators = parser.token === Token.At ? parseDecorators(parser, context | Context.InDecoratorContext) : [];
      if (parser.token === Token.LeftBrace) {
        left = parseObjectLiteralOrPattern(parser, context, 1, /* isPattern */ 1, decorators);
      } else if (parser.token === Token.LeftBracket) {
        left = parseArrayExpressionOrPattern(parser, context, 1, /* isPattern */ 1, decorators);
      } else if (parser.token === Token.Ellipsis) {
        left = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, decorators);
      } else if ((parser.token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved)) > 0) {
        left = parseBindingIdentifier(parser, context, /* requireTypeAnnotation */ 0, /* canBeOptionalParam */ 1);
        left.decorators = decorators;
      } else {
        report(parser, context, Errors.Unexpected, 0);
      }

      reinterpretToPattern(parser, left);
    }
    if (parser.token === Token.Assign) {
      nextToken(parser, context | Context.AllowRegExp);

      const right = parseExpression(parser, context);

      left = finishNode({
        type: 'AssignmentPattern',
        left,
        right
      });
    }
    setterArgs++;
    params.push(left);

    if (parser.token !== Token.RightParen) consume(parser, context, Token.Comma);
  }

  if (isThisKeyword === 0) {
    if (kind & PropertyKind.Getter) {
      report(parser, context, Errors.AccessorWrongArgs, /* early */ 1, 'Getter', 'no', 's');
    }
    if (kind & PropertyKind.Setter && setterArgs !== 1) {
      report(parser, context, Errors.AccessorWrongArgs, /* early */ 1, 'Setter', 'one', '');
    }
  }

  consume(parser, context, Token.RightParen);
  return params;
}

export function parseMethodFormals(parser: ParserState, context: Context, kind: PropertyKind): ESTree.Parameter[] {
  consume(parser, context, Token.LeftParen);

  if (parser.token === Token.RightParen) {
    if (kind & PropertyKind.Setter) {
      report(parser, context, Errors.AccessorWrongArgs, /* early */ 1, 'Setter', 'one', '');
    }
    nextToken(parser, context);
    return [];
  }

  const params: ESTree.Parameter[] = [];
  let setterArgs = 0;
  let left: any;

  if (kind & PropertyKind.Getter) {
    report(parser, context, Errors.AccessorWrongArgs, /* early */ 1, 'Getter', 'no', 's');
  }

  if (kind & PropertyKind.Setter && parser.token === Token.Ellipsis) {
    report(parser, context, Errors.BadSetterRestParameter, /* early */ 1);
  }
  while (parser.token !== Token.RightParen) {
    if ((parser.token & (Token.FutureReserved | Token.Keywords | Token.IsIdentifier)) > 0) {
      left = parseIdentifier(parser, context);
    } else {
      if (parser.token === Token.LeftBrace) {
        left = parseObjectLiteralOrPattern(parser, context, 1, /* isPattern */ 1, []);
      } else if (parser.token === Token.LeftBracket) {
        left = parseArrayExpressionOrPattern(parser, context, 1, /* isPattern */ 1, []);
      } else if (parser.token === Token.Ellipsis) {
        left = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 0, []);
      } else {
        report(parser, context, Errors.Unexpected, 0);
      }

      reinterpretToPattern(parser, left);
    }

    if (parser.token === Token.Assign) {
      nextToken(parser, context | Context.AllowRegExp);

      const right = parseExpression(parser, context);

      left = finishNode({
        type: 'AssignmentPattern',
        left,
        right
      });
    }
    setterArgs++;
    params.push(left);

    if (parser.token !== Token.RightParen) consume(parser, context, Token.Comma);
  }

  if (kind & PropertyKind.Setter && setterArgs !== 1) {
    report(parser, context, Errors.AccessorWrongArgs, /* early */ 1, 'Setter', 'one', '');
  }

  consume(parser, context, Token.RightParen);
  return params;
}

export function parseSpreadOrRestElement(
  parser: ParserState,
  context: Context,
  closingToken: Token,
  allowTypeAnnotation: 0 | 1,
  decorators: ESTree.Decorator[]
): any {
  nextToken(parser, context | Context.AllowRegExp); // skip '...'

  let argument: any;

  if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
    argument = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);

    argument = parseMemberOrUpdateExpression(parser, context, argument);

    if (parser.token !== Token.Comma && parser.token !== closingToken) {
      argument = parseAssignmentExpression(parser, context, argument);
    }
  } else if (parser.token === closingToken) {
    report(parser, context, Errors.Unexpected, /* early */ 0);
  } else if (parser.token & Token.IsPatternStart) {
    argument =
      parser.token === Token.LeftBrace
        ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 0, [])
        : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 0, []);

    const { token } = parser;

    if (token !== Token.Assign && token !== closingToken && token !== Token.Comma) {
      argument = parseMemberOrUpdateExpression(parser, context, argument);

      if (parser.token !== Token.Comma && parser.token !== closingToken) {
        argument = parseAssignmentExpression(parser, context, argument);
      }
    }
  } else {
    argument = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

    const { token } = parser;

    if (token === Token.Assign && token !== closingToken && token !== Token.Comma) {
      argument = parseAssignmentExpression(parser, context, argument);
    } else {
      if (token === Token.Comma) {
        // TODO
      } else if (token !== closingToken) {
        argument = parseAssignmentExpression(parser, context, argument);
      }
    }

    return finishNode({
      type: 'SpreadElement',
      argument
    });
  }

  if (parser.token !== closingToken) {
    if (consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)) {
      reinterpretToPattern(parser, argument);
      const right = parseExpression(parser, context);

      argument = finishNode({
        type: 'AssignmentExpression',
        left: argument,
        operator: '=',
        right
      });
    }
  }

  return context & Context.OptionsTS && allowTypeAnnotation
    ? finishNode({
        type: 'SpreadElement',
        argument,
        optional: consumeOpt(parser, context, Token.QuestionMark),
        typeAnnotation:
          allowTypeAnnotation && parser.token === Token.Colon
            ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0)
            : [],
        value: null,
        decorators
      })
    : finishNode({
        type: 'SpreadElement',
        argument
      });
}

export function parseArrayLiteral(parser: ParserState, context: Context, skipInitializer: 0 | 1): any {
  return parseArrayExpressionOrPattern(parser, context, skipInitializer, /* isPattern */ 0, []);
}

export function parseArrayExpressionOrPattern(
  parser: ParserState,
  context: Context,
  skipInitializer: 0 | 1,
  isPattern: 0 | 1,
  decorators: ESTree.Decorator[]
): ESTree.ArrayExpression | ESTree.ArrayPattern | ESTree.AssignmentExpression {
  nextToken(parser, context | Context.AllowRegExp); // skips: '['
  const elements: any[] = [];
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  while (parser.token !== Token.RightBracket) {
    if (consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) {
      elements.push(null);
    } else {
      let left: any;

      const { token } = parser;

      if (token & Token.IsIdentifier) {
        left = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);

        if (consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)) {
          const right = parseExpression(parser, context);

          left = finishNode({
            type: 'AssignmentExpression',
            operator: '=',
            left,
            right
          });
        } else {
          left = parseMemberOrUpdateExpression(parser, context, left);

          if (parser.token !== Token.Comma && parser.token !== Token.RightBracket) {
            left = parseAssignmentExpression(parser, context, left);
          }
        }
      } else if (token & Token.IsPatternStart) {
        left =
          parser.token === Token.LeftBrace
            ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, isPattern, [])
            : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, isPattern, []);

        if (parser.token === Token.Comma || parser.token === Token.RightBracket) {
          // TODO
        } else {
          left = parseMemberOrUpdateExpression(parser, context, left);
          if (parser.token !== Token.Comma && parser.token !== Token.RightBracket) {
            left = parseAssignmentExpression(parser, context, left);
          }
        }
      } else if (token === Token.Ellipsis) {
        left = parseSpreadOrRestElement(parser, context, Token.RightBracket, /* allowTypeAnnotation */ 0, []);
      } else {
        left = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

        if (parser.token !== Token.Comma && parser.token !== Token.RightBracket) {
          left = parseAssignmentExpression(parser, context, left);
        }
      }
      elements.push(left);

      if (consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) {
        if (parser.token === Token.RightBracket) break;
      } else break;
    }
  }

  consume(parser, context, Token.RightBracket);
  let node: any = null;

  if (context & Context.OptionsTS) {
    const optional = !!isPattern && consumeOpt(parser, context, Token.QuestionMark);
    const typeAnnotation =
      isPattern && parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];
    node = finishNode({
      type: 'ArrayExpression',
      elements,
      typeAnnotation,
      optional,
      decorators
    });
  } else {
    node = finishNode({
      type: 'ArrayExpression',
      elements
    });
  }
  if (!skipInitializer && parser.token & Token.IsAssignOp) {
    return parseArrayOrObjectAssignmentPattern(parser, context, node) as any;
  }

  return node;
}

export function parseParenthesizedExpression(parser: ParserState, context: Context, isLHS: 0 | 1): any {
  consumeOpt(parser, context | Context.AllowRegExp, Token.LeftParen);
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  if (consumeOpt(parser, context, Token.RightParen)) {
    if (parser.token !== Token.Arrow) report(parser, context, Errors.Unexpected, /* early */ 0);
    if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseArrowFunctionExpression(parser, context, [], null, null, isLHS, /* isAsync */ 0);
  }

  let expr: any;
  let expressions: any[] = [];
  let isSequence: 0 | 1 = 0;

  while (parser.token !== Token.RightParen) {
    const { token } = parser;

    if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
      expr = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 1);

      if (parser.token === Token.Comma || parser.token === Token.RightParen) {
        // TODO
      } else {
        expr = parseMemberOrUpdateExpression(parser, context, expr);

        if (parser.token !== Token.Comma && parser.token !== Token.RightParen) {
          expr = parseAssignmentExpression(parser, context, expr);
        }
      }
    } else if (token & Token.IsPatternStart) {
      expr =
        parser.token === Token.LeftBrace
          ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 0, [])
          : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 0, []);

      if (parser.token !== Token.Comma && parser.token !== Token.RightParen) {
        expr = parseMemberOrUpdateExpression(parser, context, expr);

        if (parser.token !== Token.Comma && parser.token !== Token.RightParen) {
          expr = parseAssignmentExpression(parser, context, expr);
        }
      }
    } else if (token === Token.Ellipsis) {
      expr = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, []);
    } else {
      expr = parseExpression(parser, context);

      if (isSequence && (parser.token === Token.Comma || parser.token === Token.RightParen)) {
        expressions.push(expr);
      }

      if (parser.token === Token.Comma) {
        if (!isSequence) {
          isSequence = 1;
          expressions = [expr];
        }
      }

      if (isSequence) {
        while (consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) {
          expressions.push(parseExpression(parser, context));
        }

        expr = finishNode({
          type: 'SequenceExpression',
          expressions
        });
      }

      consume(parser, context, Token.RightParen);

      return expr;
    }

    if (isSequence && (parser.token === Token.Comma || parser.token === Token.RightParen)) {
      expressions.push(expr);
    }

    if (!consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) break;

    if (!isSequence) {
      isSequence = 1;
      expressions = [expr];
    }

    if (parser.token === Token.RightParen) {
      break;
    }
  }

  if (isSequence) {
    expr = finishNode({
      type: 'SequenceExpression',
      expressions
    });
  }

  consume(parser, context, Token.RightParen);

  if (parser.token === Token.Arrow) {
    return parseArrowFunctionExpression(
      parser,
      context,
      isSequence ? expressions : [expr],
      null,
      null,
      isLHS,
      /* isAsync */ 0
    );
  }

  return expr;
}

export function parseOptionalNchanged(parser: ParserState, context: Context, param: any, isAsync: any): any {
  // Conditional
  if (parser.token !== Token.Colon && parser.token !== Token.Comma && parser.token !== Token.RightParen) {
    const consequent = parseExpression(
      parser,
      (context | Context.DisallowIn | Context.Conditional) ^ Context.DisallowIn
    );
    consume(parser, context | Context.AllowRegExp, Token.Colon);
    const alternate = parseExpression(parser, context);
    const expr = finishNode({
      type: 'ConditionalExpression',
      test: param[0],
      consequent,
      alternate
    });

    nextToken(parser, context);
    return expr;
  }

  while (consumeOpt(parser, context, Token.Comma)) {
    param.push(
      parser.token === Token.Ellipsis
        ? parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, [])
        : parseBindingIdentifier(parser, context, 0, 1)
    );
  }

  if (parser.token === Token.RightParen) {
    nextToken(parser, context);
    const returnType =
      parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : null;
    return parseArrowFunctionExpression(parser, context, param, [], returnType, 1, isAsync);
  }
}

export function parseTypescriptParenthesizedExpression(
  parser: ParserState,
  context: Context,
  isLHS: 0 | 1,
  typeAnnotation: any[],
  assertion: TypeAssertionState
): any {
  consumeOpt(parser, context | Context.AllowRegExp, Token.LeftParen);
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;
  if (consumeOpt(parser, context, Token.RightParen)) {
    let returnType: any[] | null = null;
    if (assertion > 0) {
      if (assertion & (TypeAssertionState.Unfinished | TypeAssertionState.TypeAssertion))
        report(parser, context, Errors.ExpressionExpected, /* early */ 0);
      if (assertion & TypeAssertionState.UnKnown) {
        typeAnnotation = finishNode({
          type: 'TypeParameterDeclaration',
          params: [parseTypeParameterFromValue(parser, context, typeAnnotation as any)]
        } as any);
      }
    }
    if (parser.token === Token.Colon) {
      if (context & Context.Conditional) {
        const returnType = tryScan(parser, context, function(): any {
          const returnType = parseTypeAnnotation(parser, context | Context.Speculative, /* restrictedTypes */ 0);
          if (parser.token === Token.Arrow) return returnType;
          return undefined;
        });
        return returnType
          ? parseArrowFunctionExpression(parser, context, [], typeAnnotation, returnType, isLHS, /* isAsync */ 0)
          : [];
      } else {
        returnType = parseTypeAnnotation(parser, context | Context.Speculative, /* restrictedTypes */ 0);
      }
    }

    if (parser.token !== Token.Arrow) report(parser, context, Errors.Unexpected, /* early */ 0);
    if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 1);

    return parseArrowFunctionExpression(parser, context, [], typeAnnotation, returnType, isLHS, /* isAsync */ 0);
  }

  let expr: any;
  let expressions: any[] = [];
  let isSequence: 0 | 1 = 0;

  while (parser.token !== Token.RightParen) {
    const { token } = parser;

    if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
      expr = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 1);
      if (parser.token === Token.QuestionMark) {
        nextToken(parser, context);
        if (parser.token === Token.Colon) {
          expr.typeAnnotation = parseTypeAnnotation(parser, context, /* restrictedTypes */ 0);
        }
        if (isSequence) expressions.push(expr);
        return parseOptionalNchanged(parser, context, isSequence ? expressions : [expr], /* isAsync */ 0);
      }
      if (parser.token === Token.Comma || parser.token === Token.RightParen) {
        // TODO
      } else {
        expr = parseMemberOrUpdateExpression(parser, context, expr);
        if (parser.token !== Token.Comma && parser.token !== Token.RightParen) {
          expr = parseAssignmentExpression(parser, context, expr);
        }
      }
    } else if (token & Token.IsPatternStart) {
      expr =
        parser.token === Token.LeftBrace
          ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 0, [])
          : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 0, []);

      if (parser.token === Token.Colon) {
        expr.typeAnnotation = parseTypeAnnotation(parser, context, /* restrictedTypes */ 0);
      }

      if (parser.token !== Token.Comma && parser.token !== Token.RightParen) {
        expr = parseMemberOrUpdateExpression(parser, context, expr);

        if (parser.token !== Token.Comma && parser.token !== Token.RightParen) {
          expr = parseAssignmentExpression(parser, context, expr);
        }
      }
    } else if (token === Token.Ellipsis) {
      expr = parseSpreadOrRestElement(parser, context, Token.RightParen, /* allowTypeAnnotation */ 1, []);
    } else if (assertion > 0 && parser.token === Token.LeftParen) {
      let type = parseTypeFromValue(parser, context, typeAnnotation as any);
      type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
      const expression = parseTypescriptParenthesizedExpression(parser, context, isLHS, typeAnnotation, assertion);
      consume(parser, context, Token.RightParen);
      return finishNode({
        type: 'TypeAssertion',
        typeAnnotation: type,
        expression
      });
    } else {
      expr = parseExpression(parser, context);

      if (isSequence && (parser.token === Token.Comma || parser.token === Token.RightParen)) {
        expressions.push(expr);
      }

      if (parser.token === Token.Comma) {
        if (!isSequence) {
          isSequence = 1;
          expressions = [expr];
        }
      }

      if (isSequence) {
        while (consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) {
          expressions.push(parseExpression(parser, context));
        }

        expr = finishNode({
          type: 'SequenceExpression',
          expressions
        });
      }

      consume(parser, context, Token.RightParen);

      return expr;
    }

    if (isSequence && (parser.token === Token.Comma || parser.token === Token.RightParen)) {
      expressions.push(expr);
    }

    if (!consumeOpt(parser, context | Context.AllowRegExp, Token.Comma)) break;

    if (!isSequence) {
      isSequence = 1;
      expressions = [expr];
    }

    if (parser.token === Token.RightParen) {
      break;
    }
  }

  if (isSequence) {
    expr = finishNode({
      type: 'SequenceExpression',
      expressions
    });
  }

  consume(parser, context, Token.RightParen);

  if (context & Context.Conditional && parser.token === Token.Colon) {
    const returnType = tryScan(parser, context, function(): any {
      const returnType = parseTypeAnnotation(parser, context | Context.Speculative, /* restrictedTypes */ 0);
      if (parser.token === Token.Arrow) return returnType;
      return undefined;
    });
    return returnType
      ? parseArrowFunctionExpression(
          parser,
          context,
          isSequence ? expressions : [expr],
          typeAnnotation,
          returnType,
          isLHS,
          /* isAsync */ 0
        )
      : expr;
  }

  let returnType: any = null;

  if (parser.token === Token.Colon) {
    returnType = parseTypeOrTypePredicate(parser, context | Context.Speculative, /* restrictedTypes */ 0);
    if (parser.token !== Token.Arrow) report(parser, context, Errors.Unexpected, /* early */ 0);
  }

  if (parser.token === Token.Arrow) {
    if (assertion > 0) {
      if (assertion & (TypeAssertionState.Unfinished | TypeAssertionState.TypeAssertion))
        report(parser, context, Errors.ExpressionExpected, /* early */ 0);
      if (assertion & TypeAssertionState.UnKnown) {
        typeAnnotation = finishNode({
          type: 'TypeParameterDeclaration',
          params: [parseTypeParameterFromValue(parser, context, typeAnnotation as any)]
        } as any);
      }
    }

    return parseArrowFunctionExpression(
      parser,
      context,
      isSequence ? expressions : [expr],
      typeAnnotation,
      returnType,
      isLHS,
      /* isAsync */ 0
    );
  }

  if (assertion > 0) {
    if (assertion & (TypeAssertionState.TypeAssertion | TypeAssertionState.TypeParameter)) return typeAnnotation;

    if (assertion & TypeAssertionState.UnKnown) {
      typeAnnotation = parseTypeFromValue(parser, context, typeAnnotation as any) as any;
      typeAnnotation = parseUnionAndIntersectionType(parser, context, typeAnnotation, 0, 0, 0) as any;
    }
    return finishNode({
      type: 'TypeAssertion',
      typeAnnotation,
      expression: expr
    } as any);
  }

  return expr;
}

export function parseArrowFunctionExpression(
  parser: ParserState,
  context: Context,
  params: any,
  typeParameters: any,
  returnType: any,
  isLHS: 0 | 1,
  isAsync: 0 | 1
): ESTree.ArrowFunctionExpression {
  consume(parser, context | Context.AllowRegExp, Token.Arrow);

  for (let i = 0; i < params.length; ++i) reinterpretToPattern(parser, params[i]);

  context = ((context | 0b0000000111100000000_0000_00000000) ^ 0b0000000111100000000_0000_00000000) | (isAsync << 22);
  const expression = parser.token !== Token.LeftBrace;

  if (!isLHS) report(parser, context, Errors.Unexpected, /* early */ 1);

  let body: any;

  if (expression) {
    // Single-expression body
    body = parseExpression(parser, (context | Context.Conditional) ^ Context.Conditional);
  } else {
    body = parseFunctionBody(
      parser,
      (context | 0b0001000000000000001_0000_00000000 | Context.InGlobal | Context.InClass | Context.Conditional) ^
        (0b0001000000000000001_0000_00000000 | Context.InGlobal | Context.InClass | Context.Conditional),
      Origin.Arrow
    );

    if ((parser.token & Token.IsBinaryOp) === Token.IsBinaryOp && parser.precedingLineBreak === 0)
      report(parser, context, Errors.UnexpectedToken, /* early */ 0, KeywordDescTable[parser.token & Token.Type]);
    if ((parser.token & Token.IsUpdateOp) === Token.IsUpdateOp)
      report(parser, context, Errors.InvalidArrowPostfix, /* early */ 0);

    switch (parser.token) {
      case Token.Period:
      case Token.LeftBracket:
      case Token.TemplateTail:
      case Token.QuestionMark:
        report(parser, context, Errors.InvalidAccessedBlockBodyArrow, /* early */ 0);
      case Token.LeftParen:
        report(parser, context, Errors.InvalidInvokedBlockBodyArrow, /* early */ 0);
      default: // ignore
    }
  }

  return context & Context.OptionsTS
    ? finishNode({
        type: 'ArrowFunctionExpression',
        body,
        params,
        async: isAsync === 1,
        expression,
        returnType,
        typeParameters
      })
    : finishNode({
        type: 'ArrowFunctionExpression',
        body,
        params,
        async: isAsync === 1,
        expression
      });
}

export function parseSuperExpression(parser: ParserState, context: Context): ESTree.Super {
  nextToken(parser, context);

  switch (parser.token) {
    case Token.LeftParen: {
      // The super property has to be within a class constructor
      if ((context & Context.SuperCall) < 1) report(parser, context, Errors.SuperNoConstructor, /* early */ 1);
      break;
    }
    case Token.LeftBracket:
    case Token.Period: {
      // new super() is never allowed.
      // super() is only allowed in derived constructor
      if ((context & Context.SuperProperty) < 1) report(parser, context, Errors.InvalidSuperProperty, /* early */ 1);
      break;
    }
    default:
      report(parser, context, Errors.UnexpectedToken, /* early */ 1, 'super');
  }

  return finishNode({ type: 'Super' });
}

export function parseNewExpression(parser: ParserState, context: Context): ESTree.NewExpression | ESTree.MetaProperty {
  const id = parseIdentifier(parser, context | Context.AllowRegExp);

  if (consumeOpt(parser, context, Token.Period)) {
    if (context & Context.AllowNewTarget && parser.tokenValue === 'target') {
      return parseMetaProperty(parser, context, id);
    }
    report(parser, context, Errors.InvalidNewTarget, /* early */ 1);
  }
  const isTS = context & Context.OptionsTS;
  const expr = parsePrimaryExpression(parser, context, /* isLHS */ 0, /* inParen */ 0);
  let typeParameters = null;

  if (isTS && parser.token === Token.LessThan) {
    typeParameters = parseTypeParameterInstantiation(parser, context);
    if (parser.token !== Token.LeftParen) report(parser, context, Errors.Unexpected, 0);
  }
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;

  // NewExpression without arguments.
  const callee = parseMembeExpressionNoCall(parser, context, expr);

  const args = parser.token === Token.LeftParen ? parseArguments(parser, context) : [];

  return isTS
    ? finishNode({
        type: 'NewExpression',
        callee,
        arguments: args,
        typeParameters
      })
    : finishNode({
        type: 'NewExpression',
        callee,
        arguments: args
      });
}

export function parseMetaProperty(parser: ParserState, context: Context, meta: ESTree.Identifier): ESTree.MetaProperty {
  const property = parseIdentifier(parser, context);
  return finishNode({
    type: 'MetaProperty',
    meta,
    property
  });
}

export function parseMembeExpressionNoCall(parser: ParserState, context: Context, expr: any): ESTree.MemberExpression {
  const { token } = parser;

  /* Property */
  if (token === Token.Period) {
    nextToken(parser, context);

    const property = parseIdentifier(parser, context);

    return parseMembeExpressionNoCall(
      parser,
      context,
      finishNode({
        type: 'MemberExpression',
        object: expr,
        computed: false,
        property
      })
    );
    /* Property */
  } else if (token === Token.LeftBracket) {
    nextToken(parser, context | Context.AllowRegExp);

    const property = parseExpressions(parser, context);

    consume(parser, context, Token.RightBracket);

    return parseMembeExpressionNoCall(
      parser,
      context,
      finishNode({
        type: 'MemberExpression',
        object: expr,
        computed: true,
        property
      })
    );

    /* Template */
  } else if (token === Token.TemplateCont || token === Token.TemplateTail) {
    return parseMembeExpressionNoCall(parser, context, {
      type: 'TaggedTemplateExpression',
      tag: expr,
      quasi:
        parser.token === Token.TemplateCont
          ? parseTemplateLiteral(parser, context)
          : parseNoSubstitutionTemplate(parser, context | Context.TaggedTemplate)
    });
  }
  return expr;
}

export function parseNoSubstitutionTemplate(parser: ParserState, context: Context): ESTree.TemplateLiteral {
  consume(parser, context, Token.TemplateTail);
  return finishNode({
    type: 'TemplateLiteral',
    expressions: [],
    quasis: [parseTemplateElement(parser, true)]
  });
}

export function parseTemplateLiteral(parser: ParserState, context: Context): ESTree.TemplateLiteral {
  context = (context | Context.DisallowIn) ^ Context.DisallowIn;

  const quasis = [parseTemplateElement(parser, false)];

  consume(parser, context | Context.AllowRegExp, Token.TemplateCont);

  const expressions = [parseExpressions(parser, context)];
  while ((parser.token = scanTemplateTail(parser, context)) !== Token.TemplateTail) {
    quasis.push(parseTemplateElement(parser, /* tail */ false));
    consume(parser, context | Context.AllowRegExp, Token.TemplateCont);
    expressions.push(parseExpressions(parser, context));
  }

  quasis.push(parseTemplateElement(parser, /* tail */ true));

  consume(parser, context, Token.TemplateTail);

  return finishNode({
    type: 'TemplateLiteral',
    expressions,
    quasis
  });
}

export function parseTemplateElement(parser: ParserState, tail: boolean): ESTree.TemplateElement {
  return finishNode({
    type: 'TemplateElement',
    tail,
    value: {
      cooked: parser.tokenValue,
      raw: parser.tokenRaw
    }
  });
}

export function parseBigIntLiteral(parser: ParserState, context: Context): any {
  const { tokenRaw, tokenValue } = parser;
  nextToken(parser, context);
  return finishNode({
    type: 'BigIntLiteral',
    value: tokenValue,
    bigint: tokenRaw
  } as any);
}

export function parseUnaryExpression(parser: ParserState, context: Context): ESTree.UnaryExpression {
  const unaryOperator = parser.token;
  nextToken(parser, context | Context.AllowRegExp);
  const arg = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);
  if (parser.token === Token.Exponentiate) report(parser, context, Errors.Unexpected, /* early */ 1);
  if (context & Context.Strict && unaryOperator === Token.DeleteKeyword) {
    if (arg.type === 'Identifier') {
      report(parser, context, Errors.Unexpected, /* early */ 1);
    }
  }

  return finishNode({
    type: 'UnaryExpression',
    operator: KeywordDescTable[unaryOperator & Token.Type] as ESTree.UnaryOperator,
    argument: arg,
    prefix: true
  });
}

export function parseUpdateExpressionPrefixed(parser: ParserState, context: Context, inNew: 0 | 1): any {
  if (inNew) report(parser, context, Errors.Unexpected, /* early */ 1);

  const { token } = parser;

  nextToken(parser, context | Context.AllowRegExp);

  const arg = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

  return finishNode({
    type: 'UpdateExpression',
    argument: arg,
    operator: KeywordDescTable[token & Token.Type],
    prefix: true
  });
}

export function parseLiteral(parser: ParserState, context: Context): any {
  const { tokenValue } = parser;
  nextToken(parser, context);
  return finishNode({
    type: 'Literal',
    value: tokenValue
  });
}

export function parseIdentifier(parser: ParserState, context: Context): any {
  const { tokenValue } = parser;
  nextToken(parser, context);
  return finishNode({
    type: 'Identifier',
    name: tokenValue
  });
}

export function parseThisExpression(parser: ParserState, context: Context): any {
  nextToken(parser, context);
  return finishNode({
    type: 'ThisExpression'
  });
}

export function parseNullOrTrueOrFalseLiteral(parser: ParserState, context: Context): any {
  const raw = KeywordDescTable[parser.token & Token.Type];
  const value = parser.token === Token.NullKeyword ? null : raw === 'true';
  nextToken(parser, context);
  return finishNode({
    type: 'Literal',
    value
  });
}

export function parseRegExpLiteral(parser: ParserState, context: Context): any {
  const { tokenRegExp, tokenValue } = parser;
  nextToken(parser, context);
  return finishNode({
    type: 'Literal',
    value: tokenValue,
    regex: tokenRegExp
  } as any);
}

export function parseTypeParameters(parser: ParserState, context: Context): ESTree.TypeParameterDeclaration | never[] {
  const params: any[] = [];
  consume(parser, context, Token.LessThan);
  while (parser.token !== Token.GreaterThan) {
    params.push(parseTypeParameter(parser, context | Context.InTSTypes));
    if (parser.token !== Token.GreaterThan) {
      consume(parser, context, Token.Comma);
    }
  }
  consume(parser, context, Token.GreaterThan);
  return finishNode({
    type: 'TypeParameterDeclaration',
    params
  });
}

export function parseTypeParameter(parser: ParserState, context: Context): ESTree.TypeParameter {
  const name = parseBindingIdentifier(parser, context, 0, 0);
  let constraint: any = null;
  if (consumeOpt(parser, context, Token.ExtendsKeyword)) {
    //   nextToken();    return token() === SyntaxKind.ImportKeyword; === isStartOfType()
    // if ((parser.token & Token.IsExpressionStart) !== Token.IsExpressionStart) {
    constraint = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
    // }
  }

  const default_ = consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)
    ? parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None)
    : null;

  return finishNode({
    type: 'TypeParameter',
    name,
    constraint,
    default: default_
  });
}

export function parseBindingIdentifier(
  parser: ParserState,
  context: Context,
  requireTypeAnnotation: 0 | 1,
  canBeOptionalParam: 0 | 1
): ESTree.Identifier {
  const { tokenValue } = parser;
  let definite = false;
  nextToken(parser, context);

  const optional: any = canBeOptionalParam && consumeOpt(parser, context, Token.QuestionMark);

  if (consumeOpt(parser, context, Token.Negate)) {
    definite = true;
  }

  const typeAnnotation =
    requireTypeAnnotation || parser.token === Token.Colon
      ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0)
      : [];

  return finishNode({
    type: 'Identifier',
    name: definite ? tokenValue | TypeScriptMadness.Definite : tokenValue,
    optional,
    typeAnnotation
  });
}

export function parseOptionalIdentifier(parser: ParserState, context: Context): ESTree.Identifier {
  const { tokenValue } = parser;
  nextToken(parser, context);

  const optional: any = consumeOpt(parser, context, Token.QuestionMark);

  return finishNode({
    type: 'Identifier',
    name: tokenValue,
    optional,
    typeAnnotation: null
  } as any);
}

export function parseTypeAnnotationNoConsume(parser: ParserState, context: Context, restrictedTypes: 0 | 1): any {
  const typeAnnotation = parseType(parser, context, restrictedTypes, /* isMappedType */ 0, TypeAliasState.None);
  consumeOpt(parser, context, Token.Semicolon);
  return finishNode({
    type: 'TypeAnnotation',
    typeAnnotation
  });
}
export function parseTypeAnnotation(parser: ParserState, context: Context, restrictedTypes: 0 | 1): any {
  nextToken(parser, context);

  const typeAnnotation = parseType(parser, context, restrictedTypes, /* isMappedType */ 0, TypeAliasState.None);
  consumeOpt(parser, context, Token.Semicolon);
  return finishNode({
    type: 'TypeAnnotation',
    typeAnnotation
  });
}

export function parseType(
  parser: ParserState,
  context: Context,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): any {
  const type = parseUnionType(parser, context, restrictedTypes, isMappedType, typeAlias);
  return parser.precedingLineBreak === 0 && consumeOpt(parser, context, Token.ExtendsKeyword)
    ? parseConditionalType(parser, context, restrictedTypes, isMappedType, typeAlias, type)
    : type;
}

export function parseConditionalType(
  parser: ParserState,
  context: Context,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState,
  checkType: ESTree.TypeNode
): ESTree.ConditionalType {
  const extendsType = parseUnionType(parser, context, restrictedTypes, isMappedType, typeAlias);
  consumeOpt(parser, context, Token.QuestionMark);
  const trueType = parseType(parser, context, restrictedTypes, isMappedType, typeAlias);
  consumeOpt(parser, context, Token.Colon);
  const falseType = parseType(parser, context, restrictedTypes, isMappedType, typeAlias);
  return finishNode({
    type: 'ConditionalType',
    checkType,
    extendsType,
    trueType,
    falseType
  });
}

export function parseIntersectionType(
  parser: ParserState,
  context: Context,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): any {
  const hasLeadingOperator = consumeOpt(parser, context, Token.BitwiseAnd);
  let type: any = parseTypeOperatorOrHigher(
    parser,
    context,
    /* isReadOnly */ 0,
    restrictedTypes,
    isMappedType,
    typeAlias
  );
  if (parser.token === Token.BitwiseAnd || hasLeadingOperator) {
    const types = [type];
    while (consumeOpt(parser, context, Token.BitwiseAnd)) {
      types.push(
        parseTypeOperatorOrHigher(parser, context, /* isReadOnly */ 0, restrictedTypes, isMappedType, typeAlias)
      );
    }
    type = finishNode({
      type: 'IntersectionType',
      types
    });
  }
  return type;
}

export function parseTypeOperatorOrHigher(
  parser: ParserState,
  context: Context,
  isReadOnly: 0 | 1,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): ESTree.InferType | ESTree.TypeOperator | ESTree.IndexedAccessType | ESTree.ArrayType {
  switch (parser.token) {
    case Token.ReadOnlyKeyword:
      isReadOnly = 1;
    // falls through
    case Token.KeyOfKeyword:
    case Token.UniqueKeyword:
      return parseTypeOperator(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias);
    case Token.InferKeyword:
      return parseInferType(parser, context);
    default:
      return parsePostFix(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias);
  }
}

export function parseTypeOperator(
  parser: ParserState,
  context: Context,
  isReadOnly: 0 | 1,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): ESTree.TypeOperator {
  const operator = KeywordDescTable[parser.token & Token.Type] as 'keyof' | 'unique' | 'readonly';

  nextToken(parser, context);
  return finishNode({
    type: 'TypeOperator',
    operator,
    typeAnnotation: parseTypeOperatorOrHigher(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias)
  });
}

export function parseInferType(parser: ParserState, context: Context): any {
  nextToken(parser, context);
  const typeParameter = finishNode({
    type: 'TypeParameter',
    name: parseIdentifier(parser, context)
  });
  return finishNode({
    type: 'InferType',
    typeParameter
  } as any);
}

export function parsePostFix(
  parser: ParserState,
  context: Context,
  isReadOnly: 0 | 1,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): ESTree.IndexedAccessType | ESTree.ArrayType {
  const type = parseNonArrayType(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias);
  return parsePostFixTypeOrHigher(parser, context, type);
}

export function parsePostFixTypeOrHigher(
  parser: ParserState,
  context: Context,
  type: any
): ESTree.IndexedAccessType | ESTree.ArrayType {
  while (parser.precedingLineBreak === 0) {
    switch (parser.token) {
      case Token.Negate:
        report(parser, context, Errors.InvalidJSDoc, /* early */ 0);
        break;
      case Token.LeftBracket: {
        nextToken(parser, context | Context.AllowRegExp);
        if (consumeOpt(parser, context, Token.RightBracket)) {
          type = finishNode({
            type: 'ArrayType',
            elementType: type
          } as any);
        } else {
          const indexType = parseType(
            parser,
            context,
            /* restrictedTypes */ 0,
            /* isMappedType */ 0,
            TypeAliasState.None
          );
          consume(parser, context, Token.RightBracket);
          type = finishNode({
            type: 'IndexedAccessType',
            objectType: type,
            indexType
          });
        }
        break;
      }
      default:
        return type;
    }
  }
  return type;
}

export function parseUnionType(
  parser: ParserState,
  context: Context,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): ESTree.UnionType {
  const hasLeadingOperator = consumeOpt(parser, context, Token.BitwiseOr);
  let type = parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias);
  if (parser.token === Token.BitwiseOr || hasLeadingOperator) {
    if (restrictedTypes) report(parser, context, Errors.InvalidIdxSignatureUnion, /* early */ 0);
    const types = [type];
    while (consumeOpt(parser, context, Token.BitwiseOr)) {
      types.push(parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias));
    }
    type = finishNode({
      type: 'UnionType',
      types
    });
  }
  return type;
}
export function parseEntityName(parser: ParserState, context: Context): ESTree.QualifiedName {
  let entity: any = parseIdentifier(parser, context);
  while (consumeOpt(parser, context, Token.Period)) {
    entity = finishNode({
      type: 'QualifiedName',
      left: entity,
      right: parseIdentifier(parser, context)
    });
  }
  return entity;
}

export function parseTypeReference(parser: ParserState, context: Context): ESTree.TypeReference {
  const typeName = parseEntityName(parser, context);
  let typeParameters: any = null;

  if (!parser.precedingLineBreak && parser.token === Token.LessThan) {
    typeParameters = parseTypeParameterInstantiation(parser, context | Context.InTSTypes);
  }
  return finishNode({
    type: 'TypeReference',
    typeName,
    typeParameters
  });
}

export function parseNonArrayType(
  parser: ParserState,
  context: Context,
  isReadOnly: 0 | 1,
  restrictedTypes: 0 | 1,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): any {
  const { token, tokenValue } = parser;

  if ((token & (Token.Contextual | Token.FutureReserved | Token.IsIdentifier)) !== 0) {
    const type = primaryTypes[tokenValue];

    if (restrictedTypes && (tokenValue !== 'string' && tokenValue !== 'number'))
      report(parser, context, Errors.InvalidIndexSignatureParam, /* early */ 0);

    if (type) {
      nextToken(parser, context);
      if (isReadOnly && parser.token !== Token.LeftBracket) {
        report(parser, context, Errors.InvalidReadOnlyModifier, 0);
      }
      return {
        type
      };
    }

    if ((context & Context.Strict && token & Token.FutureReserved) === Token.FutureReserved) {
      report(parser, context, Errors.UnexpectedStrictReserved, 0);
    }
    return parseTypeReference(parser, context);
  }

  switch (token) {
    case Token.ConstKeyword:
      return parseTypeReference(parser, context);
    case Token.StringLiteral:
      return parseLiteralTypedNode(parser, context, /* isBoolean */ 0, 'Literal');
    case Token.NumericLiteral:
      return parseLiteralTypedNode(parser, context, /* isBoolean */ 0, 'Literal');
    case Token.BigIntLiteral:
      return parseLiteralTypedNode(parser, context, /* isBoolean */ 0, 'BigIntLiteral');
    case Token.TrueKeyword:
    case Token.FalseKeyword:
      return parseLiteralTypedNode(parser, context, /* isBoolean */ 1, 'Literal');
    case Token.Subtract:
      return parseSubtractTypeNode(parser, context);
    case Token.TemplateTail:
      return parseTemplateLiteralType(parser, context);
    case Token.LeftBrace:
      return parseObjectTypeMembers(parser, context, typeAlias);
    case Token.LeftBracket:
      return parseTupleType(parser, context);
    case Token.LessThan:
      return parseFunctionType(parser, context);
    case Token.LeftParen:
      return parseFunctionOrConstructorTypeOrParenthesized(parser, context, isMappedType, typeAlias, 'FunctionType');
    case Token.NullKeyword:
      return parseNullOrVoidTypedNode(parser, context, 'NullKeyword');
    case Token.VoidKeyword:
      return parseNullOrVoidTypedNode(parser, context, 'VoidKeyword');
    case Token.TypeOfKeyword:
      nextToken(parser, context);
      return parser.token === Token.ImportKeyword
        ? parseImportType(parser, context, /* isTypeOf */ true)
        : parseTypeQuery(parser, context);
    case Token.NewKeyword:
      return parseNewAsTypeReferenceOrConstructorType(parser, context, isMappedType, typeAlias);
    case Token.ThisKeyword:
      const thisKeyword = parseThisTypeNode(parser, context);
      return parser.token === Token.IsKeyword && parser.precedingLineBreak === 0
        ? parseTypePredicate(parser, context, thisKeyword)
        : thisKeyword;
    case Token.ImportKeyword:
      return parseImportType(parser, context, /* isTypeOf */ false);
    case Token.AssertsKeyword:
      return parseAssertsTypePredicateOrTypePredicate(parser, context);
    case Token.Multiply:
    case Token.MultiplyAssign:
      report(parser, context, Errors.InvalidJSDoc, /* early */ 0);
    default:
      if (context & Context.Speculative && parser.token !== Token.RightParen) return undefined;
      report(
        parser,
        context,
        (context & Context.Strict && token & Token.FutureReserved) === Token.FutureReserved
          ? Errors.UnexpectedStrictReserved
          : Errors.ExpressionExpected,
        /* early */ 0
      );
  }
}

export function parseFunctionType(parser: ParserState, context: Context): any {
  const typeParameters = parseTypeParameters(parser, context) as any;
  if (context & Context.Speculative && parser.token !== Token.LeftParen) return undefined;
  consume(parser, context, Token.LeftParen);
  const params = parseFunctionTypeParams(parser, context);
  consume(parser, context, Token.RightParen);
  consume(parser, context, Token.Arrow);
  const returnType = parseTypeAnnotationNoConsume(parser, context, /* restrictedTypes */ 0);
  return finishNode({
    type: 'FunctionType',
    params,
    returnType,
    typeParameters
  });
}

export function parseNewAsTypeReferenceOrConstructorType(
  parser: ParserState,
  context: Context,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState
): any {
  const { tokenValue } = parser;
  nextToken(parser, context);

  // Mark it if annotation - should fail ' const a: new.a: '

  return parser.token === Token.LeftParen
    ? parseFunctionOrConstructorTypeOrParenthesized(parser, context, isMappedType, typeAlias, 'ConstructorType')
    : parseTypeReferenceFromExpression(
        parser,
        context,
        parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 0)
      );
}

export function parseImportType(parser: ParserState, context: Context, isTypeOf: boolean): ESTree.ImportType {
  nextToken(parser, context);
  consume(parser, context, Token.LeftParen);
  const parameter = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
  consume(parser, context, Token.RightParen);
  const qualifier = consumeOpt(parser, context, Token.Period) ? parseEntityName(parser, context) : null;
  const typeParameters =
    parser.precedingLineBreak === 0 && parser.token === Token.LessThan
      ? parseTypeParameterInstantiation(parser, context)
      : null;
  return finishNode({
    type: 'ImportType',
    qualifier,
    parameter,
    isTypeOf,
    typeParameters
  });
}

export function parseTemplateLiteralType(parser: ParserState, context: Context): ESTree.LiteralType {
  const templateNode = parseNoSubstitutionTemplate(parser, context);
  return finishNode({
    type: 'LiteralType',
    literal: templateNode
  });
}

export function parseSubtractTypeNode(parser: ParserState, context: Context): any {
  const expr = parseIdentifier(parser, context);
  if (parser.token !== Token.NumericLiteral && parser.token !== Token.BigIntLiteral)
    return parseTypeReferenceFromExpression(parser, context, expr);
  const literal = finishNode({
    type: 'UnaryExpression',
    operator: '-',
    prefix: true,
    argument: {
      type: 'Literal',
      value: parser.tokenValue
    }
  });

  nextToken(parser, context);
  return finishNode({
    type: 'LiteralType',
    literal
  });
}

export function parseTypeQuery(parser: ParserState, context: Context): ESTree.TypeQuery {
  const exprName: any = parseEntityName(parser, context);
  return finishNode({
    type: 'TypeQuery',
    exprName
  });
}

export function parseThisTypeNode(parser: ParserState, context: Context): ESTree.ThisType {
  consume(parser, context, Token.ThisKeyword);
  return finishNode({
    type: 'ThisType'
  });
}

export function parseTypePredicate(parser: ParserState, context: Context, parameterName: any): ESTree.TypePredicate {
  const typeAnnotation = parseTypeAnnotation(parser, context, /* restrictedTypes */ 0);
  return finishNode({
    type: 'TypePredicate',
    assertsModifier: false,
    parameterName,
    typeAnnotation
  });
}

export function parseLiteralTypedNode(
  parser: ParserState,
  context: Context,
  isBoolean: 0 | 1,
  type: 'Literal' | 'Literal' | 'BigIntLiteral'
): ESTree.LiteralType {
  const { tokenValue } = parser;

  const literal = {
    type,
    value: isBoolean && type === 'Literal' ? tokenValue === 'true' : tokenValue
  };

  nextToken(parser, context);

  return finishNode({
    type: 'LiteralType',
    literal
  });
}

export function parseNullOrVoidTypedNode(
  parser: ParserState,
  context: Context,
  type: 'NullKeyword' | 'VoidKeyword'
): ESTree.NullKeyword | ESTree.VoidKeyword {
  nextToken(parser, context);
  return finishNode({
    type
  });
}

export function parseFunctionOrConstructorTypeOrParenthesized(
  parser: ParserState,
  context: Context,
  isMappedType: 0 | 1,
  typeAlias: TypeAliasState,
  astType: 'ParenthesizedType' | 'FunctionType' | 'ConstructorType'
): ESTree.ParenthesizedType | ESTree.FunctionType | any {
  nextToken(parser, context); // skips: '('

  let isGroupedType: 0 | 1 = 0;
  let hasParams: 0 | 1 = 0;
  let type: any = null;

  if (parser.token !== Token.RightParen && parser.token !== Token.Ellipsis) {
    hasParams = 1;

    if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
      if (isMappedType || (parser.token === Token.TypeOfKeyword || parser.token === Token.InferKeyword)) {
        type = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
        isGroupedType = 1;
      } else {
        const { tokenValue } = parser;

        nextToken(parser, context);

        if (parser.token === Token.QuestionMark || parser.token === Token.Colon) {
          type = parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 1);
        } else {
          if (consumeOpt(parser, context, Token.RightParen)) {
            if (consumeOpt(parser, context, Token.Arrow)) {
              return finishNode({
                type: astType,
                params: [parseIdentifierFromValue(parser, context, tokenValue, /* allowAnnotations */ 0)],
                returnType: parseTypeAnnotationNoConsume(parser, context, /* restrictedTypes */ 0),
                typeParameters: null
              } as any);
            }

            return finishNode({
              type: 'ParenthesizedType',
              typeAnnotation: {
                type: primaryTypes[tokenValue]
              }
            } as any);
          } else {
            type = parseTypeFromValue(parser, context, tokenValue);
            type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
            isGroupedType = 1;
          }
        }
      }
    } else {
      hasParams = 1;
      if ((parser.token & Token.IsPatternStart) === Token.IsPatternStart) {
        type =
          parser.token === Token.LeftBracket
            ? parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 1, /* isPattern */ 1, [])
            : parseObjectTypeMembers(parser, context, typeAlias | TypeAliasState.Pattern);
        type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
        reinterpretToPattern(parser, type); // TODO ???
      } else {
        type = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);
      }

      if (consumeOpt(parser, context, Token.RightParen)) {
        if ((context & Context.Speculative) === 0 && consumeOpt(parser, context, Token.Arrow)) {
          const returnType = parseTypeAnnotationNoConsume(parser, context, /* restrictedTypes */ 0);

          return finishNode({
            type: astType,
            params: [type],
            returnType,
            typeParameters: null
          } as any);
        }
        reinterpretToTypeLiteral(type);

        return finishNode({
          type: 'ParenthesizedType',
          typeAnnotation: type
        });
      }
    }
  }

  if (isGroupedType) {
    if (context & Context.Speculative && parser.token !== Token.RightParen) return undefined;
    consume(parser, context, Token.RightParen);
    // If we see a => next then someone was probably confused about
    // function types, so we can provide a better error message
    if (parser.token === Token.Arrow) {
      report(parser, context, Errors.Unexpected, /* early */ 0);
    }
    return finishNode({
      type: 'ParenthesizedType',
      typeAnnotation: type
    });
  }

  const params: any[] = parser.token === Token.Ellipsis ? [parseRestElement(parser, context)] : [];

  if (hasParams) params.push(type);
  if (consumeOpt(parser, context, Token.Comma)) {
    while (parser.token !== Token.RightParen) {
      params.push(parseFunctionTypeParam(parser, context));
      if (parser.token !== Token.RightParen) {
        consume(parser, context, Token.Comma);
      }
    }
  }

  if (context & Context.Speculative && parser.token !== Token.RightParen) return undefined;
  consume(parser, context, Token.RightParen);
  if (context & Context.Speculative && parser.token !== Token.Arrow) return undefined;
  consume(parser, context, Token.Arrow);

  const returnType = parseTypeOrTypePredicate(parser, context, /* restrictedTypes */ 0);

  return finishNode({
    type: astType,
    params,
    returnType,
    typeParameters: null
  } as any);
}

export function parseIdentifierFromValue(parser: ParserState, context: Context, name: string, allowAnnotations: 0 | 1) {
  const optional = allowAnnotations ? consumeOpt(parser, context, Token.QuestionMark) : false;
  const typeAnnotation =
    allowAnnotations && parser.token === Token.Colon
      ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0)
      : [];

  return finishNode({
    type: 'Identifier',
    name,
    optional,
    typeAnnotation
  });
}

export function parseRestElement(parser: ParserState, context: Context): any {
  consume(parser, context | Context.AllowRegExp, Token.Ellipsis);
  const argument = parseExpression(parser, context);
  const optional = consumeOpt(parser, context, Token.QuestionMark);
  const typeAnnotation =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];

  return finishNode({
    type: 'RestElement',
    argument,
    typeAnnotation,
    optional,
    decorators: []
  });
}

export function parseQualifiedName(parser: ParserState, context: Context, entity: any): ESTree.QualifiedName {
  while (consumeOpt(parser, context, Token.Period)) {
    entity = finishNode({
      type: 'QualifiedName',
      left: entity,
      right: parseIdentifier(parser, context)
    });
  }
  return entity;
}

export function parseTypeReferenceFromExpression(
  parser: ParserState,
  context: Context,
  expr: any
): ESTree.TypeReference {
  let typeParameters: any = null;
  const typeName = parseQualifiedName(parser, context, expr);
  if (!parser.precedingLineBreak && parser.token === Token.LessThan) {
    typeParameters = parseTypeParameterInstantiation(parser, context);
  }
  return finishNode({
    type: 'TypeReference',
    typeName,
    typeParameters
  });
}

export function parseTupleType(parser: ParserState, context: Context): ESTree.TupleType {
  const types: (ESTree.OptionalType | ESTree.RestType)[] = [];
  consume(parser, context, Token.LeftBracket);

  let prevIsOptional: 0 | 1 = 0;
  let seenRest: 0 | 1 = 0;

  while (parser.token !== Token.RightBracket) {
    let element: ESTree.RestType | ESTree.OptionalType;

    if (parser.token === Token.Ellipsis) {
      seenRest = 1;
      nextToken(parser, context);
      element = finishNode({
        type: 'RestType',
        typeAnnotation: parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None)
      });
    } else {
      element = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None);

      if (parser.token === Token.QuestionMark) {
        nextToken(parser, context);
        prevIsOptional = 1;
        element = finishNode({
          type: 'OptionalType',
          typeAnnotation: element
        });
      } else {
        if (prevIsOptional) report(parser, context, Errors.ReqElemFollowOptElem, 0);
        if (seenRest) report(parser, context, Errors.NotLastElemInTuple, 0);
      }
    }

    types.push(element);

    if (parser.token === Token.RightBracket) {
      break;
    }
    consume(parser, context, Token.Comma);
  }
  consume(parser, context, Token.RightBracket);
  return finishNode({
    type: 'TupleType',
    elementTypes: types
  });
}

export function parseFunctionTypeParams(
  parser: ParserState,
  context: Context
): (ESTree.ObjectPattern | ESTree.ArrayPattern | ESTree.Identifier)[] {
  const params: (ESTree.ObjectPattern | ESTree.ArrayPattern | ESTree.Identifier)[] = [];

  while (parser.token !== Token.RightParen) {
    params.push(parseFunctionTypeParam(parser, context));
    if (parser.token !== Token.RightParen) {
      consume(parser, context, Token.Comma);
    }
  }

  return params;
}

export function parseFunctionTypeParam(
  parser: ParserState,
  context: Context
): ESTree.ObjectPattern | ESTree.ArrayPattern | ESTree.Identifier {
  if (parser.token === Token.Ellipsis) return parseRestElement(parser, context);
  if ((parser.token & Token.IsPatternStart) === Token.IsPatternStart) {
    const name =
      parser.token === Token.LeftBrace
        ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 1, [])
        : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 1, []);

    reinterpretToPattern(parser, name);
    return name;
  }
  return parseBindingIdentifier(parser, context, 0, 1);
}

export function parseObjectTypeMembers(parser: ParserState, context: Context, typeAlias: TypeAliasState): any {
  let optional = false;
  let key;
  let isReadOnly: boolean | '-' | '+' = false;
  let isStatic = false;
  let isUnambiguouslyIndexSignature: 0 | 1 = 0;

  const members: any[] = [];

  consume(parser, context, Token.LeftBrace);

  while (parser.token !== Token.RightBrace) {
    const { token } = parser;

    if (token === Token.Subtract || token === Token.Add) {
      nextToken(parser, context);
      if (parser.token !== Token.ReadOnlyKeyword) {
        report(parser, context, Errors.UnexpectedPropertyOrSignature, 0);
      }
      nextToken(parser, context);
      isReadOnly = KeywordDescTable[token & Token.Type] as '+' | '-';
    } else if (token === Token.ReadOnlyKeyword) {
      nextToken(parser, context);
      isReadOnly = true;
    }

    isStatic = consumeOpt(parser, context, Token.StaticKeyword);

    if (parser.token === Token.LeftBracket) {
      nextToken(parser, context);

      if (parser.token === Token.RightBracket)
        report(parser, context, Errors.InvalidIndexSignatureOptional, /* early */ 0);

      let hasTypeAnnotation: 0 | 1 = 0;

      if (parser.token & Token.IsModifier) {
        report(
          parser,
          context,
          parser.token === Token.AbstractKeyword ? Errors.InvalidAbstractModifier : Errors.ParamPropertyNoConstructor,
          /* early */ 0
        );
      }

      let id: any;

      if ((parser.token & (Token.Keywords | Token.IsIdentifier)) > 0) {
        const { tokenValue } = parser;

        nextToken(parser, context);
        if (parser.token === Token.QuestionMark) {
          report(parser, context, Errors.InvalidIndexSignatureOptional, /* early */ 0);
        }
        if (parser.token === Token.Negate) {
          report(parser, context, Errors.InvalidComputedInterface, /* early */ 0);
        }

        if (parser.token === Token.InKeyword) {
          const mapped = parseMappedType(parser, context, tokenValue, isReadOnly as any);
          consume(parser, context, Token.RightBrace);
          return mapped;
        }

        const optional = consumeOpt(parser, context, Token.QuestionMark);

        if (parser.token === Token.Colon) {
          if (isStatic)
            report(parser, context, Errors.InvalidStaticOnIdxSignature, /* early */ 0, 'an index signature');
          isUnambiguouslyIndexSignature = 1;
          hasTypeAnnotation = 1;
          let typeAnnotation: any = [];

          if (consumeOpt(parser, context, Token.Colon)) {
            if (parser.token & Token.IsPatternStart || parser.token === Token.LeftParen) {
              report(parser, context, Errors.InvalidIndexSignatureParam, /* early */ 0);
            }
            typeAnnotation = parseTypeAnnotationNoConsume(parser, context, /* restrictedTypes */ 1);
          }

          id = finishNode({
            type: 'Identifier',
            name: tokenValue,
            optional,
            typeAnnotation
          });
        } else {
          if (parser.token === Token.Comma) report(parser, context, Errors.IndexSignatureOneParam, /* early */ 0);

          id = parseIdentifierFromValue(parser, context, tokenValue, /*allowAnnotations */ 0) as ESTree.Identifier;

          if (parser.token !== Token.RightBracket) {
            id = parseMemberOrUpdateExpression(parser, context, id);

            id = parseAssignmentExpression(parser, context, id);
          }
        }

        id = parseMemberOrUpdateExpression(parser, context, id);
      }

      consume(parser, context, Token.RightBracket);

      if (hasTypeAnnotation && parser.token !== Token.Colon)
        report(parser, context, Errors.InvalidIndexSignatureAnnotation, /* early */ 0);
      if (!isUnambiguouslyIndexSignature) {
        optional = consumeOpt(parser, context, Token.QuestionMark);
        members.push(
          parser.token === Token.LessThan || parser.token === Token.LeftParen
            ? parseObjectTypeMembersMethod(parser, context, isReadOnly, optional, id)
            : parsePropertySignature(parser, context, optional, isReadOnly, id)
        );
      } else {
        consume(parser, context, Token.Colon);

        const typeAnnotation = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, typeAlias);

        members.push(
          finishNode({
            type: 'IndexSignature',
            parameters: [id],
            typeAnnotation,
            readonly: false,
            accessibility: null,
            export: false,
            static: false
          })
        );
      }
    } else if (parser.token === Token.LeftParen || parser.token === Token.LessThan) {
      members.push(parseCallSignatureDeclaration(parser, context));
      typeAlias = (typeAlias | TypeAliasState.Pattern) ^ TypeAliasState.Pattern;
    } else if (parser.token === Token.NewKeyword) {
      members.push(parseConstructSignatureDeclaration(parser, context));
      typeAlias = (typeAlias | TypeAliasState.Pattern) ^ TypeAliasState.Pattern;
    }
    // Object pattern parsing
    else if (typeAlias & TypeAliasState.Pattern) {
      if (parser.token === Token.Ellipsis) {
        members.push(parseSpreadOrRestElement(parser, context, Token.RightBrace, /* allowTypeAnnotation */ 0, []));
      } else {
        let value: any;
        let isShortHand = false;

        key = parseObjectPropertyKey(parser, context);

        const { token } = parser;

        if (token === Token.Comma || token === Token.RightBrace || token === Token.Assign) {
          isShortHand = true;

          if (consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)) {
            const right = parseExpression(parser, context);

            value = finishNode({
              type: 'AssignmentPattern',
              left: key,
              right
            } as any);
          } else {
            value = key;
          }
        } else if (token === Token.Colon) {
          nextToken(parser, context);

          if (parser.token & (Token.Keywords | Token.IsIdentifier | Token.FutureReserved)) {
            value = parsePrimaryExpression(parser, context, /* isLHS */ 1, /* inParen */ 0);

            const { token } = parser;

            value = parseMemberOrUpdateExpression(parser, context, value);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              if (token === Token.Assign || token === Token.RightBrace || token === Token.Comma) {
                // TODO
              } else {
                // TODO
              }
            } else if (parser.token === Token.Assign) {
              value = parseAssignmentExpression(parser, context, value);
            } else {
              value = parseAssignmentExpression(parser, context, value);
            }
          } else if ((parser.token & Token.IsPatternStart) === Token.IsPatternStart) {
            value =
              parser.token === Token.LeftBrace
                ? parseObjectLiteralOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 1, [])
                : parseArrayExpressionOrPattern(parser, context, /* skipInitializer */ 0, /* isPattern */ 1, []);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              const { token } = parser;

              if (token !== Token.Comma && token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              } else if (token !== Token.Assign) {
                // TODO
              }
            }
          } else {
            value = parseLeftHandSideExpression(parser, context, /* isLHS */ 1);

            if (parser.token === Token.Comma || parser.token === Token.RightBrace) {
              // TODO
            } else {
              value = parseMemberOrUpdateExpression(parser, context, value);

              const { token } = parser;

              if (token !== Token.Comma && token !== Token.RightBrace) {
                value = parseAssignmentExpression(parser, context, value);
              }
            }
          }
        }
        members.push(
          finishNode({
            type: 'Property',
            key,
            value,
            kind: 'init',
            computed: false,
            method: false,
            shorthand: isShortHand
          } as any)
        );
      }
    } else {
      key = parseObjectPropertyKey(parser, context);

      optional = consumeOpt(parser, context, Token.QuestionMark);

      if (parser.token === Token.LessThan || parser.token === Token.LeftParen) {
        members.push(parseObjectTypeMembersMethod(parser, context, isReadOnly, optional, key));
      } else {
        if (typeAlias & TypeAliasState.TypeMember && parser.token === Token.Assign) {
          report(parser, context, Errors.ExpressionExpected, /* early */ 0);
        }
        members.push(parsePropertySignature(parser, context, optional, isReadOnly as any, key));
      }
    }

    // Typescript allow type members to be separated by commas or (possibly ASI) semicolons.
    // First check if it was a comma.  If so, we're done with the member.
    if (!consumeOpt(parser, context, Token.Comma)) {
      // Didn't have a comma.  We must have a (possible ASI) semicolon.
      consumeSemicolon(parser, context);
    }
  }

  consume(parser, context, Token.RightBrace);

  if (typeAlias & TypeAliasState.Pattern) {
    const optional = consumeOpt(parser, context, Token.QuestionMark);
    const typeAnnotation =
      parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];

    return finishNode({
      type: 'ObjectExpression',
      properties: members,
      typeAnnotation,
      optional,
      decorators: []
    });
  }

  return finishNode({
    type: 'TypeLiteral',
    members
  });
}

export function parseMappedType(
  parser: ParserState,
  context: Context,
  name: string,
  readonly: boolean | '-' | '+'
): ESTree.MappedType {
  const typeParameter: any = parseMappedTypeParameter(parser, context, name);

  consume(parser, context, Token.RightBracket);

  let optional: boolean | '-' | '+' = consumeOpt(parser, context, Token.QuestionMark);

  if (!optional) {
    if (parser.token === Token.Add || parser.token === Token.Subtract) {
      optional = KeywordDescTable[parser.token & Token.Type] as '+' | '-';
      nextToken(parser, context);
      consumeOpt(parser, context, Token.QuestionMark);
    }
  }

  const typeAnnotation = consumeOpt(parser, context, Token.Colon)
    ? parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None)
    : [];

  consumeSemicolon(parser, context);

  return finishNode({
    type: 'MappedType',
    typeAnnotation,
    typeParameter,
    readonly,
    optional
  });
}

export function parseMappedTypeParameter(parser: ParserState, context: Context, value: string): ESTree.TypeParameter {
  const name = parseIdentifierFromValue(parser, context, value, /* allowAnnotations */ 0) as ESTree.Identifier;

  consume(parser, context, Token.InKeyword);

  const constraint = parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 1, TypeAliasState.None);

  return finishNode({
    type: 'TypeParameter',
    name,
    constraint,
    default: null
  });
}

export function parseObjectTypeMembersMethod(
  parser: ParserState,
  context: Context,
  isStatic: any,
  optional: boolean,
  key: ESTree.Identifier | ESTree.Literal
): ESTree.MethodSignature {
  const params = [];
  let typeParameters: any = null;
  if (parser.token === Token.LessThan) {
    typeParameters = parseTypeParameters(parser, context);
  }
  consume(parser, context, Token.LeftParen);

  while (parser.token !== Token.RightParen) {
    params.push(parseFunctionTypeParam(parser, context));
    if (parser.token !== Token.RightParen) {
      consume(parser, context, Token.Comma);
    }
  }

  consume(parser, context, Token.RightParen);

  const returnType =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : null;
  consumeOpt(parser, context, Token.Semicolon);
  return finishNode({
    type: 'MethodSignature',
    key,
    optional,
    static: isStatic,
    computed: false,
    params,
    returnType,
    readonly: false,
    typeParameters,
    accessibility: null as any,
    export: false
  });
}

export function parsePropertySignature(
  parser: ParserState,
  context: Context,
  optional: boolean,
  isReadOnly: boolean | '+' | '-',
  key: any
): ESTree.PropertySignature {
  const typeAnnotation =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];
  consumeOpt(parser, context, Token.Semicolon);

  const initializer = consumeOpt(parser, context | Context.AllowRegExp, Token.Assign)
    ? parseExpression(parser, context)
    : null;

  return finishNode({
    type: 'PropertySignature',
    key,
    optional,
    computed: false,
    readonly: isReadOnly as boolean,
    typeAnnotation,
    initializer,
    static: false,
    export: false,
    accessibility: null as ESTree.Accessibility | any
  });
}

export function parseCallSignatureDeclaration(parser: ParserState, context: Context): ESTree.CallSignatureDeclaration {
  const params = [];
  const typeParameters: any = parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;
  consume(parser, context, Token.LeftParen);

  while (parser.token !== Token.RightParen) {
    params.push(parseFunctionTypeParam(parser, context));

    if (parser.token !== Token.RightParen) {
      consume(parser, context, Token.Comma);
    }
  }

  consume(parser, context, Token.RightParen);

  consumeOpt(parser, context, Token.Semicolon);

  const returnType =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : null;
  consumeOpt(parser, context, Token.Semicolon);
  return finishNode({
    type: 'CallSignatureDeclaration',
    params,
    returnType,
    typeParameters
  });
}

export function parseConstructSignatureDeclaration(
  parser: ParserState,
  context: Context
): ESTree.ConstructSignatureDeclaration {
  nextToken(parser, context);
  const params = [];
  const typeParameters: any = parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;
  consume(parser, context, Token.LeftParen);

  while (parser.token !== Token.RightParen) {
    params.push(parseFunctionTypeParam(parser, context));

    if (parser.token !== Token.RightParen) {
      consume(parser, context, Token.Comma);
    }
  }

  consume(parser, context, Token.RightParen);

  consumeOpt(parser, context, Token.Semicolon);

  const returnType =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : null;

  return finishNode({
    type: 'ConstructSignatureDeclaration',
    params,
    returnType,
    typeParameters
  });
}

export function parseObjectPropertyKey(parser: ParserState, context: Context): ESTree.Identifier | ESTree.Literal {
  const { token, tokenValue } = parser;
  nextToken(parser, context);
  if ((token & (Token.IsIdentifier | Token.Keywords | Token.FutureReserved | Token.IsStringOrNumber)) === 0)
    report(parser, context, Errors.UnexpectedPropertyOrSignature, /* early */ 0);

  return (token & Token.IsStringOrNumber) === Token.IsStringOrNumber
    ? finishNode({
        type: 'Literal',
        value: tokenValue
      })
    : (parseIdentifierFromValue(parser, context, tokenValue, /*allowAnnotations */ 0) as ESTree.Identifier);
}

export function parseClassDeclarationOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  abstract: 0 | 1,
  declare: 0 | 1
): ESTree.Identifier | ESTree.ClassDeclaration {
  if (parser.token === Token.At) report(parser, context, Errors.DecoratorESNext, /* early */ 0);
  const expr = parseIdentifier(parser, context);
  if (parser.token !== Token.ClassKeyword) return parseExpressionOrLabelledStatement(parser, context, expr, token, 1);
  return parseTypescriptClassDeclaration(parser, context, ClassAndFunctionFlags.None, declare, abstract);
}

export function parseTypeAliasOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  declare: 0 | 1
): ESTree.TypeAliasDeclaration | ESTree.Identifier {
  const expr = parseIdentifier(parser, context);
  if (parser.precedingLineBreak || (parser.token & Token.IsIdentifier) === 0) {
    return parseExpressionOrLabelledStatement(parser, context, expr, token, 1);
  }

  return parseTypeAlias(parser, context, declare);
}

export function parseTypeAlias(parser: ParserState, context: Context, declare: 0 | 1): ESTree.TypeAliasDeclaration {
  const id = parseIdentifier(parser, context);
  const typeParameters: any = parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;
  consume(parser, context, Token.Assign);

  const typeAnnotation = parseType(
    parser,
    context,
    /* restrictedTypes */ 0,
    /* isMappedType */ 0,
    TypeAliasState.TypeMember
  );

  consumeSemicolon(parser, context);
  return finishNode({
    type: 'TypeAliasDeclaration',
    id,
    typeAnnotation,
    declare: declare === 1,
    typeParameters
  });
}

export function parseInterfaceOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  declare: 0 | 1
): ESTree.Identifier | ESTree.InterfaceDeclaration {
  const expr = parseIdentifier(parser, context);
  if (parser.precedingLineBreak || (parser.token & Token.IsIdentifier) === 0) {
    if (context & Context.Strict) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseExpressionOrLabelledStatement(parser, context, expr, token, 1);
  }
  return parseInterfaceDeclaration(parser, context, declare);
}

export function parseInterfaceDeclaration(
  parser: ParserState,
  context: Context,
  declare: 0 | 1
): ESTree.InterfaceDeclaration {
  const id = parseIdentifier(parser, context);
  const typeParameters: any = parser.token === Token.LessThan ? parseTypeParameters(parser, context) : null;
  const heritage: ESTree.InterfaceHeritage[] = [];

  if (consumeOpt(parser, context, Token.ExtendsKeyword)) {
    while (parser.token !== Token.EndOfSource) {
      heritage.push(parseHeritageClausesOrClassImplements(
        parser,
        context,
        'InterfaceHeritage'
      ) as ESTree.InterfaceHeritage);
      if (parser.token !== Token.Comma) {
        break;
      }
      consume(parser, context, Token.Comma);
    }
  }

  const body: ESTree.InterfaceBody = parseInterfaceBody(parser, context);

  return finishNode({
    type: 'InterfaceDeclaration',
    body,
    id,
    typeParameters,
    extends: heritage,
    implements: [],
    decorators: [],
    abstract: false,
    declare: declare === 1
  });
}

export function parseIndexSignature(parser: ParserState, context: Context, isStatic: boolean, readonly: boolean): any {
  let hasTypeAnnotation: 0 | 1 = 0;
  let isUnambiguouslyIndexSignature: 0 | 1 = 0;

  const parameters: any[] = [];

  nextToken(parser, context); // skips: '['

  if ((parser.token & Token.IsModifier) === Token.IsModifier) {
    report(parser, context, Errors.InvalidIndexSignatureModifier, /* early */ 0, 'Accessibility');
  }

  let left: any;

  while (parser.token !== Token.RightBracket) {
    if ((parser.token & Token.IsIdentifier) === Token.IsIdentifier) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      if (parser.token === Token.QuestionMark) {
        report(parser, context, Errors.InvalidIndexSignatureOptional, /* early */ 0);
      }

      if (parser.token === Token.Negate) {
        report(parser, context, Errors.InvalidComputedInterface, /* early */ 0);
      }
      if (parser.token === Token.Colon) {
        if (isStatic) report(parser, context, Errors.InvalidStaticOnIdxSignature, /* early */ 0, 'an index signature');
        isUnambiguouslyIndexSignature = 1;
        hasTypeAnnotation = 1;
        let typeAnnotation: ESTree.TypeAssertion[] = [];

        if (consumeOpt(parser, context, Token.Colon)) {
          if (parser.token & Token.IsPatternStart || parser.token === Token.LeftParen) {
            report(parser, context, Errors.InvalidIndexSignatureParam, /* early */ 0);
          }
          typeAnnotation = parseTypeAnnotationNoConsume(parser, context, /* restrictedTypes */ 1);
        }

        left = finishNode({
          type: 'Identifier',
          name: tokenValue,
          optional: false,
          typeAnnotation
        } as any);
      } else {
        if (isStatic) report(parser, context, Errors.InvalidStaticOnIdxSignature, /* early */ 0, 'a type member');

        if (parser.token === Token.InKeyword) report(parser, context, Errors.InvalidComputedInterface, /* early */ 0);

        if (parser.token === Token.Comma) {
          report(parser, context, Errors.IndexSignatureOneParam, /* early */ 0);
        }

        left = parseIdentifierFromValue(parser, context, tokenValue, /*allowAnnotations */ 0) as ESTree.Identifier;

        left = parseMemberOrUpdateExpression(parser, context, left);

        left = parseAssignmentExpression(parser, context, left);
      }
    } else {
      if (parser.token === Token.Negate) {
        report(parser, context, Errors.InvalidComputedInterface, /* early */ 0);
      }

      left = parseExpression(parser, context);
    }
    parameters.push(left);
    if (parser.token !== Token.RightBracket) {
      consume(parser, context, Token.Comma);
    }
  }

  consume(parser, context, Token.RightBracket);

  if (parser.token === Token.LessThan || parser.token === Token.LeftParen) {
    return parseObjectTypeMembersMethod(parser, context, isStatic, true, parameters[0]);
  }
  if (hasTypeAnnotation && parser.token !== Token.Colon)
    report(parser, context, Errors.InvalidIndexSignatureAnnotation, /* early */ 0);
  const optional = consumeOpt(parser, context, Token.QuestionMark);

  const typeAnnotation =
    parser.token === Token.Colon ? parseTypeAnnotation(parser, context, /* restrictedTypes */ 0) : [];

  return isUnambiguouslyIndexSignature
    ? finishNode({
        type: 'IndexSignature',
        parameters: parameters,
        typeAnnotation,
        readonly: false,
        accessibility: null,
        export: false,
        static: false
      })
    : finishNode({
        type: 'PropertySignature',
        key: parameters[0],
        optional,
        computed: true,
        readonly,
        typeAnnotation,
        initializer: null,
        static: false,
        export: false,
        accessibility: null
      } as any);
}

export function parseInterfaceBody(parser: ParserState, context: Context): ESTree.InterfaceBody {
  consume(parser, context, Token.LeftBrace);
  const body: (ESTree.TypeElement | ESTree.IndexSignature)[] = [];

  while (parser.token !== Token.RightBrace) {
    let isReadOnlyAsIdent: 0 | 1 = 0;
    let key: any = null;
    if (parser.token === Token.ReadOnlyKeyword) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      if (parser.token === Token.QuestionMark || parser.token === Token.Colon) {
        key = parseIdentifierFromValue(parser, context, tokenValue, 0);
        isReadOnlyAsIdent = 1;
      }
    }

    const isReadOnly = consumeOpt(parser, context, Token.ReadOnlyKeyword);
    const isStatic = consumeOpt(parser, context, Token.StaticKeyword) && parser.token !== Token.LeftParen;

    if (parser.token === Token.LeftBracket) {
      body.push(parseIndexSignature(parser, context, isStatic, isReadOnly));
    } else {
      if (isStatic) report(parser, context, Errors.InvalidStaticOnIdxSignature, /* early */ 0, 'a type member');
      if (parser.token === Token.LeftParen || parser.token === Token.LessThan) {
        body.push(parseCallSignatureDeclaration(parser, context));
      } else if (parser.token === Token.NewKeyword) {
        body.push(parseConstructSignatureDeclaration(parser, context));
      } else {
        if (!isReadOnlyAsIdent) key = parseObjectPropertyKey(parser, context);

        const isOptional = consumeOpt(parser, context, Token.QuestionMark);
        if (parser.token === Token.LessThan || parser.token === Token.LeftParen) {
          body.push(parseObjectTypeMembersMethod(
            parser,
            context,
            isReadOnly,
            isOptional,
            key
          ) as ESTree.MethodSignature);
        } else {
          body.push(parsePropertySignature(parser, context, isOptional, isReadOnly, key));
        }
      }

      if (parser.token !== Token.RightBrace) consumeOpt(parser, context, Token.Comma);
    }
  }

  if (parser.token !== Token.RightBrace) report(parser, context, Errors.Unexpected, /* early */ 0);

  consume(parser, context, Token.RightBrace);

  return finishNode({
    type: 'InterfaceBody',
    body
  });
}

export function parseHeritageClausesOrClassImplements(
  parser: ParserState,
  context: Context,
  type: 'InterfaceHeritage' | 'ClassImplements'
): ESTree.InterfaceHeritage | ESTree.ClassImplements {
  const expression: any = parseEntityName(parser, context);
  const typeParameters: any = parser.token === Token.LessThan ? parseTypeParameterInstantiation(parser, context) : null;

  return finishNode({
    type,
    expression,
    typeParameters
  });
}

export function parseConstEnumOrVariableStatement(
  parser: ParserState,
  context: Context,
  declare: 0 | 1
): ESTree.VariableDeclaration | ESTree.EnumDeclaration {
  nextToken(parser, context);
  if (consumeOpt(parser, context, Token.EnumKeyword)) {
    return parseEnumDeclaration(parser, context, declare, /* isConst */ 1);
  }

  const declarations = parseVariableDeclarationList(
    parser,
    context,
    BindingKind.Const,
    declare ? Origin.Declare : Origin.None
  );

  consumeSemicolon(parser, context);

  return finishNode({
    type: 'VariableDeclaration',
    kind: 'const',
    declare: declare === 1,
    declarations
  } as any);
}
export function parseEnumDeclaration(
  parser: ParserState,
  context: Context,
  declare: 0 | 1,
  isConst: 0 | 1
): ESTree.EnumDeclaration {
  const id = parseIdentifier(parser, context);
  consume(parser, context, Token.LeftBrace);
  const members: ESTree.EnumMember[] = [];
  while (parser.token !== Token.RightBrace) {
    members.push(parseEnumMembers(parser, context));
    if (parser.token === Token.RightBrace) {
      break;
    }
    consume(parser, context, Token.Comma);
  }

  consume(parser, context, Token.RightBrace);

  return finishNode({
    type: 'EnumDeclaration',
    const: isConst === 1,
    declare: declare === 1,
    modifiers: [],
    decorators: [],
    members,
    id
  });
}

export function parseEnumDeclarationOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  declare: 0 | 1,
  isConst: 0 | 1
): ESTree.EnumDeclaration {
  const expr = parseIdentifier(parser, context);
  if (parser.precedingLineBreak || (parser.token & Token.IsIdentifier) === 0) {
    return parseExpressionOrLabelledStatement(parser, context, expr, token, 1);
  }
  const id = parseIdentifier(parser, context);
  consume(parser, context, Token.LeftBrace);
  const members: any[] = [];
  while (parser.token !== Token.RightBrace) {
    members.push(parseEnumMembers(parser, context));
    if (parser.token === Token.RightBrace) {
      break;
    }
    consume(parser, context, Token.Comma);
  }

  consume(parser, context, Token.RightBrace);

  return finishNode({
    type: 'EnumDeclaration',
    const: isConst === 1,
    declare: declare === 1,
    modifiers: [],
    decorators: [],
    members,
    id
  });
}

export function parseEnumMembers(parser: ParserState, context: Context): ESTree.EnumMember {
  let id: ESTree.Identifier | ESTree.Literal | null = null;

  if (parser.token & (Token.Contextual | Token.Keywords | Token.IsIdentifier)) {
    id = parseIdentifier(parser, context);
  } else {
    switch (parser.token) {
      case Token.StringLiteral:
        id = parseLiteral(parser, context);
        break;
      case Token.NumericLiteral:
        report(parser, context, Errors.EnumNumericName, /* early */ 1);
      default:
        report(parser, context, Errors.EnumInvalidMember, /* early */ 1);
    }
  }

  if (parser.token === Token.NumericLiteral || parser.token === Token.BigIntLiteral) {
  }

  const initializer = consumeOpt(parser, context, Token.Assign) ? parseExpression(parser, context) : null;
  return finishNode({
    type: 'EnumMember',
    id: id as ESTree.Identifier | ESTree.Literal,
    initializer
  });
}

export function parseNamespaceOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  declare: 0 | 1
): ESTree.ModuleDeclaration | ESTree.Expression {
  const expr = parseIdentifier(parser, context);
  if (parser.precedingLineBreak || (parser.token & Token.IsIdentifier) === 0) {
    return parseExpressionOrLabelledStatement(parser, context, expr, token, 1);
  }
  return parseModuleDeclaration(parser, context, declare);
}

export function parseModuleDeclaration(parser: ParserState, context: Context, declare: any): any {
  const id = parseIdentifier(parser, context);
  let body: any;
  if (consumeOpt(parser, context, Token.Period)) {
    body = parseModuleDeclaration(parser, context, declare);
  } else {
    body = parseModuleBlock(parser, context);
  }
  consumeSemicolon(parser, context);
  return finishNode({
    type: 'ModuleDeclaration',
    id,
    body,
    global: false,
    declare: declare === 1,
    modifiers: []
  });
}

export function parseStatementListBlock(parser: ParserState, context: Context): ESTree.ModuleBlock {
  consume(parser, context, Token.LeftBrace);
  const body: ESTree.DeclarationStatement[] = [];
  while (parser.token !== Token.RightBrace) {
    body.push(parseDeclarationList(parser, context, /* isModule */ 1, /*declare */ 0, /* isExport */ false));
  }
  consume(parser, context, Token.RightBrace);
  return finishNode({
    type: 'ModuleBlock',
    body
  });
}

export function parseModuleBlock(parser: ParserState, context: Context): ESTree.ModuleBlock {
  const body: ESTree.DeclarationStatement[] = [];
  consume(parser, context | Context.AllowRegExp, Token.LeftBrace);

  while (parser.token & Token.IsStatementStart) {
    body.push(parseDeclarationList(parser, context, /* isModule */ 1, /*declare */ 0, /* isExport */ false));
  }

  consume(parser, context, Token.RightBrace);

  return finishNode({
    type: 'ModuleBlock',
    body
  });
}

export function parseGlobalModuleDeclarationOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  declare: 0 | 1
): any {
  const id = parseIdentifier(parser, context);
  if (parser.precedingLineBreak || parser.token !== Token.LeftBrace) {
    if (context & Context.Strict) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseExpressionOrLabelledStatement(parser, context, id, token, 1);
  }

  const body = parser.token === Token.LeftBrace ? parseModuleBlock(parser, context) : null;

  if (!body) consumeSemicolon(parser, context);

  return finishNode({
    type: 'ModuleDeclaration',
    id,
    body,
    global: true,
    declare: declare === 1,
    modifiers: []
  } as any);
}

export function parseModuleDeclarationOrIdentifier(
  parser: ParserState,
  context: Context,
  token: Token,
  declare: 0 | 1
): any {
  const { tokenValue } = parser;
  nextToken(parser, context); // Skip: 'module'
  let body: any = null;
  let id: any;
  if (
    parser.precedingLineBreak ||
    (parser.token !== Token.StringLiteral && (parser.token & Token.IsIdentifier) === 0)
  ) {
    if (context & Context.Strict) report(parser, context, Errors.Unexpected, /* early */ 1);
    return parseExpressionOrLabelledStatement(
      parser,
      context,
      parseIdentifierFromValue(parser, context, tokenValue, 0),
      token,
      1
    );
  }
  if (parser.token === Token.StringLiteral) {
    id = parseLiteral(parser, context);
    if (parser.token === Token.LeftBrace) {
      body = parseModuleBlock(parser, context) as any;
    } else {
      consumeSemicolon(parser, context);
    }
    return finishNode({
      type: 'ModuleDeclaration',
      id,
      body: body,
      global: false,
      declare: declare === 1,
      modifiers: []
    });
  }
  return parseModuleDeclaration(parser, context, declare);
}

export function parseTypeParameterInstantiation(parser: ParserState, context: Context): any {
  const params: any[] = [];
  consume(parser, context, Token.LessThan);
  return parseTypeParameterInstantiationOrHigher(parser, context, params);
}

export function parseTypeParameterInstantiationOrHigher(parser: ParserState, context: Context, params: any[]): any {
  while (parser.token !== Token.GreaterThan) {
    params.push(parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None));

    if (parser.token !== Token.GreaterThan) {
      if (parser.token !== Token.Comma && context & Context.Speculative) return undefined;
      consume(parser, context, Token.Comma);
    }
  }

  consume(parser, context, Token.GreaterThan);
  return finishNode({
    type: 'TypeParameterInstantiation',
    params
  });
}

export function parseJSXFragment(parser: ParserState, context: Context, inJSXChild: 0 | 1): any {
  return finishNode({
    type: 'JSXFragment',
    openingFragment: parseJSXOpeningFragment(parser),
    children: parseJSXChildren(parser, context),
    closingFragment: parseJSXClosingFragment(parser, context, inJSXChild)
  });
}

export function parseJSXOpeningElement(
  context: Context,
  name: string,
  attributes: (ESTree.JSXAttribute | ESTree.JSXSpreadAttribute)[],
  selfClosing: any,
  typeParameters: any
): ESTree.JSXOpeningElement {
  return context & Context.OptionsTS
    ? finishNode({
        type: 'JSXOpeningElement',
        name,
        attributes,
        selfClosing,
        typeParameters
      } as any)
    : finishNode({
        type: 'JSXOpeningElement',
        name,
        attributes,
        selfClosing
      } as any);
}

export function parseJSXRootElementOrFragment(
  parser: ParserState,
  context: Context,
  inJSXChild: 0 | 1
): ESTree.JSXElement | ESTree.JSXFragment {
  nextToken(parser, context); // skips: ''

  if (parser.token === Token.GreaterThan) return parseJSXFragment(parser, context, inJSXChild);

  let closingElement: ESTree.JSXClosingElement | null = null;

  let children: ESTree.JSXChild[] = [];

  const tagName = parseJSXElementName(parser, context);

  const typeParameters =
    context & Context.OptionsJSX && parser.token === Token.LessThan
      ? parseTypeParameterInstantiation(parser, context)
      : null;

  const attributes: (ESTree.JSXAttribute | ESTree.JSXSpreadAttribute)[] = parseJSXAttributes(parser, context);

  const selfClosing = parser.token === Token.Divide;

  if (parser.token === Token.GreaterThan) {
    scanJSXToken(parser);
  } else {
    consume(parser, context, Token.Divide);
    if (inJSXChild) {
      consume(parser, context, Token.GreaterThan);
    } else {
      scanJSXToken(parser);
    }
  }

  const openingElement = parseJSXOpeningElement(context, tagName, attributes, selfClosing, typeParameters);

  if (!selfClosing) {
    children = parseJSXChildren(parser, context);

    closingElement = parseJSXClosingElement(parser, context, inJSXChild);

    const close = isEqualTagName(closingElement.name);

    if (isEqualTagName(openingElement.name) !== close) {
      report(parser, context, Errors.ExpectedJSXClosingTag, /* early */ 0, close);
    }
  }

  return finishNode({
    type: 'JSXElement',
    children,
    openingElement,
    closingElement
  });
}

export function parseJSXClosingElement(
  parser: ParserState,
  context: Context,
  inJSXChild: 0 | 1
): ESTree.JSXClosingElement {
  consume(parser, context, Token.JSXClose);
  const name = parseJSXElementName(parser, context);
  if (inJSXChild) {
    consume(parser, context, Token.GreaterThan);
  } else {
    parser.token = scanJSXToken(parser);
  }

  return finishNode({
    type: 'JSXClosingElement',
    name
  });
}

export function parseJSXAttributes(
  parser: ParserState,
  context: Context
): (ESTree.JSXAttribute | ESTree.JSXSpreadAttribute)[] {
  const attributes: (ESTree.JSXAttribute | ESTree.JSXSpreadAttribute)[] = [];
  while (parser.token !== Token.Divide && parser.token !== Token.GreaterThan) {
    attributes.push(parseJsxAttribute(parser, context));
  }
  return attributes;
}

export function parseJSXElementName(parser: ParserState, context: Context): any {
  scanJSXIdentifier(parser);

  let key: ESTree.JSXIdentifier | ESTree.JSXMemberExpression = parseJSXIdentifier(parser, context);

  // Namespace
  if (parser.token === Token.Colon) return parseJSXNamespacedName(parser, context, key);

  // Member expression
  while (consumeOpt(parser, context, Token.Period)) {
    scanJSXIdentifier(parser);
    key = parseJSXMemberExpression(parser, context, key);
  }
  return key;
}

export function parseJSXMemberExpression(
  parser: ParserState,
  context: Context,
  object: ESTree.JSXIdentifier | ESTree.JSXMemberExpression
): ESTree.JSXMemberExpression {
  const property = parseJSXIdentifier(parser, context);
  return finishNode({
    type: 'JSXMemberExpression',
    object,
    property
  });
}

export function parseJSXOpeningFragment(parser: ParserState): ESTree.JSXOpeningFragment {
  scanJSXToken(parser);
  return finishNode({
    type: 'JSXOpeningFragment'
  });
}
export function parseJSXClosingFragment(
  parser: ParserState,
  context: Context,
  inJSXChild: 0 | 1
): ESTree.JSXClosingFragment {
  consume(parser, context, Token.JSXClose);

  if (inJSXChild) {
    consume(parser, context, Token.GreaterThan);
  } else {
    consume(parser, context, Token.GreaterThan);
  }

  return finishNode({
    type: 'JSXClosingFragment'
  });
}

export function parseJSXChildren(parser: ParserState, context: Context): ESTree.JSXChild[] {
  const children: ESTree.JSXChild[] = [];
  while (parser.token !== Token.JSXClose) {
    parser.index = parser.tokenPos = parser.startPos;
    parser.column = parser.endColumn = parser.startColumn;
    parser.line = parser.endLine = parser.startLine;
    scanJSXToken(parser);
    children.push(parseJSXChild(parser, context));
  }
  return children;
}

export function parseJSXChild(
  parser: ParserState,
  context: Context
): ESTree.JSXExpression | ESTree.JSXText | ESTree.JSXElement | ESTree.JSXFragment {
  switch (parser.token) {
    case Token.JSXText:
      return parseJSXText(parser);
    case Token.LeftBrace:
      return parseJSXExpressionContainer(parser, context, /*inJSXChild*/ 0, /* isAttr */ 0);
    default:
      if (parser.token !== Token.LessThan) report(parser, context, Errors.Unexpected, /* early */ 0);
      return parseJSXRootElementOrFragment(parser, context, /*inJSXChild*/ 0);
  }
}

export function parseJSXText(parser: ParserState): ESTree.JSXText {
  scanJSXToken(parser);
  return finishNode({
    type: 'JSXText',
    value: parser.tokenValue as string
  });
}

export function parseJSXExpressionContainer(
  parser: ParserState,
  context: Context,
  inJSXChild: 0 | 1,
  isAttr: 0 | 1
): ESTree.JSXExpressionContainer | ESTree.JSXSpreadChild {
  nextToken(parser, context);

  if (parser.token === Token.Ellipsis) return parseJSXSpreadChild(parser, context);

  let expression: ESTree.Expression | ESTree.JSXEmptyExpression | null = null;

  if (parser.token === Token.RightBrace) {
    // JSX attributes must only be assigned a non-empty 'expression'
    if (isAttr) report(parser, context, Errors.InvalidNonEmptyJSXExpr, /* early */ 0);
    expression = parseJSXEmptyExpression();
  } else {
    expression = parseExpression(parser, context);
  }
  if (inJSXChild) {
    consume(parser, context, Token.RightBrace);
  } else {
    scanJSXToken(parser);
  }

  return finishNode({
    type: 'JSXExpressionContainer',
    expression: expression as ESTree.Expression | ESTree.JSXEmptyExpression
  });
}

export function parseJSXSpreadChild(parser: ParserState, context: Context): ESTree.JSXSpreadChild {
  consume(parser, context, Token.Ellipsis);
  const expression = parseExpression(parser, context);
  consume(parser, context, Token.RightBrace);
  return finishNode({
    type: 'JSXSpreadChild',
    expression
  });
}

export function parseJSXEmptyExpression(): ESTree.JSXEmptyExpression {
  return finishNode({
    type: 'JSXEmptyExpression'
  });
}

export function parseJSXIdentifier(parser: ParserState, context: Context): ESTree.JSXIdentifier {
  const { tokenValue } = parser;
  nextToken(parser, context);
  return finishNode({
    type: 'JSXIdentifier',
    name: tokenValue as string
  });
}

export function parseJsxAttribute(
  parser: ParserState,
  context: Context
): ESTree.JSXAttribute | ESTree.JSXSpreadAttribute {
  if (parser.token === Token.LeftBrace) return parseJSXSpreadAttribute(parser, context);
  scanJSXIdentifier(parser);
  let value: any = null;
  let name: any = parseJSXIdentifier(parser, context);

  if (parser.token === Token.Colon) {
    name = parseJSXNamespacedName(parser, context, name);
  }

  // HTML empty attribute
  if (parser.token === Token.Assign) {
    const token = scanJSXAttributeValue(parser, context);

    switch (token) {
      case Token.StringLiteral:
        value = parseLiteral(parser, context);
        break;
      case Token.LessThan:
        value = parseJSXRootElementOrFragment(parser, context, /*inJSXChild*/ 1);
        break;
      case Token.LeftBrace:
        value = parseJSXExpressionContainer(parser, context, 1, 1);
        break;
      default:
        report(parser, context, Errors.InvalidJSXAttributeValue, /* early */ 0);
    }
  }

  return finishNode({
    type: 'JSXAttribute',
    value,
    name
  });
}
export function parseJSXSpreadAttribute(parser: ParserState, context: Context): ESTree.JSXSpreadAttribute {
  nextToken(parser, context); // skips: '{'
  consume(parser, context, Token.Ellipsis);
  const expression = parseExpression(parser, context);
  consume(parser, context, Token.RightBrace);
  return finishNode({
    type: 'JSXSpreadAttribute',
    argument: expression
  });
}

export function parseJSXNamespacedName(
  parser: ParserState,
  context: Context,
  namespace: ESTree.JSXIdentifier | ESTree.JSXMemberExpression
): ESTree.JSXNamespacedName {
  consume(parser, context, Token.Colon);
  const name = parseJSXIdentifier(parser, context);
  return finishNode({
    type: 'JSXNamespacedName',
    namespace,
    name
  });
}

export function parseDecorators(parser: ParserState, context: Context): ESTree.Decorator[] {
  const list: ESTree.Decorator[] = [];

  while (consumeOpt(parser, context, Token.At)) {
    list.push(parseDecoratorList(parser, context));
  }

  return list;
}

export function parseDecoratorList(parser: ParserState, context: Context): ESTree.Decorator {
  let expression = parsePrimaryExpression(parser, context, /* isLHS */ 0, /* inParen */ 0);

  expression = parseMemberOrUpdateExpression(parser, context, expression);

  return finishNode({
    type: 'Decorator',
    expression
  });
}

export function parseAssertsTypePredicateOrTypePredicate(parser: ParserState, context: Context) {
  const { tokenValue } = parser;
  nextToken(parser, context);
  if (parser.precedingLineBreak === 0) {
    const parameterName =
      parser.token === Token.ThisKeyword ? parseThisExpression(parser, context) : parseIdentifier(parser, context);
    const typeAnnotation = consumeOpt(parser, context, Token.IsKeyword)
      ? parseType(parser, context, /* restrictedTypes */ 0, /* isMappedType */ 0, TypeAliasState.None)
      : null;
    return finishNode({
      type: 'TypePredicate',
      assertsModifier: true,
      parameterName,
      typeAnnotation
    });
  }
  return parseTypeReferenceFromExpression(parser, context, parseIdentifierFromValue(parser, context, tokenValue, 0));
}
