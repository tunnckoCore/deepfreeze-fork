export interface _Node {
  start?: number;
  end?: number;
  loc?: SourceLocation | null;
}

export interface SourceLocation {
  source?: string | null;
  start: Position;
  end: Position;
}

export interface Position {
  /** >= 1 */
  line: number;
  /** >= 0 */
  column: number;
}

export type CommentType = 'Line' | 'Block' | 'HTMLOpen' | 'HTMLClose';

export interface Comment extends _Node {
  type: CommentType;
  value: string;
  start?: number;
  end?: number;
  loc?: SourceLocation | null;
}

export type Node =
  | ArrayExpression
  | ArrayPattern
  | ArrowFunctionExpression
  | AssignmentExpression
  | AssignmentPattern
  | AwaitExpression
  | BigIntLiteral
  | BinaryExpression
  | BlockStatement
  | BreakStatement
  | CallExpression
  | CatchClause
  | ClassBody
  | ClassDeclaration
  | ClassExpression
  | ClassProperty
  | ConditionalExpression
  | ContinueStatement
  | DebuggerStatement
  | Decorator
  | DoWhileStatement
  | EmptyStatement
  | ExportAllDeclaration
  | ExportDefaultDeclaration
  | ExportNamedDeclaration
  | ExportNamespaceSpecifier
  | ExportSpecifier
  | ExpressionStatement
  | ForInStatement
  | ForOfStatement
  | ForStatement
  | FunctionDeclaration
  | FunctionExpression
  | Identifier
  | IfStatement
  | Import
  | ImportDeclaration
  | ImportDefaultSpecifier
  | ImportNamespaceSpecifier
  | ImportSpecifier
  | ImportExpression
  | JSXAttribute
  | JSXClosingElement
  | JSXClosingFragment
  | JSXElement
  | JSXEmptyExpression
  | JSXExpressionContainer
  | JSXFragment
  | JSXIdentifier
  | JSXNamespacedName
  | JSXOpeningElement
  | JSXOpeningFragment
  | JSXSpreadAttribute
  | JSXSpreadChild
  | JSXMemberExpression
  | JSXText
  | LabeledStatement
  | Literal
  | LogicalExpression
  | MemberExpression
  | MetaProperty
  | MethodDefinition
  | NewExpression
  | ObjectExpression
  | ObjectPattern
  | OptionalExpression
  | OptionalChain
  | Program
  | ParenthesizedExpression
  | Property
  | RestElement
  | ReturnStatement
  | SequenceExpression
  | SpreadElement
  | Super
  | SwitchCase
  | SwitchStatement
  | TaggedTemplateExpression
  | TemplateElement
  | TemplateLiteral
  | ThisExpression
  | ThrowStatement
  | TryStatement
  | AbstractClassProperty
  | AbstractKeyword
  | AbstractMethodDefinition
  | AnyKeyword
  | ArrayType
  | AsExpression
  | AsyncKeyword
  | BigIntKeyword
  | BooleanKeyword
  | CallSignatureDeclaration
  | ClassImplements
  | ConditionalType
  | ConstructorType
  | ConstructSignatureDeclaration
  | DeclareFunction
  | DeclareKeyword
  | EmptyBodyFunctionExpression
  | EnumDeclaration
  | EnumMember
  | ExportAssignment
  | ExportKeyword
  | ExternalModuleReference
  | FunctionType
  | ImportEqualsDeclaration
  | ImportType
  | IndexedAccessType
  | IndexSignature
  | InferType
  | InterfaceDeclaration
  | InterfaceBody
  | InterfaceHeritage
  | IntersectionType
  | LiteralType
  | MappedType
  | MethodSignature
  | ModuleBlock
  | ModuleDeclaration
  | NamespaceExportDeclaration
  | NeverKeyword
  | NonNullExpression
  | NullKeyword
  | NumberKeyword
  | ObjectKeyword
  | OptionalType
  | ParameterProperty
  | ParenthesizedType
  | PropertySignature
  | PublicKeyword
  | PrivateKeyword
  | ProtectedKeyword
  | QualifiedName
  | ReadonlyKeyword
  | RestType
  | StaticKeyword
  | StringKeyword
  | SymbolKeyword
  | ThisType
  | TupleType
  | TypeAliasDeclaration
  | TypeAnnotation
  | TypeAssertion
  | TypeLiteral
  | TypeOperator
  | TypeParameter
  | TypeParameterDeclaration
  | TypeParameterInstantiation
  | TypePredicate
  | TypeQuery
  | TypeReference
  | UndefinedKeyword
  | UnionType
  | UnknownKeyword
  | VoidKeyword
  | UpdateExpression
  | UnaryExpression
  | VariableDeclaration
  | VariableDeclarator
  | WhileStatement
  | WithStatement
  | YieldExpression;

export type Accessibility = 'public' | 'protected' | 'private' | null;

export type ClassElement =
  | ClassProperty
  | FunctionExpression
  | MethodDefinition
  | AbstractClassProperty
  | AbstractMethodDefinition
  | EmptyBodyFunctionExpression
  | IndexSignature;
export type DeclarationStatement =
  | ClassDeclaration
  | ClassExpression
  | ExportDefaultDeclaration
  | ExportAllDeclaration
  | ExportNamedDeclaration
  | FunctionDeclaration
  | DeclareFunction
  | ImportEqualsDeclaration
  | InterfaceDeclaration
  | ModuleDeclaration
  | NamespaceExportDeclaration
  | TypeAliasDeclaration
  | EnumDeclaration;
export type EntityName = Identifier | QualifiedName;
export type ExportDeclaration =
  | ClassDeclaration
  | ClassExpression
  | FunctionDeclaration
  | DeclareFunction
  | EnumDeclaration
  | InterfaceDeclaration
  | ModuleDeclaration
  | TypeAliasDeclaration
  | VariableDeclaration;
export type Expression =
  | ArrowFunctionExpression
  | AssignmentExpression
  | BinaryExpression
  | ConditionalExpression
  | JSXClosingElement
  | JSXClosingFragment
  | JSXExpressionContainer
  | JSXOpeningElement
  | JSXOpeningFragment
  | JSXSpreadChild
  | LogicalExpression
  | NewExpression
  | RestElement
  | SequenceExpression
  | SpreadElement
  | AsExpression
  | UnaryExpression
  | YieldExpression;
export type ExpressionWithTypeArguments = ClassImplements | InterfaceHeritage;
export type ForInitialiser = Expression | VariableDeclaration;
export type ImportClause = ImportDefaultSpecifier | ImportNamespaceSpecifier | ImportSpecifier;
export type IterationStatement = DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | WhileStatement;
export type JSXChild = JSXElement | JSXExpression | JSXFragment | JSXText;
export type JSXExpression = JSXEmptyExpression | JSXSpreadChild | JSXExpressionContainer;
export type JSXTagNameExpression = JSXIdentifier | JSXMemberExpression;
export type LeftHandSideExpression =
  | CallExpression
  | ClassExpression
  | ClassDeclaration
  | FunctionExpression
  | LiteralExpression
  | MemberExpression
  | PrimaryExpression
  | TaggedTemplateExpression
  | NonNullExpression
  | AsExpression;
export type LiteralExpression = BigIntLiteral | Literal | TemplateLiteral;
export type Modifier =
  | AbstractKeyword
  | AsyncKeyword
  | DeclareKeyword
  | ExportKeyword
  | PublicKeyword
  | PrivateKeyword
  | ProtectedKeyword
  | ReadonlyKeyword
  | StaticKeyword;
export type ObjectLiteralElementLike =
  | MethodDefinition
  | Property
  | RestElement
  | SpreadElement
  | AbstractMethodDefinition;
export type Parameter = AssignmentPattern | RestElement | ArrayPattern | ObjectPattern | Identifier | ParameterProperty;
export type PrimaryExpression =
  | ArrayExpression
  | ArrayPattern
  | ClassExpression
  | FunctionExpression
  | Identifier
  | Import
  | JSXElement
  | JSXFragment
  | JSXOpeningElement
  | Literal
  | LiteralExpression
  | MetaProperty
  | ObjectExpression
  | ObjectPattern
  | Super
  | TemplateLiteral
  | ThisExpression
  | NullKeyword;
export type Statement =
  | BlockStatement
  | BreakStatement
  | ContinueStatement
  | DebuggerStatement
  | DeclarationStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | IterationStatement
  | ImportDeclaration
  | LabeledStatement
  | ModuleBlock
  | ReturnStatement
  | SwitchStatement
  | ThrowStatement
  | TryStatement
  | VariableDeclaration
  | WithStatement;
export type TypeElement =
  | CallSignatureDeclaration
  | ConstructSignatureDeclaration
  | IndexSignature
  | MethodSignature
  | PropertySignature;
export type TypeNode =
  | ThisExpression
  | AnyKeyword
  | ArrayType
  | BigIntKeyword
  | BooleanKeyword
  | ClassImplements
  | ConditionalType
  | ConstructorType
  | FunctionType
  | ImportType
  | IndexedAccessType
  | InferType
  | InterfaceHeritage
  | IntersectionType
  | LiteralType
  | MappedType
  | NeverKeyword
  | NullKeyword
  | NumberKeyword
  | ObjectKeyword
  | OptionalType
  | ParenthesizedType
  | RestType
  | StringKeyword
  | SymbolKeyword
  | ThisType
  | TupleType
  | TypeLiteral
  | TypeOperator
  | TypeReference
  | TypePredicate
  | TypeQuery
  | UndefinedKeyword
  | UnionType
  | UnknownKeyword
  | VoidKeyword;

interface ClassDeclarationBase extends _Node {
  typeParameters?: TypeParameterDeclaration;
  superTypeParameters?: TypeParameterInstantiation;
  id: Identifier | null;
  body: ClassBody;
  superClass?: LeftHandSideExpression | null;
  implements?: ExpressionWithTypeArguments[];
  abstract?: boolean;
  declare?: boolean;
  decorators?: Decorator[];
}

interface ClassPropertyBase extends _Node {
  key: Identifier | Literal;
  value: Expression;
  computed: boolean;
  static: boolean;
  readonly?: boolean;
  decorators?: Decorator[];
  accessibility?: Accessibility;
  optional?: boolean;
  definite?: boolean;
  typeAnnotation?: TypeAnnotation;
}

interface FunctionDeclarationBase extends _Node {
  id: Identifier | null;
  generator: boolean;
  async: boolean;
  params: Parameter[];
  body?: BlockStatement | null;
  returnType?: TypeAnnotation;
  typeParameters?: TypeParameterDeclaration;
  declare?: boolean;
}

interface FunctionSignatureBase extends _Node {
  params: Parameter[];
  returnType?: TypeAnnotation;
  typeParameters?: TypeParameterDeclaration;
}

interface MethodDefinitionBase extends _Node {
  key: Expression;
  value: FunctionExpression | EmptyBodyFunctionExpression;
  computed: boolean;
  static: boolean;
  kind: 'method' | 'get' | 'set' | 'constructor';
  decorators?: Decorator[];
  accessibility?: Accessibility;
  typeParameters?: TypeParameterDeclaration;
}

interface HeritageBase extends _Node {
  expression: Expression;
  typeParameters?: TypeParameterInstantiation;
}

export interface ArrayExpression extends _Node {
  type: 'ArrayExpression';
  elements: Expression[];
}

export interface ArrayPattern extends _Node {
  type: 'ArrayPattern';
  elements: Expression[];
  typeAnnotation?: TypeAnnotation;
  optional?: boolean;
  decorators?: Decorator[];
}

export interface ArrowFunctionExpression extends _Node {
  type: 'ArrowFunctionExpression';
  params: Parameter[];
  body: Expression | BlockStatement;
  async: boolean;
  expression: boolean;
  returnType?: TypeAnnotation;
  typeParameters?: TypeParameterDeclaration;
}

export type AssignmentOperator =
  | '='
  | '<<='
  | '>>='
  | '>>>='
  | '**='
  | '+='
  | '-='
  | '*='
  | '/='
  | '%='
  | '^='
  | '|='
  | '&=';

export interface AssignmentExpression extends _Node {
  type: 'AssignmentExpression';
  operator: AssignmentOperator;
  left: Expression;
  right: Expression;
}

export interface AssignmentPattern extends _Node {
  type: 'AssignmentPattern';
  left: ArrayPattern | ObjectPattern | Identifier;
  right?: Expression;
  typeAnnotation?: TypeAnnotation;
  optional?: boolean;
  decorators?: Decorator[];
}

export interface AwaitExpression extends _Node {
  type: 'AwaitExpression';
  argument: UnaryExpression;
}

export interface BigIntLiteral extends _Node {
  type: 'BigIntLiteral';
  raw?: string;
  value: number | null;
}

export interface BinaryExpression extends _Node {
  type: 'BinaryExpression';
  operator: string;
  left: Expression;
  right: Expression;
}

export interface BlockStatement extends _Node {
  type: 'BlockStatement';
  body: Statement[];
}

export interface BreakStatement extends _Node {
  type: 'BreakStatement';
  label: Identifier | null;
}

export interface ImportExpression extends _Node {
  type: 'ImportExpression';
  source: Expression;
}

export interface OptionalExpression extends _Node {
  type: 'OptionalExpression';
  object: Expression;
  chain: OptionalChain | MemberExpression;
}
export interface OptionalChain extends _Node {
  type: 'OptionalChain';
  base: Expression | null;
  property?: Expression;
  computed?: boolean;
  arguments?: any;
}

export interface CallExpression extends _Node {
  type: 'CallExpression';
  callee: LeftHandSideExpression;
  arguments: Expression[];
  typeParameters?: TypeParameterInstantiation;
}

export interface CatchClause extends _Node {
  type: 'CatchClause';
  param: ArrayPattern | ObjectPattern | Identifier | null;
  body: BlockStatement;
}

export interface ClassBody extends _Node {
  type: 'ClassBody';
  body: ClassElement[];
}

export interface ClassDeclaration extends ClassDeclarationBase {
  type: 'ClassDeclaration';
}

export interface ClassExpression extends ClassDeclarationBase {
  type: 'ClassExpression';
}

export interface ClassProperty extends ClassPropertyBase {
  type: 'ClassProperty';
}

export interface ConditionalExpression extends _Node {
  type: 'ConditionalExpression';
  test: Expression;
  consequent: Expression;
  alternate: Expression;
}

export interface ContinueStatement extends _Node {
  type: 'ContinueStatement';
  label: Identifier | null;
}

export interface DebuggerStatement extends _Node {
  type: 'DebuggerStatement';
}

export interface Decorator extends _Node {
  type: 'Decorator';
  expression: LeftHandSideExpression;
}

export interface DoWhileStatement extends _Node {
  type: 'DoWhileStatement';
  test: Expression;
  body: Statement;
}

export interface EmptyStatement extends _Node {
  type: 'EmptyStatement';
}

export interface ExportAllDeclaration extends _Node {
  type: 'ExportAllDeclaration';
  source: Expression | null;
}

export interface ExportDefaultDeclaration extends _Node {
  type: 'ExportDefaultDeclaration';
  declaration: ExportDeclaration | Expression;
}

export interface ExportNamespaceSpecifier extends _Node {
  type: 'ExportNamespaceSpecifier';
  specifier: Identifier;
}

export interface ExportNamedDeclaration extends _Node {
  type: 'ExportNamedDeclaration';
  declaration: ExportDeclaration | null;
  specifiers: (ExportNamespaceSpecifier | ExportSpecifier)[];
  source: Literal | null;
}

export interface ExportSpecifier extends _Node {
  type: 'ExportSpecifier';
  local: Identifier;
  exported: Identifier;
}

export interface ExpressionStatement extends _Node {
  type: 'ExpressionStatement';
  expression: Expression;
  directive?: string;
}

export interface ForInStatement extends _Node {
  type: 'ForInStatement';
  left: ForInitialiser;
  right: Expression;
  body: Statement;
}

export interface ForOfStatement extends _Node {
  type: 'ForOfStatement';
  left: ForInitialiser;
  right: Expression;
  body: Statement;
  await: boolean;
}

export interface ForStatement extends _Node {
  type: 'ForStatement';
  init: Expression | ForInitialiser | null;
  test: Expression | null;
  update: Expression | null;
  body: Statement;
}

export interface FunctionDeclaration extends FunctionDeclarationBase {
  type: 'FunctionDeclaration';
}

export interface FunctionExpression extends FunctionDeclarationBase {
  type: 'FunctionExpression';
}

export interface Identifier extends _Node {
  type: 'Identifier';
  name: string;
  pattern?: boolean;
  typeAnnotation?: TypeAnnotation;
  optional?: boolean;
  decorators?: Decorator[];
}

export interface IfStatement extends _Node {
  type: 'IfStatement';
  test: Expression;
  consequent: Statement;
  alternate: Statement | null;
}

export interface Import extends _Node {
  type: 'Import';
}

export interface ImportDeclaration extends _Node {
  type: 'ImportDeclaration';
  source: Literal;
  specifiers: ImportClause[];
}

export interface ImportDefaultSpecifier extends _Node {
  type: 'ImportDefaultSpecifier';
  local: Identifier;
}

export interface ImportNamespaceSpecifier extends _Node {
  type: 'ImportNamespaceSpecifier';
  local: Identifier;
}

export interface ImportSpecifier extends _Node {
  type: 'ImportSpecifier';
  local: Identifier;
  imported: Identifier;
}

export interface JSXNamespacedName extends _Node {
  type: 'JSXNamespacedName';
  namespace: JSXIdentifier | JSXMemberExpression;
  name: JSXIdentifier;
}

export interface JSXAttribute extends _Node {
  type: 'JSXAttribute';
  name: JSXIdentifier;
  value: Literal | JSXExpression | null;
}

export interface JSXClosingElement extends _Node {
  type: 'JSXClosingElement';
  name: JSXTagNameExpression;
}

export interface JSXClosingFragment extends _Node {
  type: 'JSXClosingFragment';
}

export interface JSXElement extends _Node {
  type: 'JSXElement';
  openingElement: JSXOpeningElement;
  closingElement: JSXClosingElement | null;
  children: JSXChild[];
}

export interface JSXEmptyExpression extends _Node {
  type: 'JSXEmptyExpression';
}

export interface JSXExpressionContainer extends _Node {
  type: 'JSXExpressionContainer';
  expression: Expression | JSXEmptyExpression;
}

export interface JSXFragment extends _Node {
  type: 'JSXFragment';
  openingFragment: JSXOpeningFragment;
  closingFragment: JSXClosingFragment;
  children: JSXChild[];
}

export interface JSXIdentifier extends _Node {
  type: 'JSXIdentifier';
  name: string;
}

export interface JSXMemberExpression extends _Node {
  type: 'JSXMemberExpression';
  object: JSXTagNameExpression;
  property: JSXIdentifier;
}

export interface JSXOpeningElement extends _Node {
  type: 'JSXOpeningElement';
  typeParameters?: TypeParameterInstantiation;
  selfClosing: boolean;
  name: JSXTagNameExpression;
  attributes: JSXAttribute[];
}

export interface JSXOpeningFragment extends _Node {
  type: 'JSXOpeningFragment';
}

export interface JSXSpreadAttribute extends _Node {
  type: 'JSXSpreadAttribute';
  argument: Expression;
}

export interface JSXSpreadChild extends _Node {
  type: 'JSXSpreadChild';
  expression: Expression | JSXEmptyExpression;
}

export interface JSXText extends _Node {
  type: 'JSXText';
  value: string;
  raw?: string;
}

export interface LabeledStatement extends _Node {
  type: 'LabeledStatement';
  label: Identifier;
  body: Statement;
}

export interface Literal extends _Node {
  type: 'Literal';
  raw?: string;
  value: boolean | number | RegExp | string | null;
  regex?: {
    pattern: string;
    flags: string;
  };
}

export interface LogicalExpression extends _Node {
  type: 'LogicalExpression';
  operator: string;
  left: Expression;
  right: Expression;
}

export interface MemberExpression extends _Node {
  type: 'MemberExpression';
  object: LeftHandSideExpression;
  property: Expression | Identifier;
  computed?: boolean;
}

export interface MetaProperty extends _Node {
  type: 'MetaProperty';
  meta: Identifier;
  property: Identifier;
}

export interface MethodDefinition extends MethodDefinitionBase {
  type: 'MethodDefinition';
}

export interface NewExpression extends _Node {
  type: 'NewExpression';
  callee: LeftHandSideExpression;
  arguments: Expression[];
  typeParameters?: TypeParameterInstantiation;
}

export interface ObjectExpression extends _Node {
  type: 'ObjectExpression';
  properties: ObjectLiteralElementLike[];
}

export interface ObjectPattern extends _Node {
  type: 'ObjectPattern';
  properties: ObjectLiteralElementLike[];
  typeAnnotation?: TypeAnnotation;
  optional?: boolean;
  decorators?: Decorator[];
}

export interface Program extends _Node {
  type: 'Program';
  body: Statement[];
  sourceType: 'module' | 'script';
}

export interface ParenthesizedExpression extends _Node {
  type: 'ParenthesizedExpression';
  expression: Expression;
}

export interface Property extends _Node {
  type: 'Property';
  key: Expression | Identifier | Literal;
  value: Expression | AssignmentPattern | ArrayPattern | ObjectPattern | Identifier;
  computed: boolean;
  method: boolean;
  shorthand: boolean;
  kind: 'init' | 'get' | 'set';
}

export interface RestElement extends _Node {
  type: 'RestElement';
  argument: ArrayPattern | ObjectPattern | Identifier | Expression | Identifier | Literal;
  typeAnnotation?: TypeAnnotation;
  optional?: boolean;
  value?: AssignmentPattern;
  decorators?: Decorator[];
}

export interface ReturnStatement extends _Node {
  type: 'ReturnStatement';
  argument: Expression | null;
}

export interface SequenceExpression extends _Node {
  type: 'SequenceExpression';
  expressions: Expression[];
}

export type SpreadArgument = ArrayPattern | ObjectPattern | Identifier | Expression | Identifier | Literal;

export interface SpreadElement extends _Node {
  type: 'SpreadElement';
  argument: SpreadArgument;
}

export interface Super extends _Node {
  type: 'Super';
}

export interface SwitchCase extends _Node {
  type: 'SwitchCase';
  test: Expression | null;
  consequent: Statement[];
}

export interface SwitchStatement extends _Node {
  type: 'SwitchStatement';
  discriminant: Expression;
  cases: SwitchCase[];
}

export interface TaggedTemplateExpression extends _Node {
  type: 'TaggedTemplateExpression';
  typeParameters?: TypeParameterInstantiation;
  tag: LeftHandSideExpression;
  quasi: TemplateLiteral;
}

export interface TemplateElement extends _Node {
  type: 'TemplateElement';
  value: {
    raw: string;
    cooked: string;
  };
  tail: boolean;
}

export interface TemplateLiteral extends _Node {
  type: 'TemplateLiteral';
  quasis: TemplateElement[];
  expressions: Expression[];
}

export interface ThisExpression extends _Node {
  type: 'ThisExpression';
}

export interface ThrowStatement extends _Node {
  type: 'ThrowStatement';
  argument: Statement | AsExpression | null;
}

export interface TryStatement extends _Node {
  type: 'TryStatement';
  block: BlockStatement;
  handler: CatchClause | null;
  finalizer: BlockStatement;
}

export interface AbstractClassProperty extends ClassPropertyBase {
  type: 'AbstractClassProperty';
}

export interface AbstractKeyword extends _Node {
  type: 'AbstractKeyword';
}

export interface AbstractMethodDefinition extends MethodDefinitionBase {
  type: 'AbstractMethodDefinition';
}

export interface AnyKeyword extends _Node {
  type: 'AnyKeyword';
}

export interface ArrayType extends _Node {
  type: 'ArrayType';
  elementType: TypeNode;
}

export interface AsExpression extends _Node {
  type: 'AsExpression';
  expression: Expression;
  typeAnnotation: TypeNode;
}

export interface AsyncKeyword extends _Node {
  type: 'AsyncKeyword';
}

export interface BigIntKeyword extends _Node {
  type: 'BigIntKeyword';
}

export interface BooleanKeyword extends _Node {
  type: 'BooleanKeyword';
}

export interface CallSignatureDeclaration extends FunctionSignatureBase {
  type: 'CallSignatureDeclaration';
}

export interface ClassImplements extends HeritageBase {
  type: 'ClassImplements';
}

export interface ConditionalType extends _Node {
  type: 'ConditionalType';
  checkType: TypeNode;
  extendsType: TypeNode;
  trueType: TypeNode;
  falseType: TypeNode;
}

export interface ConstructorType extends FunctionSignatureBase {
  type: 'ConstructorType';
}

export interface ConstructSignatureDeclaration extends FunctionSignatureBase {
  type: 'ConstructSignatureDeclaration';
}

export interface DeclareFunction extends FunctionDeclarationBase {
  id: Identifier;
  type: 'DeclareFunction';
}

export interface DeclareKeyword extends _Node {
  type: 'DeclareKeyword';
}

export interface EmptyBodyFunctionExpression extends FunctionDeclarationBase {
  type: 'EmptyBodyFunctionExpression';
  body: null;
}

export interface EnumDeclaration extends _Node {
  type: 'EnumDeclaration';
  id: Identifier;
  members: EnumMember[];
  const?: boolean;
  declare?: boolean;
  modifiers?: Modifier[];
  decorators?: Decorator[];
}

export interface EnumMember extends _Node {
  type: 'EnumMember';
  id: Identifier | Literal;
  initializer?: Expression;
}

export interface ExportAssignment extends _Node {
  type: 'ExportAssignment';
  expression: Expression;
}

export interface ExportKeyword extends _Node {
  type: 'ExportKeyword';
}

export interface ExternalModuleReference extends _Node {
  type: 'ExternalModuleReference';
  expression: Expression;
}

export interface FunctionType extends FunctionSignatureBase {
  type: 'FunctionType';
}

export interface ImportEqualsDeclaration extends _Node {
  type: 'ImportEqualsDeclaration';
  id: Identifier;
  moduleReference: EntityName | ExternalModuleReference;
  isExport: boolean;
}

export interface ImportType extends _Node {
  type: 'ImportType';
  isTypeOf: boolean;
  parameter: TypeNode;
  qualifier: EntityName | null;
  typeParameters: TypeParameterInstantiation | null;
}

export interface IndexedAccessType extends _Node {
  type: 'IndexedAccessType';
  objectType: TypeNode;
  indexType: TypeNode;
}

export interface IndexSignature extends _Node {
  type: 'IndexSignature';
  parameters: Parameter[];
  typeAnnotation?: TypeAnnotation;
  readonly?: boolean;
  accessibility?: Accessibility;
  export?: boolean;
  static?: boolean;
}

export interface InferType extends _Node {
  type: 'InferType';
  typeParameter: TypeParameterDeclaration;
}

export interface InterfaceDeclaration extends _Node {
  type: 'InterfaceDeclaration';
  body: InterfaceBody;
  id: Identifier;
  typeParameters?: TypeParameterDeclaration;
  extends?: ExpressionWithTypeArguments[];
  implements?: ExpressionWithTypeArguments[];
  decorators?: Decorator[];
  abstract?: boolean;
  declare?: boolean;
}

export interface InterfaceBody extends _Node {
  type: 'InterfaceBody';
  body: TypeElement[];
}

export interface InterfaceHeritage extends HeritageBase {
  type: 'InterfaceHeritage';
}

export interface IntersectionType extends _Node {
  type: 'IntersectionType';
  types: TypeNode[];
}

export interface LiteralType extends _Node {
  type: 'LiteralType';
  literal: LiteralExpression | UnaryExpression | UpdateExpression;
}

export interface MappedType extends _Node {
  type: 'MappedType';
  typeParameter: TypeParameterDeclaration;
  readonly?: boolean | '-' | '+';
  optional?: boolean | '-' | '+';
  typeAnnotation?: TypeNode;
}

export interface MethodSignature extends _Node {
  type: 'MethodSignature';
  computed: boolean;
  key: Identifier | Literal;
  params: Parameter[];
  optional?: boolean;
  returnType?: TypeAnnotation;
  readonly?: boolean;
  typeParameters?: TypeParameterDeclaration;
  accessibility?: Accessibility;
  export?: boolean;
  static?: boolean;
}

export interface ModuleBlock extends _Node {
  type: 'ModuleBlock';
  body: Statement[];
}

export interface ModuleDeclaration extends _Node {
  type: 'ModuleDeclaration';
  id: Identifier | Literal;
  body?: ModuleBlock | ModuleDeclaration;
  global?: boolean;
  declare?: boolean;
  modifiers?: Modifier[];
}

export interface NamespaceExportDeclaration extends _Node {
  type: 'NamespaceExportDeclaration';
  id: Identifier;
}

export interface NeverKeyword extends _Node {
  type: 'NeverKeyword';
}

export interface NonNullExpression extends _Node {
  type: 'NonNullExpression';
  expression: Expression;
}

export interface NullKeyword extends _Node {
  type: 'NullKeyword';
}

export interface NumberKeyword extends _Node {
  type: 'NumberKeyword';
}

export interface ObjectKeyword extends _Node {
  type: 'ObjectKeyword';
}

export interface OptionalType extends _Node {
  type: 'OptionalType';
  typeAnnotation: TypeNode;
}

export interface ParameterProperty extends _Node {
  type: 'ParameterProperty';
  accessibility?: Accessibility;
  readonly?: boolean;
  static?: boolean;
  export?: boolean;
  parameter: AssignmentPattern | ArrayPattern | ObjectPattern | Identifier | RestElement;
  decorators?: Decorator[];
}

export interface ParenthesizedType extends _Node {
  type: 'ParenthesizedType';
  typeAnnotation: TypeNode;
}

export interface PropertySignature extends _Node {
  type: 'PropertySignature';
  optional?: boolean;
  computed: boolean;
  key: Identifier | Literal;
  typeAnnotation?: TypeAnnotation;
  initializer?: Expression;
  readonly?: boolean;
  static?: boolean;
  export?: boolean;
  accessibility?: Accessibility;
}

export interface PublicKeyword extends _Node {
  type: 'PublicKeyword';
}

export interface PrivateKeyword extends _Node {
  type: 'PrivateKeyword';
}

export interface ProtectedKeyword extends _Node {
  type: 'ProtectedKeyword';
}

export interface QualifiedName extends _Node {
  type: 'QualifiedName';
  left: EntityName;
  right: Identifier;
}

export interface ReadonlyKeyword extends _Node {
  type: 'ReadonlyKeyword';
}

export interface RestType extends _Node {
  type: 'RestType';
  typeAnnotation: TypeNode;
}

export interface StaticKeyword extends _Node {
  type: 'StaticKeyword';
}

export interface StringKeyword extends _Node {
  type: 'StringKeyword';
}

export interface SymbolKeyword extends _Node {
  type: 'SymbolKeyword';
}

export interface ThisType extends _Node {
  type: 'ThisType';
}

export interface TupleType extends _Node {
  type: 'TupleType';
  elementTypes: TypeNode[];
}

export interface TypeAliasDeclaration extends _Node {
  type: 'TypeAliasDeclaration';
  id: Identifier;
  typeAnnotation: TypeNode;
  declare?: boolean;
  typeParameters?: TypeParameterDeclaration;
}

export interface TypeAnnotation extends _Node {
  type: 'TypeAnnotation';
  typeAnnotation: TypeNode;
}

export interface TypeAssertion extends _Node {
  type: 'TypeAssertion';
  typeAnnotation: TypeNode;
  expression: Expression;
}

export interface TypeLiteral extends _Node {
  type: 'TypeLiteral';
  members: TypeElement[];
}

export interface TypeOperator extends _Node {
  type: 'TypeOperator';
  operator: 'keyof' | 'unique' | 'readonly';
  typeAnnotation?: TypeNode;
}

export interface TypeParameter extends _Node {
  type: 'TypeParameter';
  name: Identifier;
  constraint?: TypeNode;
  default?: TypeNode | null;
}

export interface TypeParameterDeclaration extends _Node {
  type: 'TypeParameterDeclaration';
  params: TypeParameter[];
}

export interface TypeParameterInstantiation extends _Node {
  type: 'TypeParameterInstantiation';
  params: TypeNode[];
}

export interface TypePredicate extends _Node {
  type: 'TypePredicate';
  assertsModifier: boolean;
  parameterName: Identifier | ThisType;
  typeAnnotation: TypeAnnotation;
}

export interface JSDocNullableType extends _Node {
  type: 'JSDocNullableType';
  typeAnnotation: TypeAnnotation;
}
export interface JSDocUnknownType extends _Node {
  type: 'JSDocUnknownType';
}

export interface TypeQuery extends _Node {
  type: 'TypeQuery';
  exprName: EntityName;
}

export interface TypeReference extends _Node {
  type: 'TypeReference';
  typeName: EntityName;
  typeParameters?: TypeParameterInstantiation;
}

export interface UndefinedKeyword extends _Node {
  type: 'UndefinedKeyword';
}

export interface UnionType extends _Node {
  type: 'UnionType';
  types: TypeNode[];
}

export interface UnknownKeyword extends _Node {
  type: 'UnknownKeyword';
}

export interface VoidKeyword extends _Node {
  type: 'VoidKeyword';
}

export type UnaryOperator = '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete';
export type UpdateOperator = '++' | '--';

export interface UpdateExpression extends _Node {
  type: 'UpdateExpression';
  operator: string;
  prefix: boolean;
  argument: LeftHandSideExpression | Literal | UnaryExpression;
}

export interface UnaryExpression extends _Node {
  type: 'UnaryExpression';
  operator: UnaryOperator;
  prefix: boolean;
  argument: LeftHandSideExpression | Literal | UnaryExpression;
}

export interface VariableDeclaration extends _Node {
  type: 'VariableDeclaration';
  declarations: VariableDeclarator[];
  kind: 'let' | 'const' | 'var';
  declare?: boolean;
}

export interface VariableDeclarator extends _Node {
  type: 'VariableDeclarator';
  id: ArrayPattern | ObjectPattern | Identifier;
  init: Expression | null;
  definite?: boolean;
}

export interface WhileStatement extends _Node {
  type: 'WhileStatement';
  test: Expression;
  body: Statement;
}

export interface WithStatement extends _Node {
  type: 'WithStatement';
  object: Expression;
  body: Statement;
}

export interface YieldExpression extends _Node {
  type: 'YieldExpression';
  delegate: boolean;
  argument?: Expression;
}
