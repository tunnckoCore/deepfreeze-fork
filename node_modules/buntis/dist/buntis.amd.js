define(['exports'], function (exports) { 'use strict';



  var estree = /*#__PURE__*/Object.freeze({

  });

  const KeywordDescTable = [
      'end of source',
      'identifier',
      'number',
      'string',
      'regular expression',
      'false',
      'true',
      'null',
      'template continuation',
      'template end',
      '=>',
      '(',
      '{',
      '.',
      '...',
      '}',
      ')',
      ';',
      ',',
      '[',
      ']',
      ':',
      '?',
      '?.',
      "'",
      '"',
      '</',
      '/>',
      '++',
      '--',
      '=',
      '<<=',
      '>>=',
      '>>>=',
      '**=',
      '+=',
      '-=',
      '*=',
      '/=',
      '%=',
      '^=',
      '|=',
      '&=',
      'typeof',
      'delete',
      'void',
      '!',
      '~',
      '+',
      '-',
      'in',
      'instanceof',
      '*',
      '%',
      '/',
      '**',
      '&&',
      '||',
      '===',
      '!==',
      '==',
      '!=',
      '<=',
      '>=',
      '<',
      '>',
      '<<',
      '>>',
      '>>>',
      '&',
      '|',
      '^',
      '?.',
      'var',
      'let',
      'const',
      'break',
      'case',
      'catch',
      'class',
      'continue',
      'debugger',
      'default',
      'do',
      'else',
      'export',
      'extends',
      'finally',
      'for',
      'function',
      'if',
      'import',
      'new',
      'return',
      'super',
      'switch',
      'this',
      'throw',
      'try',
      'while',
      'with',
      'implements',
      'interface',
      'package',
      'private',
      'protected',
      'public',
      'static',
      'yield',
      'as',
      'async',
      'await',
      'constructor',
      'get',
      'set',
      'from',
      'of',
      'Whitespace',
      'CarriageReturn',
      'LineFeed',
      'LeadingZero',
      'Error',
      '#',
      'BigIntLiteral',
      'enum',
      'Backslash',
      'declare',
      'type',
      'abstract',
      'namespace',
      'module',
      'global',
      'keyof',
      'unique',
      'is',
      'readonly',
      'infer',
      'require',
      'asserts',
      'EscapedStrictReserved',
      'EscapedKeyword',
      'JSXText',
      'At'
  ];
  const descKeywordTable = Object.create(null, {
      this: { value: 139360 },
      function: { value: 139353 },
      if: { value: 438362 },
      return: { value: 438365 },
      var: { value: 134357065 },
      else: { value: 438356 },
      for: { value: 438360 },
      new: { value: 139356 },
      in: { value: 16918578 },
      typeof: { value: 33693739 },
      while: { value: 438371 },
      case: { value: 438349 },
      break: { value: 438348 },
      try: { value: 438370 },
      catch: { value: 438350 },
      delete: { value: 33693740 },
      throw: { value: 438369 },
      switch: { value: 139359 },
      continue: { value: 438352 },
      default: { value: 438354 },
      instanceof: { value: 16918579 },
      do: { value: 438355 },
      void: { value: 33693741 },
      finally: { value: 438359 },
      async: { value: 430190 },
      await: { value: 168047 },
      class: { value: 139343 },
      const: { value: 134357067 },
      constructor: { value: 4208 },
      debugger: { value: 438353 },
      export: { value: 134656085 },
      extends: { value: 8278 },
      false: { value: 139269 },
      from: { value: 4211 },
      get: { value: 4209 },
      implements: { value: 16485 },
      import: { value: 139355 },
      interface: { value: 134664294 },
      let: { value: 184394 },
      null: { value: 139271 },
      of: { value: 4212 },
      package: { value: 16487 },
      private: { value: 540776 },
      protected: { value: 540777 },
      public: { value: 540778 },
      set: { value: 4210 },
      static: { value: 540779 },
      super: { value: 139358 },
      true: { value: 139270 },
      with: { value: 438372 },
      yield: { value: 184428 },
      enum: { value: 134226044 },
      as: { value: 16915309 },
      declare: { value: 36990 },
      type: { value: 134254719 },
      abstract: { value: 134779008 },
      namespace: { value: 134254721 },
      module: { value: 134254722 },
      global: { value: 134254723 },
      keyof: { value: 36996 },
      unique: { value: 36997 },
      is: { value: 36998 },
      readonly: { value: 561287 },
      infer: { value: 37000 },
      require: { value: 37001 },
      asserts: { value: 138 }
  });

  const unicodeLookup = ((compressed, lookup) => {
      const result = new Uint32Array(104448);
      let index = 0;
      let subIndex = 0;
      while (index < 3460) {
          const inst = compressed[index++];
          if (inst < 0) {
              subIndex -= inst;
          }
          else {
              let code = compressed[index++];
              if (inst & 2)
                  code = lookup[code];
              if (inst & 1) {
                  result.fill(code, subIndex, (subIndex += compressed[index++]));
              }
              else {
                  result[subIndex++] = code;
              }
          }
      }
      return result;
  })([
      -1,
      2,
      27,
      2,
      28,
      2,
      5,
      -1,
      0,
      77595648,
      3,
      46,
      2,
      3,
      0,
      14,
      2,
      57,
      2,
      58,
      3,
      0,
      3,
      0,
      3168796671,
      0,
      4294956992,
      2,
      1,
      2,
      0,
      2,
      59,
      3,
      0,
      4,
      0,
      4294966523,
      3,
      0,
      4,
      2,
      16,
      2,
      60,
      2,
      0,
      0,
      4294836735,
      0,
      3221225471,
      0,
      4294901942,
      2,
      61,
      0,
      134152192,
      3,
      0,
      2,
      0,
      4294951935,
      3,
      0,
      2,
      0,
      2683305983,
      0,
      2684354047,
      2,
      17,
      2,
      0,
      0,
      4294961151,
      3,
      0,
      2,
      2,
      20,
      2,
      0,
      0,
      608174079,
      2,
      0,
      2,
      128,
      2,
      6,
      2,
      62,
      -1,
      2,
      64,
      2,
      25,
      2,
      1,
      3,
      0,
      3,
      0,
      4294901711,
      2,
      41,
      0,
      4089839103,
      0,
      2961209759,
      0,
      1342439375,
      0,
      4294543342,
      0,
      3547201023,
      0,
      1577204103,
      0,
      4194240,
      0,
      4294688750,
      2,
      2,
      0,
      80831,
      0,
      4261478351,
      0,
      4294549486,
      2,
      2,
      0,
      2965387679,
      0,
      196559,
      0,
      3594373100,
      0,
      3288319768,
      0,
      8469959,
      2,
      192,
      0,
      4294828031,
      0,
      3825204735,
      0,
      123747807,
      0,
      65487,
      2,
      3,
      0,
      4092591615,
      0,
      1080049119,
      0,
      458703,
      2,
      3,
      2,
      0,
      0,
      2163244511,
      0,
      4227923919,
      0,
      4236247020,
      2,
      69,
      0,
      4284449919,
      0,
      851904,
      2,
      4,
      2,
      11,
      0,
      67076095,
      -1,
      2,
      70,
      0,
      1073741743,
      0,
      4093591391,
      -1,
      0,
      50331649,
      0,
      3265266687,
      2,
      35,
      0,
      4294844415,
      0,
      4278190047,
      2,
      22,
      2,
      126,
      -1,
      3,
      0,
      2,
      2,
      32,
      2,
      0,
      2,
      9,
      2,
      0,
      2,
      14,
      2,
      15,
      3,
      0,
      10,
      2,
      72,
      2,
      0,
      2,
      73,
      2,
      74,
      2,
      75,
      2,
      0,
      2,
      76,
      2,
      0,
      2,
      10,
      0,
      261632,
      2,
      19,
      3,
      0,
      2,
      2,
      12,
      2,
      4,
      3,
      0,
      18,
      2,
      77,
      2,
      5,
      3,
      0,
      2,
      2,
      78,
      0,
      2088959,
      2,
      30,
      2,
      8,
      0,
      909311,
      3,
      0,
      2,
      0,
      814743551,
      2,
      43,
      0,
      67057664,
      3,
      0,
      2,
      2,
      42,
      2,
      0,
      2,
      31,
      2,
      0,
      2,
      18,
      2,
      7,
      0,
      268374015,
      2,
      29,
      2,
      51,
      2,
      0,
      2,
      79,
      0,
      134153215,
      -1,
      2,
      6,
      2,
      0,
      2,
      7,
      0,
      2684354559,
      0,
      67044351,
      0,
      1073676416,
      -2,
      3,
      0,
      2,
      2,
      44,
      0,
      1046528,
      3,
      0,
      3,
      2,
      8,
      2,
      0,
      2,
      52,
      0,
      4294960127,
      2,
      9,
      2,
      40,
      2,
      10,
      0,
      4294377472,
      2,
      11,
      3,
      0,
      7,
      0,
      4227858431,
      3,
      0,
      8,
      2,
      12,
      2,
      0,
      2,
      81,
      2,
      9,
      2,
      0,
      2,
      82,
      2,
      83,
      2,
      84,
      -1,
      2,
      122,
      0,
      1048577,
      2,
      85,
      2,
      13,
      -1,
      2,
      13,
      0,
      131042,
      2,
      86,
      2,
      87,
      2,
      88,
      2,
      0,
      2,
      36,
      -83,
      2,
      0,
      2,
      54,
      2,
      7,
      3,
      0,
      4,
      0,
      1046559,
      2,
      0,
      2,
      14,
      2,
      0,
      0,
      2147516671,
      2,
      23,
      3,
      89,
      2,
      2,
      0,
      -16,
      2,
      90,
      0,
      524222462,
      2,
      4,
      2,
      0,
      0,
      4269801471,
      2,
      4,
      2,
      0,
      2,
      15,
      2,
      80,
      2,
      16,
      3,
      0,
      2,
      2,
      49,
      2,
      11,
      -1,
      2,
      17,
      -16,
      3,
      0,
      205,
      2,
      18,
      -2,
      3,
      0,
      655,
      2,
      19,
      3,
      0,
      36,
      2,
      71,
      -1,
      2,
      17,
      2,
      9,
      3,
      0,
      8,
      2,
      92,
      2,
      119,
      2,
      0,
      0,
      3220242431,
      3,
      0,
      3,
      2,
      20,
      2,
      21,
      2,
      93,
      3,
      0,
      2,
      2,
      94,
      2,
      0,
      2,
      95,
      2,
      21,
      2,
      0,
      2,
      26,
      2,
      0,
      2,
      8,
      3,
      0,
      2,
      0,
      67043391,
      0,
      3909091327,
      2,
      0,
      2,
      24,
      2,
      8,
      2,
      22,
      3,
      0,
      2,
      0,
      67076097,
      2,
      7,
      2,
      0,
      2,
      23,
      0,
      67059711,
      0,
      4236247039,
      3,
      0,
      2,
      0,
      939524103,
      0,
      8191999,
      2,
      98,
      2,
      99,
      2,
      15,
      2,
      33,
      3,
      0,
      3,
      0,
      67057663,
      3,
      0,
      349,
      2,
      100,
      2,
      101,
      2,
      6,
      -264,
      3,
      0,
      11,
      2,
      24,
      3,
      0,
      2,
      2,
      34,
      -1,
      0,
      3774349439,
      2,
      102,
      2,
      103,
      3,
      0,
      2,
      2,
      20,
      2,
      25,
      3,
      0,
      10,
      2,
      9,
      2,
      17,
      2,
      0,
      2,
      47,
      2,
      0,
      2,
      26,
      2,
      104,
      2,
      19,
      0,
      1638399,
      2,
      172,
      2,
      105,
      3,
      0,
      3,
      2,
      22,
      2,
      27,
      2,
      28,
      2,
      5,
      2,
      29,
      2,
      0,
      2,
      7,
      2,
      106,
      -1,
      2,
      107,
      2,
      108,
      2,
      109,
      -1,
      3,
      0,
      3,
      2,
      11,
      -2,
      2,
      0,
      2,
      30,
      -3,
      2,
      150,
      -4,
      2,
      22,
      2,
      0,
      2,
      38,
      0,
      1,
      2,
      0,
      2,
      63,
      2,
      31,
      2,
      11,
      2,
      9,
      2,
      0,
      2,
      110,
      -1,
      3,
      0,
      4,
      2,
      9,
      2,
      32,
      2,
      111,
      2,
      6,
      2,
      0,
      2,
      33,
      2,
      0,
      2,
      50,
      -4,
      3,
      0,
      9,
      2,
      23,
      2,
      18,
      2,
      26,
      -4,
      2,
      112,
      2,
      113,
      2,
      18,
      2,
      23,
      2,
      7,
      -2,
      2,
      114,
      2,
      18,
      2,
      34,
      -2,
      2,
      0,
      2,
      115,
      -2,
      0,
      4277137519,
      0,
      2269118463,
      -1,
      3,
      22,
      2,
      -1,
      2,
      35,
      2,
      39,
      2,
      0,
      3,
      18,
      2,
      2,
      37,
      2,
      20,
      -3,
      3,
      0,
      2,
      2,
      36,
      -1,
      2,
      0,
      2,
      37,
      2,
      0,
      2,
      37,
      2,
      0,
      2,
      48,
      -14,
      2,
      22,
      2,
      45,
      2,
      38,
      -4,
      2,
      23,
      3,
      0,
      2,
      2,
      39,
      0,
      2147549120,
      2,
      0,
      2,
      11,
      2,
      17,
      2,
      134,
      2,
      0,
      2,
      53,
      0,
      4294901872,
      0,
      5242879,
      3,
      0,
      2,
      0,
      402595359,
      -1,
      2,
      118,
      0,
      1090519039,
      -2,
      2,
      120,
      2,
      40,
      2,
      0,
      0,
      67045375,
      2,
      41,
      0,
      4226678271,
      0,
      3766565279,
      0,
      2039759,
      -4,
      3,
      0,
      2,
      0,
      3288270847,
      -1,
      3,
      0,
      2,
      0,
      67043519,
      -5,
      2,
      0,
      0,
      4282384383,
      0,
      1056964609,
      -1,
      3,
      0,
      2,
      0,
      67043345,
      -1,
      2,
      0,
      2,
      42,
      2,
      43,
      -1,
      2,
      10,
      2,
      44,
      -6,
      2,
      0,
      2,
      11,
      -3,
      3,
      0,
      2,
      0,
      2147484671,
      -5,
      2,
      123,
      0,
      4244635647,
      0,
      27,
      2,
      0,
      2,
      7,
      2,
      45,
      2,
      0,
      2,
      65,
      -1,
      2,
      0,
      2,
      42,
      -8,
      2,
      55,
      2,
      46,
      0,
      67043329,
      2,
      124,
      2,
      47,
      0,
      8388351,
      -2,
      2,
      125,
      0,
      3028287487,
      2,
      48,
      2,
      127,
      0,
      33259519,
      2,
      43,
      -9,
      2,
      23,
      -8,
      3,
      0,
      28,
      2,
      34,
      -3,
      3,
      0,
      3,
      2,
      49,
      3,
      0,
      6,
      2,
      50,
      -85,
      3,
      0,
      33,
      2,
      49,
      -126,
      3,
      0,
      18,
      2,
      39,
      -269,
      3,
      0,
      17,
      2,
      42,
      2,
      7,
      2,
      43,
      -2,
      2,
      17,
      2,
      51,
      2,
      0,
      2,
      23,
      0,
      67043343,
      2,
      129,
      2,
      19,
      -21,
      3,
      0,
      2,
      -4,
      3,
      0,
      2,
      0,
      4294936575,
      2,
      0,
      0,
      4294934783,
      -2,
      2,
      130,
      3,
      0,
      191,
      2,
      52,
      3,
      0,
      23,
      2,
      37,
      -296,
      3,
      0,
      8,
      2,
      7,
      -1,
      2,
      131,
      2,
      132,
      3,
      0,
      11,
      2,
      6,
      -72,
      3,
      0,
      3,
      2,
      133,
      0,
      1677656575,
      -166,
      0,
      4161266656,
      0,
      4071,
      0,
      15360,
      -4,
      0,
      28,
      -13,
      3,
      0,
      2,
      2,
      53,
      2,
      0,
      2,
      135,
      2,
      136,
      2,
      56,
      2,
      0,
      2,
      137,
      2,
      138,
      2,
      139,
      3,
      0,
      10,
      2,
      140,
      2,
      141,
      2,
      15,
      3,
      53,
      2,
      3,
      54,
      2,
      3,
      55,
      2,
      0,
      4294954999,
      2,
      0,
      -16,
      2,
      0,
      2,
      91,
      2,
      0,
      0,
      2105343,
      0,
      4160749584,
      0,
      65534,
      -42,
      0,
      4194303871,
      0,
      2011,
      -6,
      2,
      0,
      0,
      1073684479,
      0,
      17407,
      -11,
      2,
      0,
      2,
      34,
      -40,
      3,
      0,
      6,
      0,
      8323103,
      -1,
      3,
      0,
      2,
      2,
      44,
      -37,
      2,
      56,
      2,
      144,
      2,
      145,
      2,
      146,
      2,
      147,
      2,
      148,
      -138,
      3,
      0,
      1334,
      2,
      23,
      -1,
      3,
      0,
      129,
      2,
      30,
      3,
      0,
      6,
      2,
      9,
      3,
      0,
      180,
      2,
      149,
      3,
      0,
      233,
      0,
      1,
      -96,
      3,
      0,
      16,
      2,
      9,
      -22583,
      3,
      0,
      7,
      2,
      19,
      -6130,
      3,
      5,
      2,
      -1,
      0,
      69207040,
      3,
      46,
      2,
      3,
      0,
      14,
      2,
      57,
      2,
      58,
      -3,
      0,
      3168731136,
      0,
      4294956864,
      2,
      1,
      2,
      0,
      2,
      59,
      3,
      0,
      4,
      0,
      4294966275,
      3,
      0,
      4,
      2,
      16,
      2,
      60,
      2,
      0,
      2,
      36,
      -1,
      2,
      17,
      2,
      61,
      -1,
      2,
      0,
      2,
      62,
      0,
      4294885376,
      3,
      0,
      2,
      0,
      3145727,
      0,
      2617294944,
      0,
      4294770688,
      2,
      19,
      2,
      63,
      3,
      0,
      2,
      0,
      131135,
      2,
      96,
      0,
      70256639,
      0,
      71303167,
      0,
      272,
      2,
      42,
      2,
      62,
      -1,
      2,
      64,
      -2,
      2,
      97,
      2,
      65,
      0,
      4278255616,
      0,
      4294836227,
      0,
      4294549473,
      0,
      600178175,
      0,
      2952806400,
      0,
      268632067,
      0,
      4294543328,
      0,
      57540095,
      0,
      1577058304,
      0,
      1835008,
      0,
      4294688736,
      2,
      66,
      2,
      67,
      0,
      33554435,
      2,
      121,
      2,
      66,
      2,
      151,
      0,
      131075,
      0,
      3594373096,
      0,
      67094296,
      2,
      67,
      -1,
      2,
      68,
      0,
      603979263,
      2,
      160,
      0,
      3,
      0,
      4294828001,
      0,
      602930687,
      2,
      181,
      0,
      393219,
      2,
      68,
      0,
      671088639,
      0,
      2154840064,
      0,
      4227858435,
      0,
      4236247008,
      2,
      69,
      2,
      39,
      -1,
      2,
      4,
      0,
      917503,
      2,
      39,
      -1,
      2,
      70,
      0,
      537788335,
      0,
      4026531935,
      -1,
      0,
      1,
      -1,
      2,
      35,
      2,
      71,
      0,
      7936,
      -3,
      2,
      0,
      0,
      2147485695,
      0,
      1010761728,
      0,
      4292984930,
      0,
      16387,
      2,
      0,
      2,
      14,
      2,
      15,
      3,
      0,
      10,
      2,
      72,
      2,
      0,
      2,
      73,
      2,
      74,
      2,
      75,
      2,
      0,
      2,
      76,
      2,
      0,
      2,
      11,
      -1,
      2,
      19,
      3,
      0,
      2,
      2,
      12,
      2,
      4,
      3,
      0,
      18,
      2,
      77,
      2,
      5,
      3,
      0,
      2,
      2,
      78,
      0,
      253951,
      3,
      20,
      2,
      0,
      122879,
      2,
      0,
      2,
      8,
      0,
      276824064,
      -2,
      3,
      0,
      2,
      2,
      42,
      2,
      0,
      0,
      4294903295,
      2,
      0,
      2,
      18,
      2,
      7,
      -1,
      2,
      17,
      2,
      51,
      2,
      0,
      2,
      79,
      2,
      43,
      -1,
      2,
      23,
      2,
      0,
      2,
      30,
      -2,
      0,
      128,
      -2,
      2,
      80,
      2,
      8,
      0,
      4064,
      -1,
      2,
      117,
      0,
      4227907585,
      2,
      0,
      2,
      116,
      2,
      0,
      2,
      50,
      0,
      4227915776,
      2,
      9,
      2,
      40,
      2,
      10,
      -1,
      0,
      74440192,
      3,
      0,
      6,
      -2,
      3,
      0,
      8,
      2,
      12,
      2,
      0,
      2,
      81,
      2,
      9,
      2,
      0,
      2,
      82,
      2,
      83,
      2,
      84,
      -3,
      2,
      85,
      2,
      13,
      -3,
      2,
      86,
      2,
      87,
      2,
      88,
      2,
      0,
      2,
      36,
      -83,
      2,
      0,
      2,
      54,
      2,
      7,
      3,
      0,
      4,
      0,
      817183,
      2,
      0,
      2,
      14,
      2,
      0,
      0,
      33023,
      2,
      23,
      3,
      89,
      2,
      -17,
      2,
      90,
      0,
      524157950,
      2,
      4,
      2,
      0,
      2,
      91,
      2,
      4,
      2,
      0,
      2,
      15,
      2,
      80,
      2,
      16,
      3,
      0,
      2,
      2,
      49,
      2,
      11,
      -1,
      2,
      17,
      -16,
      3,
      0,
      205,
      2,
      18,
      -2,
      3,
      0,
      655,
      2,
      19,
      3,
      0,
      36,
      2,
      71,
      -1,
      2,
      17,
      2,
      9,
      3,
      0,
      8,
      2,
      92,
      0,
      3072,
      2,
      0,
      0,
      2147516415,
      2,
      9,
      3,
      0,
      2,
      2,
      19,
      2,
      21,
      2,
      93,
      3,
      0,
      2,
      2,
      94,
      2,
      0,
      2,
      95,
      2,
      21,
      0,
      4294965179,
      0,
      7,
      2,
      0,
      2,
      8,
      2,
      93,
      2,
      8,
      -1,
      0,
      1761345536,
      2,
      96,
      0,
      4294901823,
      2,
      39,
      2,
      22,
      2,
      97,
      2,
      37,
      2,
      165,
      0,
      2080440287,
      2,
      0,
      2,
      36,
      2,
      142,
      0,
      3296722943,
      2,
      0,
      0,
      1046675455,
      0,
      939524101,
      0,
      1837055,
      2,
      98,
      2,
      99,
      2,
      15,
      2,
      33,
      3,
      0,
      3,
      0,
      7,
      3,
      0,
      349,
      2,
      100,
      2,
      101,
      2,
      6,
      -264,
      3,
      0,
      11,
      2,
      24,
      3,
      0,
      2,
      2,
      34,
      -1,
      0,
      2700607615,
      2,
      102,
      2,
      103,
      3,
      0,
      2,
      2,
      20,
      2,
      25,
      3,
      0,
      10,
      2,
      9,
      2,
      17,
      2,
      0,
      2,
      47,
      2,
      0,
      2,
      26,
      2,
      104,
      -3,
      2,
      105,
      3,
      0,
      3,
      2,
      22,
      -1,
      3,
      5,
      2,
      2,
      29,
      2,
      0,
      2,
      7,
      2,
      106,
      -1,
      2,
      107,
      2,
      108,
      2,
      109,
      -1,
      3,
      0,
      3,
      2,
      11,
      -2,
      2,
      0,
      2,
      30,
      -8,
      2,
      22,
      2,
      0,
      2,
      38,
      -1,
      2,
      0,
      2,
      63,
      2,
      31,
      2,
      18,
      2,
      9,
      2,
      0,
      2,
      110,
      -1,
      3,
      0,
      4,
      2,
      9,
      2,
      17,
      2,
      111,
      2,
      6,
      2,
      0,
      2,
      33,
      2,
      0,
      2,
      50,
      -4,
      3,
      0,
      9,
      2,
      23,
      2,
      18,
      2,
      26,
      -4,
      2,
      112,
      2,
      113,
      2,
      18,
      2,
      23,
      2,
      7,
      -2,
      2,
      114,
      2,
      18,
      2,
      34,
      -2,
      2,
      0,
      2,
      115,
      -2,
      0,
      4277075969,
      2,
      18,
      -1,
      3,
      22,
      2,
      -1,
      2,
      35,
      2,
      143,
      2,
      0,
      3,
      18,
      2,
      2,
      37,
      2,
      20,
      -3,
      3,
      0,
      2,
      2,
      36,
      -1,
      2,
      0,
      2,
      37,
      2,
      0,
      2,
      37,
      2,
      0,
      2,
      50,
      -14,
      2,
      22,
      2,
      45,
      2,
      116,
      -4,
      2,
      23,
      2,
      117,
      2,
      52,
      -2,
      2,
      117,
      2,
      19,
      2,
      17,
      2,
      36,
      2,
      117,
      2,
      39,
      0,
      4294901776,
      0,
      4718591,
      2,
      117,
      2,
      37,
      0,
      335544350,
      -1,
      2,
      118,
      2,
      119,
      -2,
      2,
      120,
      2,
      40,
      2,
      7,
      -1,
      2,
      121,
      2,
      66,
      0,
      3758161920,
      0,
      3,
      -4,
      2,
      0,
      2,
      30,
      0,
      2147485568,
      -1,
      2,
      0,
      2,
      19,
      0,
      176,
      -5,
      2,
      0,
      2,
      49,
      2,
      183,
      -1,
      2,
      0,
      2,
      19,
      2,
      195,
      -1,
      2,
      0,
      0,
      16779263,
      -2,
      2,
      11,
      -7,
      2,
      0,
      2,
      119,
      -3,
      3,
      0,
      2,
      2,
      122,
      -5,
      2,
      123,
      2,
      38,
      0,
      10,
      0,
      4294965249,
      0,
      67633151,
      0,
      4026597376,
      2,
      0,
      0,
      536871935,
      -1,
      2,
      0,
      2,
      42,
      -8,
      2,
      55,
      2,
      49,
      0,
      1,
      2,
      124,
      2,
      19,
      -3,
      2,
      125,
      2,
      38,
      2,
      126,
      2,
      127,
      0,
      16778239,
      -10,
      2,
      37,
      -8,
      3,
      0,
      28,
      2,
      34,
      -3,
      3,
      0,
      3,
      2,
      49,
      3,
      0,
      6,
      2,
      50,
      -85,
      3,
      0,
      33,
      2,
      49,
      -126,
      3,
      0,
      18,
      2,
      39,
      -269,
      3,
      0,
      17,
      2,
      42,
      2,
      7,
      -3,
      2,
      17,
      2,
      128,
      2,
      0,
      2,
      19,
      2,
      50,
      2,
      129,
      2,
      19,
      -21,
      3,
      0,
      2,
      -4,
      3,
      0,
      2,
      0,
      67583,
      -1,
      2,
      25,
      -2,
      2,
      130,
      3,
      0,
      191,
      2,
      52,
      3,
      0,
      23,
      2,
      37,
      -296,
      3,
      0,
      8,
      2,
      7,
      -1,
      2,
      131,
      2,
      132,
      3,
      0,
      11,
      2,
      6,
      -72,
      3,
      0,
      3,
      2,
      133,
      2,
      134,
      -187,
      3,
      0,
      2,
      2,
      53,
      2,
      0,
      2,
      135,
      2,
      136,
      2,
      56,
      2,
      0,
      2,
      137,
      2,
      138,
      2,
      139,
      3,
      0,
      10,
      2,
      140,
      2,
      141,
      2,
      15,
      3,
      53,
      2,
      3,
      54,
      2,
      3,
      55,
      2,
      2,
      142,
      -73,
      2,
      0,
      0,
      1065361407,
      0,
      16384,
      -11,
      2,
      0,
      2,
      119,
      -40,
      3,
      0,
      6,
      2,
      143,
      -1,
      3,
      0,
      2,
      0,
      2063,
      -37,
      2,
      56,
      2,
      144,
      2,
      145,
      2,
      146,
      2,
      147,
      2,
      148,
      -138,
      3,
      0,
      1334,
      2,
      23,
      -1,
      3,
      0,
      129,
      2,
      30,
      3,
      0,
      6,
      2,
      9,
      3,
      0,
      180,
      2,
      149,
      3,
      0,
      233,
      0,
      1,
      -96,
      3,
      0,
      16,
      2,
      9,
      -28719,
      2,
      0,
      0,
      1,
      -1,
      2,
      122,
      2,
      0,
      0,
      8193,
      -21,
      2,
      191,
      0,
      10255,
      0,
      4,
      -11,
      2,
      67,
      2,
      170,
      -1,
      0,
      71680,
      -1,
      2,
      161,
      0,
      4292900864,
      0,
      805306431,
      -5,
      2,
      150,
      -1,
      2,
      177,
      -1,
      2,
      200,
      -2,
      2,
      124,
      -1,
      2,
      154,
      -1,
      2,
      157,
      2,
      151,
      2,
      164,
      2,
      0,
      0,
      3223322624,
      2,
      37,
      0,
      4,
      -4,
      2,
      189,
      0,
      205128192,
      0,
      1333757536,
      0,
      2147483696,
      0,
      423953,
      0,
      747766272,
      0,
      2717763192,
      0,
      4286578751,
      0,
      278545,
      2,
      152,
      0,
      4294886464,
      0,
      33292336,
      0,
      417809,
      2,
      152,
      0,
      1329579616,
      0,
      4278190128,
      0,
      700594195,
      0,
      1006647527,
      0,
      4286497336,
      0,
      4160749631,
      2,
      153,
      0,
      469762560,
      0,
      4171219488,
      0,
      8323120,
      2,
      153,
      0,
      202375680,
      0,
      3214918176,
      0,
      4294508592,
      0,
      139280,
      -1,
      0,
      983584,
      0,
      48,
      0,
      58720275,
      0,
      3489923072,
      0,
      10517376,
      0,
      4293066815,
      0,
      1,
      0,
      2013265920,
      2,
      176,
      2,
      0,
      0,
      2089,
      0,
      3221225552,
      0,
      201375904,
      2,
      0,
      -2,
      0,
      256,
      0,
      122880,
      0,
      16777216,
      2,
      150,
      0,
      4160757760,
      2,
      0,
      -6,
      2,
      166,
      -11,
      0,
      3263218176,
      -1,
      0,
      49664,
      0,
      2160197632,
      0,
      8388802,
      -1,
      0,
      12713984,
      -1,
      2,
      154,
      2,
      159,
      2,
      178,
      -2,
      2,
      162,
      -20,
      0,
      3758096385,
      -2,
      2,
      155,
      0,
      4292878336,
      2,
      21,
      2,
      168,
      0,
      4294057984,
      -2,
      2,
      163,
      2,
      156,
      2,
      174,
      -2,
      2,
      155,
      -1,
      2,
      180,
      -1,
      2,
      169,
      2,
      122,
      0,
      4026593280,
      0,
      14,
      0,
      4292919296,
      -1,
      2,
      158,
      0,
      939588608,
      -1,
      0,
      805306368,
      -1,
      2,
      122,
      0,
      1610612736,
      2,
      156,
      2,
      157,
      3,
      0,
      2,
      -2,
      2,
      158,
      2,
      159,
      -3,
      0,
      267386880,
      -1,
      2,
      160,
      0,
      7168,
      -1,
      0,
      65024,
      2,
      154,
      2,
      161,
      2,
      171,
      -7,
      2,
      167,
      -8,
      2,
      162,
      -1,
      0,
      1426112704,
      2,
      163,
      -1,
      2,
      186,
      0,
      271581216,
      0,
      2149777408,
      2,
      19,
      2,
      161,
      2,
      122,
      0,
      851967,
      0,
      3758129152,
      -1,
      2,
      19,
      2,
      179,
      -4,
      2,
      158,
      -20,
      2,
      193,
      2,
      164,
      -56,
      0,
      3145728,
      2,
      185,
      -4,
      2,
      165,
      2,
      122,
      -4,
      0,
      32505856,
      -1,
      2,
      166,
      -1,
      0,
      2147385088,
      2,
      21,
      1,
      2155905152,
      2,
      -3,
      2,
      17,
      2,
      0,
      2,
      167,
      -2,
      2,
      168,
      -6,
      2,
      169,
      0,
      4026597375,
      0,
      1,
      -1,
      0,
      1,
      -1,
      2,
      170,
      -3,
      2,
      143,
      2,
      67,
      -2,
      2,
      165,
      2,
      171,
      -1,
      2,
      175,
      2,
      122,
      -6,
      2,
      122,
      -213,
      2,
      169,
      -657,
      2,
      17,
      -36,
      2,
      172,
      -1,
      2,
      187,
      -10,
      2,
      198,
      -5,
      2,
      173,
      -6,
      0,
      4294967171,
      2,
      23,
      -1,
      0,
      4227919872,
      -1,
      2,
      173,
      -2,
      0,
      4227874752,
      -3,
      0,
      2146435072,
      2,
      159,
      -2,
      0,
      1006649344,
      2,
      122,
      -1,
      2,
      21,
      0,
      201375744,
      -3,
      0,
      134217720,
      2,
      21,
      0,
      4286677377,
      0,
      32896,
      -1,
      2,
      161,
      -3,
      2,
      174,
      -349,
      2,
      175,
      0,
      1920,
      2,
      176,
      3,
      0,
      264,
      -11,
      2,
      177,
      -2,
      2,
      178,
      2,
      0,
      0,
      520617856,
      0,
      2692743168,
      0,
      36,
      -3,
      0,
      524284,
      -11,
      2,
      19,
      -1,
      2,
      184,
      -1,
      2,
      182,
      0,
      3221291007,
      2,
      178,
      -1,
      0,
      524288,
      0,
      2158720,
      -3,
      2,
      159,
      0,
      1,
      -4,
      2,
      122,
      0,
      3808625411,
      0,
      3489628288,
      2,
      199,
      0,
      1207959680,
      0,
      3221274624,
      2,
      0,
      -3,
      2,
      171,
      0,
      120,
      0,
      7340032,
      -2,
      0,
      4026564608,
      2,
      4,
      2,
      19,
      2,
      163,
      3,
      0,
      4,
      2,
      159,
      -1,
      2,
      179,
      2,
      176,
      -1,
      0,
      8176,
      2,
      180,
      2,
      171,
      2,
      181,
      -1,
      0,
      4290773232,
      2,
      0,
      -4,
      2,
      163,
      2,
      188,
      0,
      15728640,
      2,
      176,
      -1,
      2,
      161,
      -1,
      0,
      4294934512,
      3,
      0,
      4,
      -9,
      2,
      21,
      2,
      169,
      2,
      182,
      3,
      0,
      4,
      0,
      704,
      0,
      1849688064,
      0,
      4194304,
      -1,
      2,
      122,
      0,
      4294901887,
      2,
      0,
      0,
      130547712,
      0,
      1879048192,
      2,
      197,
      3,
      0,
      2,
      -1,
      2,
      183,
      2,
      184,
      -1,
      0,
      17829776,
      0,
      2025848832,
      0,
      4261477888,
      -2,
      2,
      0,
      -1,
      0,
      4286580608,
      -1,
      0,
      29360128,
      2,
      185,
      0,
      16252928,
      0,
      3791388672,
      2,
      40,
      3,
      0,
      2,
      -2,
      2,
      194,
      2,
      0,
      -1,
      2,
      25,
      -1,
      0,
      66584576,
      -1,
      2,
      190,
      3,
      0,
      9,
      2,
      122,
      3,
      0,
      4,
      -1,
      2,
      161,
      2,
      178,
      3,
      0,
      4,
      2,
      21,
      -2,
      0,
      245760,
      0,
      2147418112,
      -1,
      2,
      150,
      2,
      202,
      0,
      4227923456,
      -1,
      2,
      186,
      2,
      187,
      2,
      21,
      -2,
      2,
      177,
      0,
      4292870145,
      0,
      262144,
      2,
      122,
      3,
      0,
      2,
      0,
      1073758848,
      2,
      188,
      -1,
      0,
      4227921920,
      2,
      189,
      0,
      68289024,
      0,
      528402016,
      0,
      4292927536,
      3,
      0,
      4,
      -2,
      0,
      335544320,
      2,
      0,
      -2,
      2,
      190,
      3,
      0,
      5,
      -1,
      2,
      185,
      2,
      163,
      2,
      0,
      -2,
      0,
      4227923936,
      2,
      63,
      -1,
      2,
      155,
      2,
      96,
      2,
      0,
      2,
      154,
      2,
      158,
      3,
      0,
      6,
      -1,
      2,
      176,
      3,
      0,
      3,
      -2,
      0,
      2146959360,
      3,
      0,
      5,
      0,
      768,
      2,
      191,
      2,
      80,
      -2,
      2,
      161,
      -2,
      2,
      117,
      -1,
      2,
      155,
      3,
      0,
      8,
      0,
      512,
      0,
      8388608,
      2,
      192,
      2,
      172,
      2,
      184,
      0,
      4286578944,
      3,
      0,
      2,
      0,
      1152,
      0,
      1266679808,
      2,
      190,
      0,
      576,
      0,
      4261707776,
      2,
      96,
      3,
      0,
      9,
      2,
      155,
      3,
      0,
      6,
      -1,
      0,
      2147221504,
      -28,
      2,
      178,
      3,
      0,
      3,
      -3,
      0,
      4292902912,
      -6,
      2,
      97,
      3,
      0,
      85,
      -33,
      0,
      4294934528,
      3,
      0,
      126,
      -18,
      2,
      193,
      3,
      0,
      269,
      -17,
      2,
      155,
      2,
      122,
      2,
      196,
      3,
      0,
      2,
      2,
      19,
      0,
      4290822144,
      -2,
      0,
      67174336,
      0,
      520093700,
      2,
      17,
      3,
      0,
      21,
      -2,
      2,
      171,
      3,
      0,
      3,
      -2,
      0,
      30720,
      -1,
      0,
      32512,
      3,
      0,
      2,
      2,
      97,
      -191,
      2,
      173,
      -23,
      2,
      25,
      3,
      0,
      296,
      -8,
      2,
      122,
      2,
      0,
      0,
      4294508543,
      0,
      65295,
      -11,
      2,
      176,
      3,
      0,
      72,
      -3,
      0,
      3758159872,
      0,
      201391616,
      3,
      0,
      155,
      -7,
      2,
      169,
      -1,
      0,
      384,
      -1,
      0,
      133693440,
      -3,
      2,
      194,
      -2,
      2,
      29,
      3,
      0,
      4,
      2,
      168,
      -2,
      2,
      21,
      2,
      155,
      3,
      0,
      4,
      -2,
      2,
      186,
      -1,
      2,
      150,
      0,
      335552923,
      2,
      195,
      -1,
      0,
      538974272,
      0,
      2214592512,
      0,
      132000,
      -10,
      0,
      192,
      -8,
      0,
      12288,
      -21,
      0,
      134213632,
      0,
      4294901761,
      3,
      0,
      42,
      0,
      100663424,
      0,
      4294965284,
      3,
      0,
      6,
      -1,
      0,
      3221282816,
      2,
      196,
      3,
      0,
      11,
      -1,
      2,
      197,
      3,
      0,
      40,
      -6,
      0,
      4286578784,
      2,
      0,
      -2,
      0,
      1006694400,
      3,
      0,
      24,
      2,
      38,
      -1,
      2,
      201,
      3,
      0,
      2,
      0,
      1,
      2,
      163,
      3,
      0,
      6,
      2,
      195,
      0,
      4110942569,
      0,
      1432950139,
      0,
      2701658217,
      0,
      4026532864,
      0,
      4026532881,
      2,
      0,
      2,
      47,
      3,
      0,
      8,
      -1,
      2,
      158,
      -2,
      2,
      168,
      0,
      98304,
      0,
      65537,
      2,
      169,
      2,
      172,
      -2,
      2,
      172,
      -1,
      2,
      63,
      2,
      0,
      2,
      116,
      0,
      65528,
      2,
      176,
      0,
      4294770176,
      2,
      29,
      3,
      0,
      4,
      -30,
      2,
      169,
      0,
      4160806912,
      -3,
      2,
      168,
      -2,
      2,
      155,
      2,
      198,
      2,
      158,
      -1,
      2,
      190,
      -1,
      2,
      161,
      0,
      4294950912,
      3,
      0,
      2,
      2,
      199,
      -2,
      0,
      58982400,
      -1,
      0,
      14360,
      2,
      200,
      -3,
      2,
      168,
      0,
      4176527360,
      0,
      4290838520,
      3,
      0,
      43,
      -1334,
      2,
      21,
      2,
      0,
      -129,
      2,
      201,
      -6,
      2,
      163,
      -180,
      2,
      202,
      -233,
      2,
      4,
      3,
      0,
      96,
      -16,
      2,
      163,
      3,
      0,
      22583,
      -7,
      2,
      17,
      3,
      0,
      6128
  ], [
      4294967295,
      4294967291,
      4092460543,
      4294828015,
      4294967294,
      134217726,
      268435455,
      2147483647,
      1048575,
      1073741823,
      3892314111,
      134217727,
      1061158911,
      536805376,
      4294910143,
      4160749567,
      4294901759,
      4294901760,
      4194303,
      65535,
      262143,
      4286578688,
      536870911,
      8388607,
      4294918143,
      4294443008,
      255,
      67043328,
      2281701374,
      4294967232,
      2097151,
      4294903807,
      4294902783,
      4294902015,
      67108863,
      4294967039,
      511,
      524287,
      131071,
      127,
      4294902271,
      4294549487,
      33554431,
      1023,
      67047423,
      4294901888,
      4286578687,
      4294770687,
      67043583,
      32767,
      15,
      2047999,
      16777215,
      4292870143,
      4294934527,
      4294966783,
      4294967279,
      262083,
      20511,
      4290772991,
      41943039,
      493567,
      2047,
      4294959104,
      1071644671,
      603979775,
      602799615,
      65536,
      4294828000,
      805044223,
      4294965206,
      8191,
      1031749119,
      4294917631,
      2134769663,
      4286578493,
      4282253311,
      4294942719,
      33540095,
      4294905855,
      4294967264,
      2868854591,
      1608515583,
      265232348,
      534519807,
      2147614720,
      1060109444,
      4093640016,
      17376,
      2139062143,
      224,
      4169138175,
      4294909951,
      4294967292,
      4294965759,
      124,
      4294966272,
      4294967280,
      8289918,
      4294934399,
      4294901775,
      4294965375,
      1602223615,
      4294967259,
      268369920,
      4292804608,
      486341884,
      4294963199,
      3087007615,
      1073692671,
      4128527,
      4279238655,
      4294966591,
      2445279231,
      3670015,
      3238002687,
      63,
      4294967288,
      4294705151,
      4095,
      3221208447,
      4294549472,
      2147483648,
      4294966527,
      4294705152,
      4294966143,
      64,
      4294966719,
      16383,
      3774873592,
      11,
      458752,
      4294902000,
      536807423,
      67043839,
      3758096383,
      3959414372,
      3755993023,
      2080374783,
      4294835295,
      4294967103,
      4160749565,
      4087,
      31,
      184024726,
      2862017156,
      1593309078,
      268434431,
      268434414,
      4294901763,
      536870912,
      2952790016,
      202506752,
      139264,
      402653184,
      4261412864,
      4227922944,
      2147532800,
      61440,
      3758096384,
      117440512,
      65280,
      3233808384,
      3221225472,
      4294965248,
      32768,
      57152,
      67108864,
      4293918720,
      4290772992,
      25165824,
      4160749568,
      57344,
      4278190080,
      4227907584,
      65520,
      4026531840,
      49152,
      4227858432,
      4294836224,
      63488,
      1073741824,
      4294967040,
      251658240,
      196608,
      12582912,
      2097152,
      65408,
      64512,
      417808,
      4227923712,
      50331648,
      65472,
      4294967168,
      4294966784,
      16,
      4294917120,
      2080374784,
      4294963200,
      4096,
      6144,
      4292870144,
      65532
  ]);

  const CharTypes = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1 | 2,
      0,
      0,
      0,
      0,
      0,
      0,
      256,
      0,
      256 | 2048,
      512,
      0,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 16,
      2 | 8 | 32 | 16,
      2 | 8 | 32 | 16,
      0,
      0,
      1024,
      0,
      0,
      0,
      0,
      1 | 2 | 16,
      1 | 2 | 16,
      1 | 2 | 16,
      1 | 2 | 16,
      1 | 2 | 16 | 512,
      1 | 2 | 16,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      0,
      1,
      0,
      0,
      1 | 2 | 64 | 512,
      0,
      1 | 2 | 16,
      1 | 2 | 16,
      1 | 2 | 16,
      1 | 2 | 16,
      1 | 2 | 16 | 512,
      1 | 2 | 16,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2 | 512,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1 | 2,
      1024,
      0,
      0,
      0,
      0
  ];
  const identifierStart = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0
  ];
  const identifierPart = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0
  ];
  function isIdentifierStart(code) {
      return code <= 0x7f ? identifierStart[code] : (unicodeLookup[(code >>> 5) + 34816] >>> code) & 31 & 1;
  }
  function isIdentifierPart(code) {
      return code <= 0x7f
          ? identifierPart[code]
          : (unicodeLookup[(code >>> 5) + 0] >>> code) & 31 & 1 ||
              (code === 8204 || code === 8205);
  }

  function advance(parser) {
      parser.column++;
      return (parser.nextCodePoint = parser.source.charCodeAt(++parser.index));
  }
  function fromCodePoint(codePoint) {
      return codePoint <= 65535
          ? String.fromCharCode(codePoint)
          : String.fromCharCode(codePoint >>> 10) + String.fromCharCode(codePoint & 0x3ff);
  }
  function toHex(code) {
      return code < 65 ? code - 48 : (code - 65 + 10) & 0xf;
  }
  function consumeMultiUnitCodePoint(parser, hi) {
      if ((hi & 0xfc00) !== 0xd800)
          return 0;
      const lo = parser.source.charCodeAt(parser.index + 1);
      if ((lo & 0xfc00) !== 0xdc00)
          return 0;
      hi = parser.nextCodePoint = 0x10000 + ((hi & 0x3ff) << 10) + (lo & 0x3ff);
      if (((unicodeLookup[(hi >>> 5) + 0] >>> hi) & 31 & 1) === 0) {
          return -2;
      }
      parser.index++;
      return 1;
  }
  function consumeLineFeed(parser, lastIsCR) {
      parser.nextCodePoint = parser.source.charCodeAt(++parser.index);
      parser.precedingLineBreak = 1;
      if (lastIsCR === 0) {
          parser.column = 0;
          parser.line++;
      }
  }
  function advanceNewline(parser) {
      parser.nextCodePoint = parser.source.charCodeAt(++parser.index);
      parser.precedingLineBreak = 1;
      parser.column = 0;
      parser.line++;
  }
  function isExoticECMAScriptWhitespace(code) {
      return (code === 160 ||
          code === 65279 ||
          code === 133 ||
          code === 5760 ||
          (code >= 8192 && code <= 8203) ||
          code === 8239 ||
          code === 8287 ||
          code === 12288 ||
          code === 65519);
  }

  const errorMessages = {
      [0]: 'Unexpected',
      [1]: 'Unexpected token %0',
      [2]: 'Expected %0',
      [3]: 'Invalid character',
      [4]: 'Invalid SMP character',
      [5]: 'Octal numeric literals and escape characters not allowed in strict mode',
      [6]: 'Invalid hexadecimal escape sequence',
      [7]: 'Invalid code point %0',
      [8]: 'Invalid Unicode escape sequence',
      [9]: 'Only unicode escapes are legal in identifier names',
      [10]: 'Only one underscore is allowed as numeric separato',
      [30]: "Numeric separators '_' are not allowed in numbers that start with '0'",
      [11]: "Missing hexadecimal digits after '0x'",
      [12]: "Missing octal digits after '0o'",
      [13]: "Missing binary digits after '0b'",
      [14]: 'Numeric separators are not allowed at the end of numeric literals',
      [15]: 'Non-number found after exponent indicator',
      [16]: 'Unexpected identifier after numeric literal',
      [17]: 'Unterminated string literal',
      [18]: 'Unterminated template literal',
      [19]: 'Octal escape sequences are not allowed in template strings',
      [20]: 'Octal escape sequences are not allowed in strict mode',
      [21]: 'Escapes \\8 or \\9 are not syntactically valid escapes',
      [22]: 'Unicode escape sequence value is higher than 0x10FFFF',
      [23]: "Duplicate regular expression flag '%0'",
      [24]: 'Unexpected regular expression flag',
      [25]: 'Unterminated regular expression',
      [28]: 'Invalid BigInt syntax',
      [29]: 'Expected a closing curly brace `}`',
      [26]: '`let \n [` is a restricted production at the start of a statement',
      [31]: 'Invalid unescaped line break in string literal',
      [32]: 'Reached end of script in the middle of an escape sequence',
      [33]: 'HTML comments are only allowed with web compability (Annex B)',
      [34]: 'Multiline comment was not closed properly',
      [27]: 'Coalescing and logical operators used together in the same expression must be disambiguated with parentheses',
      [35]: 'Property or signature expected',
      [36]: "Classes may not have a non-static field named 'constructor'",
      [37]: "'readonly' type modifier is only permitted on array and tuple literal types",
      [38]: "%0 modifier must precede '%1' modifier",
      [39]: 'Accessibility modifier already seen',
      [40]: '%0 modifier already seen',
      [64]: 'Member access on super must be in a method',
      [65]: 'Calls to super must be in the "constructor" method of a class expression or class declaration that has a superclass',
      [66]: 'Class constructor may not be a %0',
      [67]: 'Duplicate constructor method in class',
      [42]: "%0 modifier cannot be used with 'abstract' modifier",
      [41]: 'Abstract methods can only appear within an abstract class',
      [43]: 'Current method cannot have an implementation because it is marked abstract',
      [44]: "'readonly' modifier can only appear on a property declaration or index signature",
      [45]: 'Function implementation is missing or not immediately following the declaration',
      [46]: 'An abstract accessor cannot have an implementation',
      [47]: 'Unexpected token. A constructor, method, accessor, or property was expected',
      [48]: "'A definite assignment assertion '!' is not permitted in this context",
      [49]: '%0 modifier cannot appear on an index signature',
      [50]: 'An index signature parameter cannot have a question mark',
      [51]: 'An index signature must have a type annotation',
      [52]: 'An index signature must have exactly one parameter',
      [53]: 'An index signature cannot have a rest parameter',
      [55]: "'static' modifier cannot appear on parameter",
      [56]: 'Expression expected',
      [57]: "'static' modifier cannot appear on %0",
      [58]: 'An index signature parameter type cannot be a union type. Consider using a mapped object type instead',
      [59]: "'%0' is a reserved word in strict mode. Class definitions are automatically in strict mode",
      [60]: 'A parameter property is only allowed in a constructor implementation',
      [61]: "'abstract' modifier can only appear on a class, method, or property declaration",
      [62]: 'Unexpected strict mode reserved word',
      [63]: 'Async modifier cannot be used here',
      [68]: 'An implementation cannot be declared in ambient contexts',
      [69]: 'Constructor implementation is missing',
      [70]: 'Generators are not allowed in an ambient context',
      [71]: 'Enum member expected',
      [72]: 'An enum member cannot have a numeric name',
      [73]: 'A parameter initializer is only allowed in a function or constructor implementation',
      [74]: '%0 functions must have exactly %1 argument%2',
      [75]: 'Setter function argument must not be a rest parameter',
      [76]: 'Invalid new target',
      [77]: "A computed property name must be of type 'string', 'number', 'symbol' or 'any",
      [78]: "An index signature parameter type must be 'string' or 'number'",
      [79]: 'JSDoc types can only be used inside documentation comments',
      [80]: 'Implements list cannot be empty',
      [81]: 'A required element cannot follow an optional element',
      [82]: 'A rest element must be last in a tuple type',
      [83]: '%0 declaration must have a name in this context',
      [84]: 'An export assignment cannot have modifiers',
      [86]: 'Block body arrows can not be immediately invoked without a group',
      [85]: 'Block body arrows can not be immediately accessed without a group',
      [87]: 'An arrow function can not have a postfix update operator',
      [88]: 'An import declaration can only be used in a namespace or module',
      [89]: 'Missing initializer in %0 declaration',
      [90]: "'for-%0' loop head declarations can not have an initializer",
      [91]: "'this' cannot be referenced in a static property initializer.",
      [93]: 'JSX value should be either an expression or a quoted JSX text',
      [92]: 'Expected corresponding JSX closing tag for %0',
      [95]: 'Adjacent JSX elements must be wrapped in an enclosing tag',
      [94]: "JSX attributes must only be assigned a non-empty 'expression'",
      [96]: 'Invalid keyword',
      [97]: 'Await is only valid in async functions',
      [98]: "'%0' may not be used as an identifier in this context",
      [99]: 'Decorators are not valid here',
      [100]: 'Decorators are not valid here'
  };
  function report(parser, _context, type, _early, ...params) {
      const message = errorMessages[type].replace(/%(\d+)/g, (_, i) => params[i]);
      const { index, line, column } = parser;
      const error = new SyntaxError(`Line ${line}, column ${column}: ${message}`);
      error.index = index;
      error.line = line;
      error.column = column;
      error.description = message;
      throw error;
  }

  function scanNumber(parser, context, nonOctalDecimalInteger, isFloat) {
      let char = parser.nextCodePoint;
      let decimalValue = 0;
      let value = 0;
      if (isFloat) {
          decimalValue = scanDecimalDigits(parser, context, char);
          if (decimalValue < 0)
              return 121;
          value = '.' + decimalValue;
      }
      else {
          let digit = 9;
          let allowSeparator = 0;
          if (nonOctalDecimalInteger === 0) {
              while (digit >= 0 && ((char >= 48 && char <= 57) || char == 95)) {
                  if (char === 95) {
                      char = advance(parser);
                      if (char === 95) {
                          report(parser, context, 10);
                          return 121;
                      }
                      allowSeparator = 1;
                      continue;
                  }
                  allowSeparator = 0;
                  value = 10 * value + (char - 48);
                  char = advance(parser);
                  --digit;
              }
              if (allowSeparator) {
                  report(parser, context, 14);
                  return 121;
              }
              if (digit >= 0 && char !== 46 && !isIdentifierStart(char)) {
                  parser.tokenValue = value;
                  return 268566530;
              }
          }
          decimalValue = scanDecimalDigits(parser, context, char);
          if (decimalValue < 0)
              return 121;
          value += decimalValue;
          char = parser.nextCodePoint;
          if (char === 46) {
              char = advance(parser);
              if (char === 95) {
                  report(parser, context, 0);
                  return 121;
              }
              decimalValue = scanDecimalDigits(parser, context, char);
              if (decimalValue < 0)
                  return 121;
              value += '.' + decimalValue;
              isFloat = 1;
          }
      }
      char = parser.nextCodePoint;
      const { index: end } = parser;
      let isBigInt = 0;
      if (char === 110) {
          if (isFloat || nonOctalDecimalInteger) {
              report(parser, context, 28);
              return 121;
          }
          char = advance(parser);
          isBigInt = 1;
      }
      else if ((char | 32) == 101) {
          char = advance(parser);
          if (CharTypes[char] & 256)
              char = advance(parser);
          const { index } = parser;
          if ((CharTypes[char] & 8) === 0) {
              report(parser, context, 15);
              return 121;
          }
          decimalValue = scanDecimalDigits(parser, context, char);
          if (decimalValue < 0)
              return 121;
          value += parser.source.substring(end, index) + decimalValue;
          char = parser.nextCodePoint;
      }
      if ((parser.index < parser.length && char >= 48 && char <= 57) || isIdentifierStart(char)) {
          report(parser, context, 16);
          return 121;
      }
      parser.tokenValue = nonOctalDecimalInteger ? parseFloat(parser.source.slice(parser.startPos, parser.index)) : +value;
      return isBigInt ? 123 : 268566530;
  }
  function scanDecimalDigits(parser, context, char) {
      let allowSeparator = 0;
      let start = parser.index;
      let value = '';
      while ((char >= 48 && char <= 57) || char == 95) {
          if (char === 95) {
              const { index } = parser;
              char = advance(parser);
              if (char === 95) {
                  report(parser, context, 10);
                  return -1;
              }
              allowSeparator = 1;
              value += parser.source.substring(start, index);
              start = parser.index;
              continue;
          }
          allowSeparator = 0;
          char = advance(parser);
      }
      if (allowSeparator) {
          report(parser, context, 14);
          return -1;
      }
      return (value += parser.source.substring(start, parser.index));
  }
  function scanLeadingZero(parser, context, char) {
      let nonOctalDecimalInteger = 0;
      let allowSeparator = 0;
      let digits = 0;
      let value = 0;
      char = advance(parser);
      if ((char | 32) === 120) {
          char = advance(parser);
          while (CharTypes[char] & (16 | 64)) {
              if (char === 95) {
                  if (!allowSeparator) {
                      report(parser, context, 10);
                      return 121;
                  }
                  allowSeparator = 0;
                  char = advance(parser);
                  continue;
              }
              allowSeparator = 1;
              value = value * 0x10 + toHex(char);
              digits++;
              char = advance(parser);
          }
          if (digits < 1 || !allowSeparator) {
              report(parser, context, digits < 1 ? 11 : 14);
              return 121;
          }
      }
      else if ((char | 32) === 111) {
          char = advance(parser);
          while ((char >= 48 && char <= 55) || char == 95) {
              if (char === 95) {
                  if (!allowSeparator) {
                      report(parser, context, 10);
                      return 121;
                  }
                  allowSeparator = 0;
                  char = advance(parser);
                  continue;
              }
              allowSeparator = 1;
              value = value * 8 + (char - 48);
              digits++;
              char = advance(parser);
          }
          if (digits < 1 || !allowSeparator) {
              report(parser, context, digits < 1 ? 12 : 14);
              return 121;
          }
      }
      else if ((char | 32) === 98) {
          char = advance(parser);
          while ((char >= 48 && char <= 49) || char == 95) {
              if (char === 95) {
                  if (!allowSeparator) {
                      report(parser, context, 10);
                      return 121;
                  }
                  allowSeparator = 0;
                  char = advance(parser);
                  continue;
              }
              allowSeparator = 1;
              value = value * 2 + (char - 48);
              digits++;
              char = advance(parser);
          }
          if (digits < 1 || !allowSeparator) {
              report(parser, context, digits < 1 ? 13 : 14);
              return 121;
          }
      }
      else if (char >= 48 && char <= 57) {
          if (context & 1024) {
              report(parser, context, 20);
              return 121;
          }
          while (char >= 48 && char <= 57) {
              if (char >= 56) {
                  nonOctalDecimalInteger = 1;
              }
              value = value * 8 + (char - 48);
              advance(parser);
              char = parser.nextCodePoint;
          }
          if (char === 95) {
              report(parser, context, 30);
              return 121;
          }
          if (char === 110) {
              report(parser, context, 28);
              return 121;
          }
          if (nonOctalDecimalInteger) {
              return scanNumber(parser, context, nonOctalDecimalInteger, 0);
          }
      }
      else if (char === 95) {
          report(parser, context, 30);
          return 121;
      }
      else {
          return scanNumber(parser, context, nonOctalDecimalInteger, 0);
      }
      let isBigInt = 0;
      if (char === 110) {
          char = advance(parser);
          isBigInt = 1;
      }
      if ((parser.index < parser.length && char >= 48 && char <= 57) || isIdentifierStart(char)) {
          report(parser, context, 16);
          return 121;
      }
      parser.tokenValue = value;
      return isBigInt ? 123 : 268566530;
  }

  function handleIdentifierError(code) {
      switch (code) {
          case -2:
              return 7;
          case -3:
              return 6;
          case -4:
              return 22;
          case -6:
          case -5:
              return 8;
          case -7:
              return 29;
          default:
              return 0;
      }
  }
  function handleEscapeError(code, isTemplate) {
      if (code === -2) {
          return isTemplate ? 19 : 20;
      }
      if (code === -3) {
          return 21;
      }
      if (code === -4) {
          return 6;
      }
      if (code === -5) {
          return 22;
      }
      if (code === -6) {
          return 29;
      }
      return 0;
  }

  function scanStringLiteral(parser, context, quote) {
      let ret = '';
      const { index: start } = parser;
      let ch = advance(parser);
      while ((CharTypes[ch] & 4) === 0) {
          if (ch === quote) {
              advance(parser);
              if (context & 64)
                  parser.tokenRaw = parser.source.slice(start, parser.index);
              parser.tokenValue = ret;
              return 268566531;
          }
          if ((ch & 8) === 8 && ch === 92) {
              ch = advance(parser);
              if (ch >= 128) {
                  ret += fromCodePoint(ch);
              }
              else {
                  parser.nextCodePoint = ch;
                  const code = parseEscape(parser, context, ch);
                  if (code >= 0)
                      ret += fromCodePoint(code);
                  else if (code !== -1) {
                      report(parser, context, handleEscapeError(code, 0));
                      return 121;
                  }
              }
          }
          else if ((ch ^ 8232) <= 1) {
              parser.index++;
              parser.column = 0;
              parser.line++;
          }
          else {
              ret += fromCodePoint(ch);
          }
          ch = advance(parser);
          if (parser.index >= parser.length) {
              report(parser, context, 17);
              return 121;
          }
      }
      report(parser, context, 31);
      return 121;
  }
  function scanTemplate(parser, context) {
      const { index: start } = parser;
      let ret = '';
      let tail = true;
      let ch = advance(parser);
      while (ch !== 96) {
          if (ch === 36) {
              const index = parser.index + 1;
              if (index < parser.source.length && parser.source.charCodeAt(index) === 123) {
                  parser.index = index;
                  parser.column++;
                  tail = false;
                  break;
              }
              ret += '$';
          }
          else if (ch === 92) {
              ch = advance(parser);
              if (ch >= 128) {
                  ret += fromCodePoint(ch);
              }
              else {
                  parser.nextCodePoint = ch;
                  const code = parseEscape(parser, context | 1024, ch);
                  if (code >= 0) {
                      ret += fromCodePoint(code);
                  }
                  else if (code !== -1 && context & 65536) {
                      ret = null;
                      ch = scanLooserTemplateSegment(parser, context, parser.nextCodePoint);
                      if (ch < 0) {
                          tail = false;
                          break;
                      }
                      else if (ch === 0x11000) {
                          return 121;
                      }
                      break;
                  }
                  else if (code !== -1) {
                      report(parser, context, handleEscapeError(code, 1));
                      return 121;
                  }
              }
          }
          else if (((ch & 83) < 3 && CharTypes[ch] & 4) ||
              (ch ^ 8232) <= 1) {
              if (ch === 13) {
                  if (parser.index < parser.length && parser.source.charCodeAt(parser.index) === 10) {
                      ret += fromCodePoint(ch);
                      ch = parser.source.charCodeAt(parser.index);
                      parser.index++;
                  }
              }
              parser.column = -1;
              parser.line++;
              ret += fromCodePoint(ch);
          }
          else {
              ret += fromCodePoint(ch);
          }
          ch = advance(parser);
          if (parser.index >= parser.length) {
              report(parser, context, 18);
              return 121;
          }
      }
      advance(parser);
      parser.tokenValue = ret;
      if (tail) {
          parser.tokenRaw = parser.source.slice(start + 1, parser.index - 1);
          return 131081;
      }
      else {
          parser.tokenRaw = parser.source.slice(start + 1, parser.index - 2);
          return 131080;
      }
  }
  function scanLooserTemplateSegment(parser, context, ch) {
      while (ch !== 96) {
          if (ch === 36) {
              const index = parser.index + 1;
              if (index < parser.source.length && parser.source.charCodeAt(index) === 123) {
                  parser.index = index;
                  parser.column++;
                  return -ch;
              }
          }
          ch = parser.source.charCodeAt(++parser.index);
          if (parser.index >= parser.length) {
              report(parser, context, 18);
              return 0x11000;
          }
      }
      return ch;
  }
  function scanTemplateTail(parser, context) {
      parser.index--;
      return scanTemplate(parser, context);
  }
  function parseEscape(parser, context, first) {
      switch (first) {
          case 98:
              return 8;
          case 102:
              return 12;
          case 114:
              return 13;
          case 110:
              return 10;
          case 116:
              return 9;
          case 118:
              return 11;
          case 13: {
              const { index } = parser;
              if (index < parser.source.length) {
                  const ch = parser.source.charCodeAt(index);
                  if (ch === 10) {
                      parser.nextCodePoint = ch;
                      parser.index = index + 1;
                  }
              }
          }
          case 10:
          case 8232:
          case 8233:
              parser.column = -1;
              parser.line++;
              return -1;
          case 48:
          case 49:
          case 50:
          case 51: {
              let code = first - 48;
              let index = parser.index + 1;
              let column = parser.column + 1;
              if (index < parser.length) {
                  const next = parser.source.charCodeAt(index);
                  if (next < 48 || next > 55) {
                      if ((code !== 0 || CharTypes[next] & 32) &&
                          context & (1024 | 256))
                          return -2;
                  }
                  else if (context & (1024 | 256)) {
                      return -2;
                  }
                  else {
                      parser.nextCodePoint = next;
                      code = (code << 3) | (next - 48);
                      index++;
                      column++;
                      if (index < parser.length) {
                          const next = parser.source.charCodeAt(index);
                          if (next >= 48 && next <= 55) {
                              parser.nextCodePoint = next;
                              code = (code << 3) | (next - 48);
                              index++;
                              column++;
                          }
                      }
                      parser.index = index - 1;
                      parser.column = column - 1;
                  }
              }
              return code;
          }
          case 52:
          case 53:
          case 54:
          case 55: {
              if (context & (1024 | 256))
                  return -2;
              let code = first - 48;
              const index = parser.index + 1;
              const column = parser.column + 1;
              if (index < parser.length) {
                  const next = parser.source.charCodeAt(index);
                  if (next >= 48 && next <= 55) {
                      code = (code << 3) | (next - 48);
                      parser.nextCodePoint = next;
                      parser.index = index;
                      parser.column = column;
                  }
              }
              return code;
          }
          case 56:
          case 57:
              return -3;
          case 120: {
              const hi = advance(parser);
              if ((CharTypes[hi] & 16) === 0)
                  return -4;
              const lo = advance(parser);
              if ((CharTypes[lo] & 16) === 0)
                  return -4;
              return (toHex(hi) << 4) | toHex(lo);
          }
          case 117: {
              let ch = advance(parser);
              if (ch === 123) {
                  ch = advance(parser);
                  let code = 0;
                  let digits = 0;
                  while (CharTypes[ch] & 16) {
                      code = (code << 4) | toHex(ch);
                      if (code > 0x10ffff)
                          return -5;
                      ch = parser.source.charCodeAt(++parser.index);
                      parser.column++;
                      digits++;
                  }
                  if (digits < 4)
                      return -4;
                  if (ch !== 125)
                      return -6;
                  return code;
              }
              if ((CharTypes[ch] & 16) === 0)
                  return -4;
              const ch2 = parser.source.charCodeAt(parser.index + 1);
              if ((CharTypes[ch2] & 16) === 0)
                  return -4;
              const ch3 = parser.source.charCodeAt(parser.index + 2);
              if ((CharTypes[ch3] & 16) === 0)
                  return -4;
              const ch4 = parser.source.charCodeAt(parser.index + 3);
              if ((CharTypes[ch4] & 16) === 0)
                  return -4;
              parser.column += 3;
              parser.nextCodePoint = parser.source.charCodeAt((parser.index += 3));
              return (toHex(ch) << 12) | (toHex(ch2) << 8) | (toHex(ch3) << 4) | toHex(ch4);
          }
          default:
              return parser.source.charCodeAt(parser.index);
      }
  }

  function scanIdentifierOrKeyword(parser, context, canBeKeyword) {
      while (identifierPart[advance(parser)]) { }
      const value = parser.source.slice(parser.tokenPos, parser.index);
      if (parser.nextCodePoint !== 92 && parser.nextCodePoint < 0x7e) {
          parser.tokenValue = value;
          if (canBeKeyword === 0)
              return 167937;
          return descKeywordTable[parser.tokenValue] || 167937;
      }
      return scanIdentifierSlowPath(parser, context, value, canBeKeyword);
  }
  function scanIdentifierSlowPath(parser, context, value, canBeKeyword) {
      let start = parser.index;
      let hasEscape = 0;
      while (parser.index < parser.length) {
          if (isIdentifierPart(parser.nextCodePoint)) {
              advance(parser);
          }
          else if (parser.nextCodePoint === 92) {
              value += parser.source.slice(start, parser.index);
              hasEscape = 1;
              const code = scanIdentifierUnicodeEscape(parser);
              if (!isIdentifierPart(code)) {
                  report(parser, context, handleIdentifierError(code));
                  return 121;
              }
              canBeKeyword = 1;
              value += fromCodePoint(code);
              start = parser.index;
          }
          else if (consumeMultiUnitCodePoint(parser, parser.nextCodePoint)) {
              advance(parser);
          }
          else {
              break;
          }
      }
      if (parser.index <= parser.length)
          value += parser.source.slice(start, parser.index);
      const length = value.length;
      parser.tokenValue = value;
      if (canBeKeyword && length >= 2 && length <= 11) {
          const token = descKeywordTable[parser.tokenValue];
          if (token === void 0)
              return 167937;
          if (hasEscape === 0)
              return token;
          if (context & 1024) {
              if ((token & 16384) === 16384) {
                  return 138;
              }
              if (token === 184394 || token === 540779) {
                  return 138;
              }
          }
          return 139;
      }
      return 167937;
  }
  function scanIdentifierUnicodeEscape(parser) {
      if (parser.source.charCodeAt(parser.index + 1) !== 117) {
          return -5;
      }
      parser.nextCodePoint = parser.source.charCodeAt((parser.index += 2));
      return scanUnicodeEscape(parser);
  }
  function scanUnicodeEscape(parser) {
      let codePoint = 0;
      let char = parser.nextCodePoint;
      if (char === 123) {
          while (CharTypes[advance(parser)] & 16) {
              codePoint = (codePoint << 4) | toHex(parser.nextCodePoint);
              if (codePoint > 0x10ffff)
                  return -4;
          }
          if (parser.nextCodePoint !== 125)
              return -7;
          advance(parser);
          return codePoint;
      }
      for (let i = 0; i < 4; i++) {
          char = toHex(parser.nextCodePoint);
          if (char < 0)
              return -3;
          codePoint = (codePoint << 4) | char;
          advance(parser);
      }
      return codePoint;
  }
  function scanUnicodeEscapeIdStart(parser, context) {
      const cookedChar = scanIdentifierUnicodeEscape(parser);
      if (isIdentifierPart(cookedChar)) {
          return scanIdentifierSlowPath(parser, context, fromCodePoint(cookedChar), 1);
      }
      parser.index++;
      report(parser, context, handleIdentifierError(cookedChar));
      return 121;
  }

  function skipSingleLineComment(parser) {
      while (parser.index < parser.length) {
          const next = parser.nextCodePoint;
          if (next === 13) {
              advanceNewline(parser);
              if (parser.index < parser.length && parser.nextCodePoint === 10) {
                  parser.nextCodePoint = parser.source.charCodeAt(++parser.index);
              }
              return 1;
          }
          if (next === 10 || (next ^ 8232) <= 1) {
              advanceNewline(parser);
              return 1;
          }
          advance(parser);
      }
  }
  function skipMultiLineComment(parser, context) {
      let lastIsCR = 0;
      while (parser.index < parser.length) {
          let next = parser.nextCodePoint;
          while (next === 42) {
              next = advance(parser);
              if (next === 47) {
                  advance(parser);
                  return 1;
              }
          }
          if (next === 13) {
              lastIsCR = 1;
              advanceNewline(parser);
          }
          else if (next === 10) {
              consumeLineFeed(parser, lastIsCR);
              lastIsCR = 0;
          }
          else if ((next ^ 8232) <= 1) {
              lastIsCR = 0;
              advanceNewline(parser);
          }
          else {
              next = advance(parser);
              lastIsCR = 0;
          }
      }
      report(parser, context, 34);
      return -1;
  }

  function scanRegularExpression(parser, context) {
      const bodyStart = parser.index;
      let preparseState = 0;
      loop: while (true) {
          const ch = parser.nextCodePoint;
          advance(parser);
          if (preparseState & 1) {
              preparseState &= ~1;
          }
          else {
              switch (ch) {
                  case 47:
                      if (!preparseState)
                          break loop;
                      else
                          break;
                  case 92:
                      preparseState |= 1;
                      break;
                  case 91:
                      preparseState |= 2;
                      break;
                  case 93:
                      preparseState &= 1;
                      break;
                  case 13:
                  case 10:
                  case 8232:
                  case 8233:
                      report(parser, context, 25);
                      return 121;
                  default:
              }
          }
          if (parser.index >= parser.source.length) {
              report(parser, context, 25);
              return 121;
          }
      }
      const bodyEnd = parser.index - 1;
      let mask = 0;
      let char = parser.nextCodePoint;
      const { index: flagStart } = parser;
      while (isIdentifierPart(char)) {
          switch (char) {
              case 103:
                  if (mask & 2)
                      report(parser, context, 23, 1, 'g');
                  mask |= 2;
                  break;
              case 105:
                  if (mask & 1) {
                      report(parser, context, 23, 1, 'i');
                      return 121;
                  }
                  mask |= 1;
                  break;
              case 109:
                  if (mask & 4) {
                      report(parser, context, 23, 1, 'm');
                      return 121;
                  }
                  mask |= 4;
                  break;
              case 117:
                  if (mask & 16) {
                      report(parser, context, 23, 0, 'u');
                      return 121;
                  }
                  mask |= 16;
                  break;
              case 121:
                  if (mask & 8) {
                      report(parser, context, 23, 1, 'y');
                      return 121;
                  }
                  mask |= 8;
                  break;
              case 115:
                  if (mask & 12) {
                      report(parser, context, 23, 1, 's');
                      return 121;
                  }
                  mask |= 12;
                  break;
              default:
                  report(parser, context, 24);
                  return 121;
          }
          char = advance(parser);
      }
      const flags = parser.source.slice(flagStart, parser.index);
      const pattern = parser.source.slice(bodyStart, bodyEnd);
      parser.tokenRegExp = { pattern, flags };
      if (context & 64)
          parser.tokenRaw = parser.source.slice(parser.tokenPos, parser.index);
      parser.tokenValue = validate(parser, context, pattern, flags);
      return 131076;
  }
  function validate(parser, context, pattern, flags) {
      try {
          RegExp(pattern);
      }
      catch (e) {
          report(parser, context, 25);
          return 121;
      }
      try {
          return new RegExp(pattern, flags);
      }
      catch (e) {
          return null;
      }
  }

  const firstCharKinds = [
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      117,
      119,
      117,
      117,
      118,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      121,
      117,
      33685550,
      268566531,
      122,
      167937,
      16911157,
      16909893,
      268566531,
      131083,
      16,
      16911156,
      50465328,
      18,
      50465329,
      13,
      16911158,
      120,
      268566530,
      268566530,
      268566530,
      268566530,
      268566530,
      268566530,
      268566530,
      268566530,
      268566530,
      21,
      2097169,
      16910400,
      8388638,
      16910401,
      22,
      142,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      167937,
      4325395,
      125,
      20,
      16909639,
      167937,
      131081,
      110592,
      110592,
      110592,
      110592,
      110592,
      110592,
      110592,
      167937,
      110592,
      167937,
      110592,
      110592,
      110592,
      110592,
      110592,
      110592,
      167937,
      110592,
      110592,
      110592,
      110592,
      110592,
      110592,
      167937,
      110592,
      110592,
      4325388,
      16909382,
      2097167,
      33685551,
      121
  ];
  function scanSingleToken(parser, context) {
      let lastIsCR = 0;
      const isStartOfLine = parser.index === 0;
      while (parser.index < parser.length) {
          parser.tokenPos = parser.index;
          parser.endColumn = parser.column;
          parser.endLine = parser.line;
          let char = parser.nextCodePoint;
          if (char <= 0x7e) {
              const token = firstCharKinds[char];
              switch (token) {
                  case 2097167:
                  case 4325388:
                  case 18:
                  case 21:
                  case 33685551:
                  case 131083:
                  case 16:
                  case 2097169:
                  case 4325395:
                  case 20:
                  case 142:
                  case 121:
                      advance(parser);
                      return token;
                  case 117:
                      advance(parser);
                      continue;
                  case 118:
                      lastIsCR = 1;
                      parser.column = 0;
                      parser.line++;
                  case 119: {
                      parser.precedingLineBreak = 1;
                      parser.nextCodePoint = parser.source.charCodeAt(++parser.index);
                      if (!lastIsCR) {
                          parser.column = 0;
                          parser.line++;
                      }
                      lastIsCR = 0;
                      continue;
                  }
                  case 110592:
                      return scanIdentifierOrKeyword(parser, context, 1);
                  case 167937:
                      return scanIdentifierOrKeyword(parser, context, 0);
                  case 268566530:
                      return scanNumber(parser, context, 0, 0);
                  case 268566531:
                      return scanStringLiteral(parser, context, char);
                  case 120:
                      return scanLeadingZero(parser, context, char);
                  case 125:
                      return scanUnicodeEscapeIdStart(parser, context);
                  case 131081:
                      return scanTemplate(parser, context);
                  case 13:
                      const next = advance(parser);
                      if (next >= 48 && next <= 57)
                          return scanNumber(parser, context, 0, 1);
                      if (next === 46) {
                          const index = parser.index + 1;
                          if (index < parser.source.length && parser.source.charCodeAt(index) === 46) {
                              parser.column += 2;
                              parser.nextCodePoint = parser.source.charCodeAt((parser.index += 2));
                              return 14;
                          }
                      }
                      return 13;
                  case 16910400:
                      advance(parser);
                      if (parser.index < parser.length) {
                          let next = parser.nextCodePoint;
                          if (next === 60) {
                              if (advance(parser) === 61) {
                                  advance(parser);
                                  return 8388639;
                              }
                              return 16910658;
                          }
                          if (next === 61) {
                              advance(parser);
                              return 16910142;
                          }
                          if (next === 47) {
                              if ((context & 16) < 1)
                                  return 16910400;
                              const index = parser.index + 1;
                              if (index < parser.length) {
                                  next = parser.source.charCodeAt(index);
                                  if (next === 42 || next === 47)
                                      break;
                              }
                              advance(parser);
                              return 26;
                          }
                          if (next === 33) {
                              if (parser.source.charCodeAt(parser.index + 2) === 45 &&
                                  parser.source.charCodeAt(parser.index + 1) === 45 &&
                                  (context & (256 | 2048)) === 0) {
                                  parser.index += 2;
                                  parser.column += 3;
                                  skipSingleLineComment(parser);
                                  continue;
                              }
                          }
                      }
                      return 16910400;
                  case 22: {
                      advance(parser);
                      if (context & 1) {
                          let ch = parser.nextCodePoint;
                          if (ch === 63) {
                              advance(parser);
                              return 553779528;
                          }
                          if (ch === 46) {
                              ch = parser.source.charCodeAt(parser.index + 1) | 0;
                              if (ch > 57 || ch <= 48) {
                                  advance(parser);
                                  return 23;
                              }
                          }
                      }
                      return 22;
                  }
                  case 8388638: {
                      advance(parser);
                      if (parser.index >= parser.length)
                          return 8388638;
                      const char = parser.nextCodePoint;
                      if (char === 61) {
                          if (advance(parser) === 61) {
                              advance(parser);
                              return 16910138;
                          }
                          return 16910140;
                      }
                      if (char === 62) {
                          advance(parser);
                          return 10;
                      }
                      return 8388638;
                  }
                  case 33685550:
                      if (advance(parser) !== 61)
                          return 33685550;
                      if (advance(parser) !== 61)
                          return 16910141;
                      advance(parser);
                      return 16910139;
                  case 16911157:
                      if (advance(parser) !== 61)
                          return 16911157;
                      advance(parser);
                      return 8388647;
                  case 16911156: {
                      advance(parser);
                      if (parser.index >= parser.length)
                          return 16911156;
                      const char = parser.nextCodePoint;
                      if (char === 61) {
                          advance(parser);
                          return 8388645;
                      }
                      if (char !== 42)
                          return 16911156;
                      advance(parser);
                      if (parser.nextCodePoint !== 61)
                          return 16911415;
                      advance(parser);
                      return 8388642;
                  }
                  case 16909639:
                      if (advance(parser) !== 61)
                          return 16909639;
                      advance(parser);
                      return 8388648;
                  case 50465328: {
                      advance(parser);
                      if (parser.index >= parser.length)
                          return 50465328;
                      const char = parser.nextCodePoint;
                      if (char === 43) {
                          advance(parser);
                          return 67239964;
                      }
                      if (char === 61) {
                          advance(parser);
                          return 8388643;
                      }
                      return 50465328;
                  }
                  case 50465329: {
                      advance(parser);
                      if (parser.index >= parser.length)
                          return 50465329;
                      const char = parser.nextCodePoint;
                      if (char === 45) {
                          if (advance(parser) === 62 &&
                              (context & (256 | 2048)) === 0 &&
                              (parser.precedingLineBreak || isStartOfLine)) {
                              skipSingleLineComment(parser);
                              continue;
                          }
                          return 67239965;
                      }
                      if (char === 61) {
                          advance(parser);
                          return 8388644;
                      }
                      return 50465329;
                  }
                  case 16911158: {
                      const char = advance(parser);
                      if (char === 47) {
                          advance(parser);
                          skipSingleLineComment(parser);
                          continue;
                      }
                      if (char === 42) {
                          advance(parser);
                          const state = skipMultiLineComment(parser, context);
                          if (state < 1)
                              return 121;
                          continue;
                      }
                      if (context & 32768) {
                          return scanRegularExpression(parser, context);
                      }
                      if (char === 61) {
                          advance(parser);
                          return 8519718;
                      }
                      return 16911158;
                  }
                  case 16909382: {
                      advance(parser);
                      if (parser.index >= parser.length)
                          return 16909382;
                      const char = parser.nextCodePoint;
                      if (char === 124) {
                          advance(parser);
                          return 17957433;
                      }
                      if (char === 61) {
                          advance(parser);
                          return 8388649;
                      }
                      return 16909382;
                  }
                  case 16910401: {
                      advance(parser);
                      if (context & 268435456 || parser.index >= parser.length)
                          return 16910401;
                      let char = parser.nextCodePoint;
                      if (char === 61) {
                          advance(parser);
                          return 16910143;
                      }
                      if (char !== 62)
                          return 16910401;
                      char = advance(parser);
                      if (char === 62) {
                          if (advance(parser) !== 61)
                              return 16910660;
                          advance(parser);
                          return 8388641;
                      }
                      if (char === 61) {
                          advance(parser);
                          return 8388640;
                      }
                      return 16910659;
                  }
                  case 16909893: {
                      advance(parser);
                      if (parser.index >= parser.source.length)
                          return 16909893;
                      const char = parser.nextCodePoint;
                      if (char === 38) {
                          advance(parser);
                          return 17957688;
                      }
                      if (char === 61) {
                          advance(parser);
                          return 8388650;
                      }
                      return 16909893;
                  }
                  default:
              }
          }
          if ((char ^ 8232) <= 1) {
              lastIsCR = 0;
              parser.precedingLineBreak = 1;
              parser.nextCodePoint = parser.source.charCodeAt(++parser.index);
              parser.column = 0;
              parser.line++;
              continue;
          }
          if ((char & 0xfc00) === 0xd800 || ((unicodeLookup[(char >>> 5) + 34816] >>> char) & 31 & 1) !== 0) {
              if ((char & 0xfc00) === 0xdc00) {
                  char = ((char & 0x3ff) << 10) | (char & 0x3ff) | 0x10000;
                  if (((unicodeLookup[(char >>> 5) + 0] >>> char) & 31 & 1) === 0) {
                      report(parser, context, 4);
                      return 121;
                  }
                  parser.index++;
                  parser.nextCodePoint = char;
              }
              return scanIdentifierSlowPath(parser, context, '', 0);
          }
          if (isExoticECMAScriptWhitespace(char)) {
              advance(parser);
              continue;
          }
          report(parser, context, 3);
          return 121;
      }
      return 0;
  }
  function nextToken(parser, context) {
      parser.precedingLineBreak = 0;
      parser.startPos = parser.index;
      parser.startColumn = parser.column;
      parser.startLine = parser.line;
      parser.token = scanSingleToken(parser, context);
      return parser.token;
  }

  function scanJSXAttributeValue(parser, context) {
      parser.startPos = parser.index;
      parser.startColumn = parser.column;
      parser.startLine = parser.line;
      if (parser.nextCodePoint === 39 || parser.nextCodePoint === 34) {
          parser.token = scanJSXString(parser, context);
      }
      else {
          parser.token = scanSingleToken(parser, context);
      }
      return parser.token;
  }
  function scanJSXString(parser, context) {
      const quote = parser.nextCodePoint;
      let char = advance(parser);
      const start = parser.index;
      while (char !== quote) {
          if (parser.index >= parser.length)
              report(parser, context, 17);
          char = advance(parser);
      }
      if (char !== quote)
          report(parser, context, 17);
      parser.tokenValue = parser.source.slice(start, parser.index);
      advance(parser);
      return 268566531;
  }
  function scanJSXToken(parser) {
      parser.startPos = parser.tokenPos = parser.index;
      parser.startColumn = parser.endColumn = parser.column;
      parser.startLine = parser.endLine = parser.line;
      if (parser.index >= parser.length)
          return (parser.token = 0);
      const token = firstCharKinds[parser.source.charCodeAt(parser.index)];
      switch (token) {
          case 16910400: {
              advance(parser);
              if (parser.nextCodePoint === 47) {
                  advance(parser);
                  parser.token = 26;
              }
              else {
                  parser.token = 16910400;
              }
              break;
          }
          case 4325388: {
              advance(parser);
              parser.token = 4325388;
              break;
          }
          default:
              while (parser.index < parser.length && (CharTypes[advance(parser)] & 1024) === 0) { }
              parser.tokenValue = parser.source.slice(parser.tokenPos, parser.index);
              parser.token = 141;
      }
      return parser.token;
  }
  function scanJSXIdentifier(parser) {
      if ((parser.token & (8192 | 4096 | 16384 | 36864)) !== 0) {
          const { index } = parser;
          let char = parser.nextCodePoint;
          while (CharTypes[char] & (2048 | 2)) {
              char = advance(parser);
          }
          parser.tokenValue += parser.source.slice(index, parser.index);
      }
      parser.token = 167937;
      return parser.token;
  }

  const primaryTypes = {
      ['any']: 'AnyKeyword',
      ['boolean']: 'BooleanKeyword',
      ['bigint']: 'BigIntKeyword',
      ['never']: 'NeverKeyword',
      ['number']: 'NumberKeyword',
      ['object']: 'ObjectKeyword',
      ['string']: 'StringKeyword',
      ['symbol']: 'SymbolKeyword',
      ['undefined']: 'UndefinedKeyword',
      ['unknown']: 'UnknownKeyword'
  };
  function consume(parser, context, t) {
      if (parser.token === t) {
          nextToken(parser, context);
          return true;
      }
      report(parser, context, 2, 0, KeywordDescTable[t & 255]);
      return false;
  }
  function consumeOpt(parser, context, t) {
      if (parser.token === t) {
          nextToken(parser, context);
          return true;
      }
      return false;
  }
  function optionalBit(parser, context, t) {
      if (parser.token === t) {
          nextToken(parser, context);
          return 1;
      }
      return 0;
  }
  function canParseSemicolon(parser) {
      if (parser.token === 2097169) {
          return true;
      }
      return parser.token === 4325388 || parser.token === 0 || parser.precedingLineBreak;
  }
  function consumeSemicolon(parser, context) {
      if (parser.precedingLineBreak === 0 && (parser.token & 2097152) !== 2097152) ;
      consumeOpt(parser, context, 2097169);
      return true;
  }
  function reinterpretToPattern(state, node) {
      switch (node.type) {
          case 'ArrayExpression':
              node.type = 'ArrayPattern';
              const elements = node.elements;
              for (let i = 0, n = elements.length; i < n; ++i) {
                  const element = elements[i];
                  if (element)
                      reinterpretToPattern(state, element);
              }
              return;
          case 'ObjectExpression':
              node.type = 'ObjectPattern';
              const properties = node.properties;
              for (let i = 0, n = properties.length; i < n; ++i) {
                  reinterpretToPattern(state, properties[i]);
              }
              return;
          case 'AssignmentExpression':
              node.type = 'AssignmentPattern';
              delete node.operator;
              reinterpretToPattern(state, node.left);
              return;
          case 'Property':
              reinterpretToPattern(state, node.value);
              return;
          case 'SpreadElement':
              node.type = 'RestElement';
              reinterpretToPattern(state, node.argument);
          default:
      }
  }
  function isValidIdentifier(context, t) {
      if (context & (1024 | 2097152)) {
          if (context & 2048 && t === 168047)
              return false;
          if (context & 2097152 && t === 184428)
              return false;
          return (t & 36864) === 36864 || (t & 4096) === 4096;
      }
      return ((t & 36864) === 36864 ||
          (t & 4096) === 4096 ||
          (t & 16384) === 16384);
  }
  function reinterpretToTypeLiteral(node) {
      switch (node.type) {
          case 'ObjectPattern':
              node.type = 'TypeLiteral';
              const members = [];
              const elements = node.properties;
              for (let i = 0, n = elements.length; i < n; ++i) {
                  const element = elements[i];
                  reinterpretToTypeLiteral(element);
                  members.push(element);
              }
              node.members = members;
              delete node.properties;
              return;
          case 'Property':
              node.type = 'PropertySignature';
              return;
      }
  }
  function tryScan(parser, context, callback) {
      return speculationHelper(parser, context, callback, false);
  }
  function speculationHelper(parser, context, callback, isLookahead) {
      const savePos = parser.index;
      const saveStartPos = parser.startPos;
      const saveTokenPos = parser.tokenPos;
      const saveCodePoint = parser.nextCodePoint;
      const savePreceding = parser.precedingLineBreak;
      const saveLine = parser.line;
      const saveColumn = parser.column;
      const saveLength = parser.length;
      const saveRaw = parser.tokenRaw;
      const saveToken = parser.token;
      const saveTokenValue = parser.tokenValue;
      const saveTokenFlags = parser.flags;
      const result = callback(parser, context);
      if (!result || isLookahead) {
          parser.index = savePos;
          parser.startPos = saveStartPos;
          parser.tokenPos = saveTokenPos;
          parser.token = saveToken;
          parser.tokenValue = saveTokenValue;
          parser.flags = saveTokenFlags;
          parser.nextCodePoint = saveCodePoint;
          parser.precedingLineBreak = savePreceding;
          parser.line = saveLine;
          parser.column = saveColumn;
          parser.length = saveLength;
          parser.tokenRaw = saveRaw;
      }
      return result;
  }
  function canFollowTypeArgumentsInExpression(parser) {
      switch (parser.token) {
          case 131083:
          case 131081:
          case 13:
          case 16:
          case 20:
          case 21:
          case 2097169:
          case 22:
          case 16910140:
          case 16910138:
          case 16910141:
          case 16910139:
          case 17957688:
          case 17957433:
          case 16909639:
          case 16909893:
          case 16909382:
          case 2097167:
          case 0:
              return true;
          case 268566530:
          case 18:
          case 4325388:
          default:
              return false;
      }
  }
  function isEqualTagName(elementName) {
      switch (elementName.type) {
          case 'JSXIdentifier':
              return elementName.name;
          case 'JSXNamespacedName':
              return elementName.namespace + ':' + elementName.name;
          case 'JSXMemberExpression':
              return isEqualTagName(elementName.object) + '.' + isEqualTagName(elementName.property);
          default:
      }
  }
  function isStrictReservedWord(parser, context, t) {
      if (t === 168047) {
          if (context & (4194304 | 2048))
              report(parser, context, 97);
      }
      if (t === 184428 && context & 2097152)
          report(parser, context, 98, 1, 'yield');
      return (t & 8192) === 8192 || (t & 16384) === 16384;
  }
  function validateFunctionName(parser, context, t) {
      if (context & 1024) {
          if ((t & 16384) === 16384) {
              report(parser, context, 62);
          }
      }
      if ((t & 8192) === 8192) {
          report(parser, context, 96);
      }
      if (context & (4194304 | 2048) && t === 168047) {
          report(parser, context, 97);
      }
      if (context & (2097152 | 1024) && t === 184428) {
          report(parser, context, 98, 1, 'yield');
      }
  }
  function finishNode(node) {
      return node;
  }

  function create(source, onError, onComment) {
      return {
          source,
          flags: 0,
          index: 0,
          line: 1,
          column: 0,
          tokenPos: 0,
          startPos: 0,
          startColumn: 0,
          startLine: 0,
          endLine: 0,
          endColumn: 0,
          precedingLineBreak: 0,
          length: source.length,
          token: 0,
          tokenValue: undefined,
          tokenRaw: '',
          tokenRegExp: undefined,
          nextCodePoint: source.charCodeAt(0),
          uid: 0,
          onComment,
          onError
      };
  }
  function parseSource(source, options, context, onError) {
      let onComment;
      if (options != null) {
          if (options.onComment != null)
              onComment = options.onComment;
          context |=
              (options.module ? 2048 : 0) |
                  (options.next ? 1 : 0) |
                  (options.jsx ? 16 : 0) |
                  (options.ranges ? 2 : 0) |
                  (options.loc ? 4 : 0) |
                  (options.impliedStrict ? 1024 : 0) |
                  (options.directives ? 8 | 64 : 0) |
                  (options.globalReturn ? 32 : 0) |
                  (options.disableWebCompat ? 256 : 0) |
                  (options.raw ? 64 : 0) |
                  (options.ts ? 128 : 0);
      }
      let body = [];
      const parser = create(source, onError, onComment);
      const isModule = context & 2048;
      nextToken(parser, context | 32768);
      context |= 8192;
      body =
          context & 128
              ? parseDeclarations(parser, context)
              : isModule
                  ? parseModuleItemList(parser, context)
                  : parseStatementList(parser, context);
      const node = {
          type: 'Program',
          sourceType: isModule ? 'module' : 'script',
          body
      };
      return node;
  }
  function parseDeclarations(parser, context) {
      const statements = [];
      while (parser.token === 268566531) {
          if (parser.index - parser.tokenPos < 13 && parser.tokenValue === 'use strict') {
              if ((parser.token & 2097152) === 2097152 || parser.precedingLineBreak === 0) {
                  context |= 1024;
              }
          }
          statements.push(parseStatementListItem(parser, context, parser.tokenPos));
      }
      while (parser.token !== 0) {
          statements.push(parseDeclarationList(parser, context, 0, 0, false));
      }
      return statements;
  }
  function parseDeclarationList(parser, context, isModule, declare, isExport) {
      const { token } = parser;
      let decorators = [];
      switch (token) {
          case 36990: {
              const { tokenValue } = parser;
              switch (nextToken(parser, context)) {
                  case 139343:
                      return parseTypescriptClassDeclaration(parser, context, 0, 1, 0);
                  case 139353:
                      return parseFunctionDeclaration(parser, context, 0, 1, 0, 1, true);
                  default:
                      if (parser.precedingLineBreak === 0 &&
                          (parser.token & 134217728) === 134217728) {
                          return parseDeclarationList(parser, context, isModule, 1, parser.token === 134656085);
                      }
                      return parseExpressionOrLabelledStatement(parser, context, parseIdentifierFromValue(parser, context, tokenValue, 0), token);
              }
          }
          case 134779008:
              return parseClassDeclarationOrIdentifier(parser, context, token, 1, declare);
          case 134254721:
              return parseNamespaceOrIdentifier(parser, context, token, declare);
          case 134226044:
              return parseEnumDeclarationOrIdentifier(parser, context, token, declare, 0);
          case 134664294:
              return parseInterfaceOrIdentifier(parser, context, token, declare);
          case 134254719:
              return parseTypeAliasOrIdentifier(parser, context, token, declare);
          case 134254723:
              return parseGlobalModuleDeclarationOrIdentifier(parser, context, token, declare);
          case 134254722:
              return parseModuleDeclarationOrIdentifier(parser, context, token, declare);
          case 134357067:
              return parseConstEnumOrVariableStatement(parser, context, declare);
          case 142:
              decorators = parseDecorators(parser, context);
              if (parser.token === 139343) {
                  return parseTypescriptClassDeclaration(parser, context, 0, 0, 0, decorators, true);
              }
          case 134656085: {
              if (isExport)
                  report(parser, context, 84);
              switch (nextToken(parser, context | 32768)) {
                  case 438354:
                      return parseExportDefaultDeclaration(parser, context, decorators);
                  case 8388638:
                      return parseExportAssignment(parser, context);
                  case 36990:
                  case 134664294:
                      return parseExportNamedDeclaration(parser, context);
                  case 16915309:
                      return parseNamespaceExportDeclaration(parser, context);
                  case 139355:
                      return parseImportEqualsDeclaration(parser, context, 1);
                  default:
                      return parseTypeScriptExportDeclaration(parser, context, decorators);
              }
          }
          case 139355: {
              if ((context & 8192) < 1) {
                  report(parser, context, 88);
              }
              return parseImportDeclaration(parser, context, 1);
          }
          default:
              return parseStatementListItem(parser, context);
      }
  }
  function parseStatementList(parser, context) {
      const statements = [];
      while (parser.token === 268566531) {
          if (parser.index - parser.tokenPos < 13 && parser.tokenValue === 'use strict') {
              if ((parser.token & 2097152) === 2097152 || parser.precedingLineBreak === 0) {
                  context |= 1024;
              }
          }
          statements.push(parseStatementListItem(parser, context, parser.tokenPos));
      }
      while (parser.token !== 0) {
          statements.push(parseStatementListItem(parser, context, parser.tokenPos));
      }
      return statements;
  }
  function parseStatementListItem(parser, context, pos) {
      switch (parser.token) {
          case 139353:
              return parseFunctionDeclaration(parser, context, 0, 1, 0, 1, false);
          case 142:
          case 139343:
              return context & 128
                  ? parseTypescriptClassDeclaration(parser, context, 0, 0, 0)
                  : parseClassDeclaration(parser, context, 0);
          case 134357067:
              return parseLexicalDeclaration(parser, context, 16, 0);
          case 184394:
              return parseLetIdentOrVarDeclarationStatement(parser, context);
          case 134656085:
              report(parser, context, 0);
          case 139355:
              switch (nextToken(parser, context)) {
                  case 131083:
                      return parseImportCallDeclaration(parser, context);
                  default:
                      report(parser, context, 0);
              }
          case 430190:
              return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context);
          default:
              return parseStatement(parser, context);
      }
  }
  function parseAsyncArrowOrAsyncFunctionDeclaration(parser, context) {
      const { token } = parser;
      let expr = parseIdentifier(parser, context);
      if (parser.token === 21) {
          return parseLabelledStatement(parser, context, token, expr);
      }
      const asyncNewLine = parser.precedingLineBreak;
      if (!asyncNewLine) {
          if (parser.token === 139353) {
              return parseFunctionDeclaration(parser, context, 0, 1, 1, 1, false);
          }
          if ((parser.token & 36864) === 36864) {
              expr = parseArrowFunctionExpression(parser, context, [parseIdentifier(parser, context)], null, null, 1, 1);
              if (parser.token === 18)
                  expr = parseSequenceExpression(parser, context, expr);
              return parseExpressionStatement(parser, context, expr);
          }
      }
      let typeParameters = null;
      if (context & 128 && parser.token === 16910400) {
          typeParameters = parseAsyncIdentifierOrParameterInstantiation(parser, context);
          if (typeParameters !== undefined && parser.token !== 131083)
              report(parser, context, 0);
      }
      if (parser.token === 131083) {
          expr = parseAsyncArrowOrCallExpression(parser, context, 1, typeParameters, expr);
      }
      else if (parser.token === 10) {
          expr = parseArrowFunctionExpression(parser, context, expr, null, null, 1, 1);
      }
      expr = parseMemberOrUpdateExpression(parser, context, expr);
      if (parser.token === 18)
          expr = parseSequenceExpression(parser, context, expr);
      expr = parseAssignmentExpression(parser, context, expr);
      return parseExpressionStatement(parser, context, expr);
  }
  function parseAsyncIdentifierOrParameterInstantiation(parser, context) {
      return tryScan(parser, context, function () {
          nextToken(parser, context);
          const params = [];
          while (parser.token !== 16910401) {
              params.push(parseTypeParameter(parser, context | 1073741824));
              if (parser.token !== 16910401) {
                  if (!consumeOpt(parser, context, 18))
                      break;
              }
          }
          if (!consumeOpt(parser, context, 16910401)) {
              return undefined;
          }
          return params && canFollowTypeArgumentsInExpression(parser)
              ? {
                  type: 'TypeParameterDeclaration',
                  params
              }
              : undefined;
      });
  }
  function parseAsyncArrowOrCallExpression(parser, context, isLHS, typeParameters, callee) {
      nextToken(parser, context | 32768);
      context = (context | 134217728) ^ 134217728;
      if (consumeOpt(parser, context, 16)) {
          let returnType = null;
          if (context & 128 && parser.token === 21) {
              returnType = parseTypeAnnotation(parser, context, 0);
              if (parser.token !== 10)
                  report(parser, context, 0);
          }
          if (parser.token === 10) {
              if (isLHS) {
                  return parseArrowFunctionExpression(parser, context, [], typeParameters, returnType, 1, 1);
              }
              report(parser, context, 0);
          }
          return finishNode({
              type: 'CallExpression',
              callee,
              arguments: []
          });
      }
      let expr = null;
      const params = [];
      while (parser.token !== 16) {
          const { token } = parser;
          if ((token & (36864 | 16384)) > 0) {
              expr = parsePrimaryExpression(parser, context, 1, 1);
              if (parser.token === 22) {
                  nextToken(parser, context);
                  if (parser.token === 21) {
                      expr.typeAnnotation = parseTypeAnnotation(parser, context, 0);
                  }
                  return parseOptionalNchanged(parser, context, params, 1);
              }
              if (parser.token === 16 || parser.token === 18) ;
              else {
                  expr = parseMemberOrUpdateExpression(parser, context, expr);
                  if (parser.token !== 16 && parser.token !== 18) {
                      expr = parseAssignmentExpression(parser, context, expr);
                  }
              }
          }
          else if (token & 4194304) {
              expr =
                  token === 4325388
                      ? parseObjectLiteralOrPattern(parser, context, 0, 1, [])
                      : parseArrayExpressionOrPattern(parser, context, 0, 1, []);
              if (parser.token !== 16 && parser.token !== 18) {
                  expr = parseMemberOrUpdateExpression(parser, context, expr);
                  if ((parser.token & 16908288) === 16908288) {
                      expr = parseBinaryExpression(parser, context, 1, token, expr);
                  }
                  if (consumeOpt(parser, context | 32768, 22)) {
                      expr = parseConditionalExpression(parser, context, expr);
                  }
              }
          }
          else if (token === 14) {
              expr = parseSpreadOrRestElement(parser, context, 16, 1, []);
          }
          else {
              expr = parseExpression(parser, context);
              params.push(expr);
              while (consumeOpt(parser, context | 32768, 18)) {
                  params.push(parseExpression(parser, context));
              }
              consume(parser, context, 16);
              return finishNode({
                  type: 'CallExpression',
                  callee,
                  arguments: params
              });
          }
          params.push(expr);
          if (!consumeOpt(parser, context | 32768, 18))
              break;
      }
      consume(parser, context, 16);
      let returnType = null;
      if (context & 536870912 && parser.token === 21) {
          const returnType = tryScan(parser, context, function () {
              const returnType = parseTypeAnnotation(parser, context | 1073741824, 0);
              if (parser.token === 10)
                  return returnType;
              return undefined;
          });
          return returnType
              ? parseArrowFunctionExpression(parser, context, params, null, returnType, isLHS, 1)
              : expr;
      }
      else if (parser.token === 21) {
          returnType = parseTypeAnnotation(parser, context, 0);
          if (parser.token !== 10)
              report(parser, context, 0);
      }
      if (parser.token === 10) {
          if (!isLHS)
              report(parser, context, 0);
          return parseArrowFunctionExpression(parser, context, params, typeParameters, returnType, 1, 1);
      }
      return finishNode({
          type: 'CallExpression',
          callee,
          arguments: params
      });
  }
  function parseModuleItemList(parser, context) {
      const statements = [];
      while (parser.token !== 0) {
          statements.push(parseModuleItem(parser, context));
      }
      return statements;
  }
  function parseModuleItem(parser, context) {
      switch (parser.token) {
          case 134656085:
              return parseExportDeclaration(parser, context);
          case 139355:
              return parseImportDeclaration(parser, context, 0);
          default:
              return parseStatementListItem(parser, context);
      }
  }
  function parseImportDeclaration(parser, context, isTS) {
      let source = null;
      nextToken(parser, context);
      const specifiers = [];
      if (parser.token === 268566531) {
          source = parseLiteral(parser, context);
      }
      else {
          if (parser.token & (8192 | 16384 | 36864)) {
              const local = parseIdentifier(parser, context);
              if (isTS && parser.token === 8388638) {
                  nextToken(parser, context);
                  const moduleReference = parseModuleReference(parser, context);
                  consumeSemicolon(parser, context);
                  return finishNode({
                      type: 'ImportEqualsDeclaration',
                      id: local,
                      moduleReference,
                      isExport: false
                  });
              }
              specifiers.push(finishNode({
                  type: 'ImportDefaultSpecifier',
                  local
              }));
              if (consumeOpt(parser, context, 18)) {
                  switch (parser.token) {
                      case 16911156:
                          specifiers.push(parseImportNamespaceSpecifier(parser, context));
                          break;
                      case 4325388:
                          parseImportSpecifierOrNamedImports(parser, context, specifiers);
                          break;
                      default:
                          report(parser, context, 0);
                  }
              }
          }
          else {
              switch (parser.token) {
                  case 16911156:
                      specifiers.push(parseImportNamespaceSpecifier(parser, context));
                      break;
                  case 4325388:
                      parseImportSpecifierOrNamedImports(parser, context, specifiers);
                      break;
                  case 131083:
                      return parseImportCallDeclaration(parser, context);
                  default:
                      report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
              }
          }
          source = parseModuleSpecifier(parser, context);
      }
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'ImportDeclaration',
          specifiers,
          source
      });
  }
  function parseImportCallDeclaration(parser, context) {
      let expr = parseImportExpression(parser, context);
      expr = parseMemberOrUpdateExpression(parser, context, expr);
      return parseExpressionStatement(parser, context, expr);
  }
  function parseImportNamespaceSpecifier(parser, context) {
      nextToken(parser, context);
      consume(parser, context, 16915309);
      return finishNode({
          type: 'ImportNamespaceSpecifier',
          local: parseIdentifier(parser, context)
      });
  }
  function parseModuleSpecifier(parser, context) {
      consumeOpt(parser, context, 4211);
      if (parser.token !== 268566531)
          report(parser, context, 0, 0, 'Import');
      return parseLiteral(parser, context);
  }
  function parseImportSpecifierOrNamedImports(parser, context, specifiers) {
      nextToken(parser, context);
      while ((parser.token & (16384 | 110592)) !== 0) {
          const imported = parseIdentifier(parser, context);
          let local;
          if (consumeOpt(parser, context, 16915309)) {
              local = parseIdentifier(parser, context);
          }
          else {
              local = imported;
          }
          specifiers.push(finishNode({
              type: 'ImportSpecifier',
              local,
              imported
          }));
          if (parser.token !== 2097167)
              consume(parser, context, 18);
      }
      consume(parser, context, 2097167);
      return specifiers;
  }
  function parseExportAssignment(parser, context) {
      nextToken(parser, context);
      const expression = parseExpression(parser, context);
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'ExportAssignment',
          expression
      });
  }
  function parseExportNamedDeclaration(parser, context) {
      return finishNode({
          type: 'ExportNamedDeclaration',
          declaration: parseDeclarationList(parser, context, 1, 1, false),
          specifiers: [],
          source: null
      });
  }
  function parseNamespaceExportDeclaration(parser, context) {
      nextToken(parser, context);
      consumeOpt(parser, context, 134254721);
      const id = parseIdentifier(parser, context);
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'NamespaceExportDeclaration',
          id
      });
  }
  function parseTypeScriptExportDeclaration(parser, context, decrorators) {
      if ((context & 8192) < 1)
          report(parser, context, 1, 0, 'Export');
      const specifiers = [];
      let source = null;
      let declaration = null;
      switch (parser.token) {
          case 134254721:
              declaration = parseModuleOrNamespaceDeclaration(parser, context);
              break;
          case 134254722:
              declaration = parseModuleDeclaration(parser, context, false);
              break;
          case 134226044:
              nextToken(parser, context);
              declaration = parseEnumDeclaration(parser, context, 0, 0);
              break;
          case 134254719:
              nextToken(parser, context);
              declaration = parseTypeAlias(parser, context, 0);
              break;
          case 134779008:
              nextToken(parser, context);
              if (parser.token !== 139343) {
                  report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
              }
              declaration = parseTypescriptClassDeclaration(parser, context, 1, 0, 1);
              break;
          case 16911156: {
              let ecma262PR = 0;
              nextToken(parser, context);
              if (context & 1 && consumeOpt(parser, context, 16915309)) {
                  ecma262PR = 1;
                  specifiers.push(finishNode({
                      type: 'ExportNamespaceSpecifier',
                      specifier: parseIdentifier(parser, context)
                  }));
              }
              consume(parser, context, 4211);
              source = parseLiteral(parser, context);
              consumeSemicolon(parser, context | 32768);
              return ecma262PR
                  ? {
                      type: 'ExportNamedDeclaration',
                      source,
                      specifiers
                  }
                  : {
                      type: 'ExportAllDeclaration',
                      source
                  };
          }
          case 4325388: {
              nextToken(parser, context);
              while ((parser.token & (16384 | 110592)) !== 0) {
                  const local = parseIdentifier(parser, context);
                  let exported;
                  if (parser.token === 16915309) {
                      nextToken(parser, context);
                      exported = parseIdentifier(parser, context);
                  }
                  else {
                      exported = local;
                  }
                  specifiers.push(finishNode({
                      type: 'ExportSpecifier',
                      local,
                      exported
                  }));
                  if (parser.token !== 2097167)
                      consume(parser, context, 18);
              }
              consume(parser, context, 2097167);
              if (consumeOpt(parser, context, 4211)) {
                  if (parser.token !== 268566531)
                      report(parser, context, 1, 0, 'Export');
                  source = parseLiteral(parser, context);
              }
              consumeSemicolon(parser, context | 32768);
              break;
          }
          case 142:
          case 139343:
              declaration =
                  context & 128
                      ? parseTypescriptClassDeclaration(parser, context, 1, 0, 0, decrorators)
                      : parseClassDeclaration(parser, context, 2);
              break;
          case 139353:
              declaration = parseFunctionDeclaration(parser, context, 2, 4, 0, 1, false);
              break;
          case 184394:
              declaration = parseLexicalDeclaration(parser, context, 8, 64);
              break;
          case 134357067:
              declaration = parseConstEnumOrVariableStatement(parser, context, 0);
              break;
          case 134357065:
              declaration = parseVariableStatement(parser, context, 64);
              break;
          case 430190:
              nextToken(parser, context);
              if (parser.precedingLineBreak === 0 && parser.token === 139353) {
                  declaration = parseFunctionDeclaration(parser, context, 2, 4, 1, 1, false);
                  break;
              }
          default:
              report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
      }
      return finishNode({
          type: 'ExportNamedDeclaration',
          source,
          specifiers,
          declaration
      });
  }
  function parseModuleOrNamespaceDeclaration(parser, context) {
      nextToken(parser, context);
      const id = parseIdentifier(parser, context);
      let body;
      if (consumeOpt(parser, context, 13)) {
          body = parseModuleOrNamespaceDeclaration(parser, context);
      }
      else {
          body = parseModuleBlock(parser, context);
      }
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'ModuleDeclaration',
          id,
          body
      });
  }
  function parseImportEqualsDeclaration(parser, context, isExport) {
      consume(parser, context, 139355);
      const id = parseIdentifier(parser, context);
      consume(parser, context | 32768, 8388638);
      const moduleReference = parseModuleReference(parser, context);
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'ImportEqualsDeclaration',
          id,
          isExport: isExport === 1,
          moduleReference
      });
  }
  function parseModuleReference(parser, context) {
      if (parser.token === 37001) {
          const { tokenValue } = parser;
          nextToken(parser, context);
          if (parser.token !== 131083) {
              return parseQualifiedName(parser, context, parseIdentifierFromValue(parser, context, tokenValue, 0));
          }
          return parseExternalModuleReference(parser, context);
      }
      return parseEntityName(parser, context);
  }
  function parseExternalModuleReference(parser, context) {
      nextToken(parser, context);
      const expression = parseLiteral(parser, context);
      consume(parser, context, 16);
      return finishNode({
          type: 'ExternalModuleReference',
          expression
      });
  }
  function parseExportDefaultDeclaration(parser, context, decorators = []) {
      let declaration = null;
      nextToken(parser, context | 32768);
      switch (parser.token) {
          case 139353: {
              declaration = parseFunctionDeclaration(parser, context, 1, 4, 0, 1, false);
              break;
          }
          case 142:
          case 139343:
              declaration =
                  context & 128
                      ? parseTypescriptClassDeclaration(parser, context, 1, 0, 0, decorators)
                      : parseClassDeclaration(parser, context, 1);
              break;
          case 430190:
              declaration = parseIdentifier(parser, context);
              if (parser.precedingLineBreak === 0) {
                  if (parser.token === 139353) {
                      declaration = parseFunctionDeclaration(parser, context, 1, 4, 1, 1, false);
                  }
                  else {
                      let typeParameters = null;
                      if (context & 128 && parser.token === 16910400) {
                          typeParameters = parseTypeParameters(parser, context);
                          if (parser.token !== 131083)
                              report(parser, context, 0);
                      }
                      if (parser.token === 131083) {
                          declaration = parseAsyncArrowOrCallExpression(parser, context, 1, typeParameters, declaration);
                          declaration = parseMemberOrUpdateExpression(parser, context, declaration);
                          declaration = parseAssignmentExpression(parser, context, declaration);
                      }
                      else if ((parser.token & (16384 | 110592)) !== 0) {
                          declaration = parseIdentifier(parser, context);
                          declaration = parseArrowFunctionExpression(parser, context, [declaration], null, null, 1, 1);
                      }
                  }
              }
              break;
          case 134664294:
              if (context & 128) {
                  declaration = parseDeclarationList(parser, context, 1, 1, false);
                  break;
              }
          default:
              declaration = parseExpression(parser, context);
              consumeSemicolon(parser, context | 32768);
      }
      return finishNode({
          type: 'ExportDefaultDeclaration',
          declaration
      });
  }
  function parseExportDeclaration(parser, context) {
      nextToken(parser, context | 32768);
      const specifiers = [];
      let declaration = null;
      let source = null;
      if (parser.token === 438354) {
          return parseExportDefaultDeclaration(parser, context);
      }
      switch (parser.token) {
          case 16911156: {
              let ecma262PR = 0;
              nextToken(parser, context);
              if (context & 1 && consumeOpt(parser, context, 16915309)) {
                  ecma262PR = 1;
                  specifiers.push(finishNode({
                      type: 'ExportNamespaceSpecifier',
                      specifier: parseIdentifier(parser, context)
                  }));
              }
              consume(parser, context, 4211);
              source = parseLiteral(parser, context);
              consumeSemicolon(parser, context | 32768);
              return ecma262PR
                  ? {
                      type: 'ExportNamedDeclaration',
                      source,
                      specifiers
                  }
                  : {
                      type: 'ExportAllDeclaration',
                      source
                  };
          }
          case 4325388: {
              nextToken(parser, context);
              while ((parser.token & (16384 | 8192 | 110592)) !== 0) {
                  const local = parseIdentifier(parser, context);
                  let exported;
                  if (parser.token === 16915309) {
                      nextToken(parser, context);
                      exported = parseIdentifier(parser, context);
                  }
                  else {
                      exported = local;
                  }
                  specifiers.push(finishNode({
                      type: 'ExportSpecifier',
                      local,
                      exported
                  }));
                  if (parser.token !== 2097167)
                      consume(parser, context, 18);
              }
              consume(parser, context, 2097167);
              if (consumeOpt(parser, context, 4211)) {
                  if (parser.token !== 268566531)
                      report(parser, context, 1, 0, 'Export');
                  source = parseLiteral(parser, context);
              }
              consumeSemicolon(parser, context | 32768);
              break;
          }
          case 142:
          case 139343:
              declaration =
                  context & 128
                      ? parseTypescriptClassDeclaration(parser, context, 0, 0, 0)
                      : parseClassDeclaration(parser, context, 0);
              break;
          case 139353:
              declaration = parseFunctionDeclaration(parser, context, 2, 4, 0, 1, false);
              break;
          case 184394:
              declaration = parseLexicalDeclaration(parser, context, 8, 64);
              break;
          case 134357067:
              declaration = parseLexicalDeclaration(parser, context, 16, 64 | 128);
              break;
          case 134357065:
              declaration = parseVariableStatement(parser, context, 64);
              break;
          case 430190:
              nextToken(parser, context);
              if (parser.precedingLineBreak === 0 && parser.token === 139353) {
                  declaration = parseFunctionDeclaration(parser, context, 2, 4, 1, 1, false);
                  break;
              }
          default:
              report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
      }
      return finishNode({
          type: 'ExportNamedDeclaration',
          source,
          specifiers,
          declaration
      });
  }
  function parseStatement(parser, context, pos) {
      switch (parser.token) {
          case 134357065:
              return parseVariableStatement(parser, context, 0);
          case 438365:
              return parseReturnStatement(parser, context);
          case 438362:
              return parseIfStatement(parser, context);
          case 438360:
              return parseForStatement(parser, context);
          case 438355:
              return parseDoWhileStatement(parser, context);
          case 438371:
              return parseWhileStatement(parser, context);
          case 139359:
              return parseSwitchStatement(parser, context);
          case 2097169:
              return parseEmptyStatement(parser, context);
          case 4325388:
              return parseBlock(parser, context);
          case 438369:
              return parseThrowStatement(parser, context);
          case 438348:
              return parseBreakStatement(parser, context);
          case 438352:
              return parseContinueStatement(parser, context);
          case 438370:
              return parseTryStatement(parser, context);
          case 438372:
              return parseWithStatement(parser, context);
          case 438353:
              return parseDebuggerStatement(parser, context);
          case 430190:
              return parseAsyncArrowOrAsyncFunctionDeclaration(parser, context);
          case 438350:
          case 438359:
          case 139353:
          case 139343:
              report(parser, context, 0);
          default:
              const { token } = parser;
              const expr = parsePrimaryExpression(parser, context, 1, 0);
              return parseExpressionOrLabelledStatement(parser, context, expr, token);
      }
  }
  function parseExpressionOrLabelledStatement(parser, context, expr, token, pos) {
      if (parser.token === 21)
          return parseLabelledStatement(parser, context, token, expr);
      expr = parseMemberOrUpdateExpression(parser, context, expr);
      expr = parseAssignmentExpression(parser, context, expr);
      if (parser.token === 18)
          expr = parseSequenceExpression(parser, context, expr);
      return parseExpressionStatement(parser, context, expr);
  }
  function parseLetIdentOrVarDeclarationStatement(parser, context) {
      const { token } = parser;
      let expr = parseIdentifier(parser, context);
      if (parser.token & (36864 | 4194304)) {
          const declarations = parseVariableDeclarationList(parser, context, 8, 0);
          consumeSemicolon(parser, context | 32768);
          return finishNode({
              type: 'VariableDeclaration',
              kind: 'let',
              declarations
          });
      }
      if (parser.token === 21) {
          return parseLabelledStatement(parser, context, token, expr);
      }
      if (parser.token === 10) {
          expr = parseArrowFunctionExpression(parser, context, [expr], null, null, 1, 0);
      }
      else {
          expr = parseMemberOrUpdateExpression(parser, context, expr);
          expr = parseAssignmentExpression(parser, context, expr);
      }
      if (parser.token === 18) {
          expr = parseSequenceExpression(parser, context, expr);
      }
      return parseExpressionStatement(parser, context, expr);
  }
  function parseReturnStatement(parser, context) {
      nextToken(parser, context | 32768);
      const argument = parser.precedingLineBreak || parser.token & 2097152 ? null : parseExpressions(parser, context);
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'ReturnStatement',
          argument
      });
  }
  function parseEmptyStatement(parser, context) {
      nextToken(parser, context | 32768);
      return finishNode({
          type: 'EmptyStatement'
      });
  }
  function parseThrowStatement(parser, context) {
      nextToken(parser, context | 32768);
      const argument = parseExpressions(parser, context);
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'ThrowStatement',
          argument
      });
  }
  function parseIfStatement(parser, context) {
      nextToken(parser, context);
      consume(parser, context | 32768, 131083);
      const test = parseExpressions(parser, context);
      consume(parser, context | 32768, 16);
      const consequent = parseConsequentOrAlternative(parser, context);
      let alternate = null;
      if (parser.token === 438356) {
          nextToken(parser, context | 32768);
          alternate = parseConsequentOrAlternative(parser, context);
      }
      return finishNode({
          type: 'IfStatement',
          test,
          consequent,
          alternate
      });
  }
  function parseForStatement(parser, context) {
      nextToken(parser, context);
      const forAwait = (context & 4194304) > 0 && consumeOpt(parser, context, 168047);
      consume(parser, context | 32768, 131083);
      let test = null;
      let update = null;
      let init = null;
      let isVarDecl = parser.token === 134357065 || parser.token === 184394 || parser.token === 134357067;
      let right;
      const { token } = parser;
      if (isVarDecl) {
          if (token === 184394) {
              init = parseIdentifier(parser, context);
              if (parser.token & (36864 | 4194304)) {
                  if (parser.token === 16918578) {
                      if (context & 1024)
                          report(parser, context, 0);
                  }
                  else {
                      init = {
                          type: 'VariableDeclaration',
                          kind: 'let',
                          declarations: parseVariableDeclarationList(parser, context | 134217728, 8, 32)
                      };
                  }
              }
              else if (context & 1024) {
                  report(parser, context, 0);
              }
              else {
                  isVarDecl = false;
                  init = parseMemberOrUpdateExpression(parser, context, init);
                  if (parser.token === 4212)
                      report(parser, context, 0);
              }
          }
          else {
              nextToken(parser, context);
              init =
                  token === 134357065
                      ? {
                          type: 'VariableDeclaration',
                          kind: 'var',
                          declarations: parseVariableDeclarationList(parser, context | 134217728, 4, 32)
                      }
                      : {
                          type: 'VariableDeclaration',
                          kind: 'const',
                          declarations: parseVariableDeclarationList(parser, context | 134217728, 16, 32)
                      };
          }
      }
      else if (token === 2097169) {
          if (forAwait)
              report(parser, context, 0);
      }
      else if ((token & 4194304) === 4194304) {
          init =
              token === 4325388
                  ? parseObjectLiteralOrPattern(parser, context, 0, 0, [])
                  : parseArrayExpressionOrPattern(parser, context, 0, 0, []);
          init = parseMemberOrUpdateExpression(parser, context | 134217728, init);
      }
      else {
          init = parseLeftHandSideExpression(parser, context | 134217728, 1);
      }
      if (parser.token === 4212 || parser.token === 16918578) {
          if (parser.token === 4212) {
              reinterpretToPattern(parser, init);
              nextToken(parser, context | 32768);
              right = parseExpression(parser, context);
              consume(parser, context | 32768, 16);
              const body = parseIterationStatementBody(parser, context);
              return finishNode({
                  type: 'ForOfStatement',
                  body,
                  left: init,
                  right,
                  await: forAwait
              });
          }
          reinterpretToPattern(parser, init);
          nextToken(parser, context | 32768);
          right = parseExpressions(parser, context);
          consume(parser, context | 32768, 16);
          const body = parseIterationStatementBody(parser, context);
          return finishNode({
              type: 'ForInStatement',
              body,
              left: init,
              right
          });
      }
      if (!isVarDecl) {
          init = parseAssignmentExpression(parser, context | 134217728, init);
      }
      if (parser.token === 18)
          init = parseSequenceExpression(parser, context, init);
      consume(parser, context | 32768, 2097169);
      if (parser.token !== 2097169)
          test = parseExpressions(parser, context);
      consume(parser, context | 32768, 2097169);
      if (parser.token !== 16)
          update = parseExpressions(parser, context);
      consume(parser, context | 32768, 16);
      const body = parseIterationStatementBody(parser, context);
      return finishNode({
          type: 'ForStatement',
          body,
          init,
          test,
          update
      });
  }
  function parseConsequentOrAlternative(parser, context) {
      return context & 1024 ||
          parser.token !== 139353
          ? parseStatement(parser, context)
          : parseFunctionDeclaration(parser, context, 0, 0, 0, 0, true);
  }
  function parseSwitchStatement(parser, context) {
      nextToken(parser, context);
      consume(parser, context | 32768, 131083);
      const discriminant = parseExpressions(parser, context);
      consume(parser, context, 16);
      consume(parser, context, 4325388);
      const cases = [];
      let seenDefault = 0;
      while (parser.token !== 2097167) {
          let test = null;
          const consequent = [];
          if (consumeOpt(parser, context | 32768, 438349)) {
              test = parseExpressions(parser, context);
          }
          else {
              consume(parser, context | 32768, 438354);
              if (seenDefault)
                  report(parser, context, 0);
              seenDefault = 1;
          }
          consume(parser, context | 32768, 21);
          while (parser.token !== 438349 &&
              parser.token !== 2097167 &&
              parser.token !== 438354) {
              consequent.push(parseStatementListItem(parser, context | 4096));
          }
          cases.push(finishNode({
              type: 'SwitchCase',
              test,
              consequent
          }));
      }
      consume(parser, context | 32768, 2097167);
      return finishNode({
          type: 'SwitchStatement',
          discriminant,
          cases
      });
  }
  function parseWhileStatement(parser, context) {
      nextToken(parser, context);
      consume(parser, context | 32768, 131083);
      const test = parseExpressions(parser, context);
      consume(parser, context | 32768, 16);
      const body = parseIterationStatementBody(parser, context);
      return finishNode({
          type: 'WhileStatement',
          test,
          body
      });
  }
  function parseIterationStatementBody(parser, context) {
      return parseStatement(parser, ((context | 134217728) ^ 134217728) | 131072);
  }
  function parseContinueStatement(parser, context) {
      nextToken(parser, context);
      let label = null;
      if (parser.precedingLineBreak === 0 && parser.token & 36864) {
          label = parseIdentifier(parser, context | 32768);
      }
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'ContinueStatement',
          label
      });
  }
  function parseBreakStatement(parser, context) {
      nextToken(parser, context | 32768);
      let label = null;
      if (parser.precedingLineBreak === 0 && parser.token & 36864) {
          label = parseIdentifier(parser, context | 32768);
      }
      else if ((context & (4096 | 131072)) < 1) {
          report(parser, context, 0);
      }
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'BreakStatement',
          label
      });
  }
  function parseWithStatement(parser, context) {
      nextToken(parser, context);
      if (context & 1024)
          report(parser, context, 0);
      consume(parser, context | 32768, 131083);
      const object = parseExpressions(parser, context);
      consume(parser, context | 32768, 16);
      const body = parseStatement(parser, context);
      return finishNode({
          type: 'WithStatement',
          object,
          body
      });
  }
  function parseDebuggerStatement(parser, context) {
      nextToken(parser, context | 32768);
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'DebuggerStatement'
      });
  }
  function parseTryStatement(parser, context) {
      nextToken(parser, context | 32768);
      const block = parseBlock(parser, context);
      const handler = consumeOpt(parser, context | 32768, 438350)
          ? parseCatchBlock(parser, context)
          : null;
      let finalizer = null;
      if (parser.token === 438359) {
          nextToken(parser, context | 32768);
          finalizer = parseBlock(parser, context);
      }
      if (!handler && !finalizer) {
          report(parser, context, 0);
      }
      return finishNode({
          type: 'TryStatement',
          block,
          handler,
          finalizer
      });
  }
  function parseCatchBlock(parser, context) {
      let param = null;
      if (consumeOpt(parser, context, 131083)) {
          param = parseBindingPattern(parser, context);
          consume(parser, context | 32768, 16);
      }
      const body = parseBlock(parser, context);
      return finishNode({
          type: 'CatchClause',
          param,
          body
      });
  }
  function parseDoWhileStatement(parser, context) {
      nextToken(parser, context | 32768);
      const body = parseIterationStatementBody(parser, context);
      consume(parser, context, 438371);
      consume(parser, context | 32768, 131083);
      const test = parseExpressions(parser, context);
      consume(parser, context | 32768, 16);
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'DoWhileStatement',
          body,
          test
      });
  }
  function parseLexicalDeclaration(parser, context, kind, origin) {
      nextToken(parser, context);
      const declarations = parseVariableDeclarationList(parser, context, kind, origin);
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'VariableDeclaration',
          kind: kind & 8 ? 'let' : 'const',
          declarations
      });
  }
  function parseVariableStatement(parser, context, origin) {
      const token = parser.token;
      nextToken(parser, context);
      const declarations = parseVariableDeclarationList(parser, context, 4, origin);
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'VariableDeclaration',
          kind: KeywordDescTable[token & 255],
          declarations
      });
  }
  function parseVariableDeclarationList(parser, context, kind, origin) {
      const list = [parseVariableDeclaration(parser, context, kind, origin)];
      while (consumeOpt(parser, context, 18)) {
          list.push(parseVariableDeclaration(parser, context, kind, origin));
      }
      return list;
  }
  function parseVariableDeclaration(parser, context, kind, origin) {
      let init = null;
      let definite = false;
      const token = parser.token;
      const id = parseBindingPattern(parser, context);
      if (context & 128 && token & 36864 && id.name & 2) {
          id.name = id.name ^ 2;
          definite = true;
      }
      if (parser.token === 8388638) {
          nextToken(parser, context | 32768);
          init = parseExpression(parser, context);
          if (origin & 32 || (token & 4194304) < 1) {
              if (parser.token === 4212 ||
                  (parser.token === 16918578 &&
                      (token & 4194304 ||
                          (kind & 4) < 1 ||
                          context & 256 ||
                          context & 1024))) {
                  report(parser, context, 90, 1, parser.token === 4212 ? 'of' : 'in');
              }
          }
      }
      else if ((token & 4194304) > 0 &&
          (context & 128 &&
              (origin & 128) === 0 &&
              (parser.token !== 4212 && parser.token !== 16918578))) {
          report(parser, context, 89, 1, kind & 16 ? 'const' : 'destructuring');
      }
      return context & 128
          ? {
              type: 'VariableDeclarator',
              init,
              id,
              definite
          }
          : {
              type: 'VariableDeclarator',
              init,
              id
          };
  }
  function parseBindingPattern(parser, context) {
      if ((parser.token & 110592) > 0) {
          return context & 128
              ? parseBindingIdentifier(parser, context, 0, 1)
              : parseIdentifier(parser, context);
      }
      if ((parser.token & 4194304) !== 4194304)
          report(parser, context, 1, 1, KeywordDescTable[parser.token & 255]);
      let left;
      if (parser.token === 4325388) {
          left = parseObjectLiteralOrPattern(parser, context, 1, 1, []);
      }
      else if (parser.token === 4325395) {
          left = parseArrayExpressionOrPattern(parser, context, 1, 1, []);
      }
      reinterpretToPattern(parser, left);
      return left;
  }
  function parseSequenceExpression(parser, context, expr) {
      const expressions = [expr];
      while (consumeOpt(parser, context | 32768, 18)) {
          expressions.push(parseExpression(parser, context));
      }
      return finishNode({
          type: 'SequenceExpression',
          expressions
      });
  }
  function parseExpression(parser, context) {
      const expr = parseLeftHandSideExpression(parser, context, 1);
      return parseAssignmentExpression(parser, context, expr);
  }
  function parseExpressions(parser, context) {
      const expr = parseExpression(parser, context);
      return parser.token === 18 ? parseSequenceExpression(parser, context, expr) : expr;
  }
  function parseLeftHandSideExpression(parser, context, isLHS) {
      const expr = parsePrimaryExpression(parser, context, isLHS, 0);
      return parseMemberOrUpdateExpression(parser, context, expr);
  }
  function parseAssignmentExpression(parser, context, left) {
      if ((parser.token & 8388608) === 8388608) {
          const token = parser.token;
          if ((token === 8388638 && left.type === 'ArrayExpression') ||
              left.type === 'ObjectExpression') {
              reinterpretToPattern(parser, left);
          }
          nextToken(parser, context | 32768);
          const right = parseExpression(parser, context);
          return finishNode({
              type: 'AssignmentExpression',
              left,
              operator: KeywordDescTable[token & 255],
              right
          });
      }
      if ((parser.token & 16908288) === 16908288) {
          left = parseBinaryExpression(parser, context, 4, parser.token, left);
      }
      if (consumeOpt(parser, context | 32768, 22)) {
          left = parseConditionalExpression(parser, context, left);
      }
      return left;
  }
  function parseConditionalExpression(parser, context, test) {
      const consequent = parseExpression(parser, (context | 134217728 | 536870912) ^ 134217728);
      consume(parser, context | 32768, 21);
      const alternate = parseExpression(parser, context);
      return finishNode({
          type: 'ConditionalExpression',
          test,
          consequent,
          alternate
      });
  }
  function parseBinaryExpression(parser, context, minPrec, operator, left) {
      const bit = -((context & 134217728) > 0) & 16918578;
      const isTS = context & 128;
      let t;
      let prec;
      while (parser.token & 16908288) {
          t = parser.token;
          prec = t & 3840;
          if ((t & 1048576 && operator & 536870912) || (operator & 1048576 && t & 536870912)) {
              report(parser, context, 27);
          }
          if (prec + ((t === 16911415) << 8) - ((bit === t) << 12) <= minPrec)
              break;
          if (isTS && t === 16915309) {
              if (parser.precedingLineBreak)
                  return left;
              nextToken(parser, context | 32768);
              left = parseAsExpression(parser, context, left);
          }
          else {
              nextToken(parser, context | 32768);
              left = {
                  type: t & 1048576 ? 'LogicalExpression' : t & 536870912 ? 'CoalesceExpression' : 'BinaryExpression',
                  left,
                  right: parseBinaryExpression(parser, context, prec, t, parseLeftHandSideExpression(parser, context, 1)),
                  operator: KeywordDescTable[t & 255]
              };
          }
      }
      return left;
  }
  function parseAsExpression(parser, context, expression) {
      const typeAnnotation = parseType(parser, context, 0, 0, 0);
      return finishNode({
          type: 'AsExpression',
          expression,
          typeAnnotation
      });
  }
  function parseMemberOrUpdateExpression(parser, context, expr, isOptional = 0, optionalChaining = 0) {
      if ((parser.token & 67239936) === 67239936 && !parser.precedingLineBreak) {
          const { token } = parser;
          nextToken(parser, context);
          return finishNode({
              type: 'UpdateExpression',
              argument: expr,
              operator: KeywordDescTable[token & 255],
              prefix: false
          });
      }
      context = (context | 134217728 | 8192) ^ (134217728 | 8192);
      switch (parser.token) {
          case 13: {
              nextToken(parser, context);
              if (isOptional &&
                  (parser.token & (4096 | 8192 | 16384 | 36864)) === 0) {
                  report(parser, context, 1, 1, 'Nchanged does not like optional chaning with number literals');
              }
              const property = parseIdentifier(parser, context);
              return parseMemberOrUpdateExpression(parser, context, finishNode({
                  type: isOptional ? 'OptionalMemberExpression' : 'MemberExpression',
                  object: expr,
                  computed: false,
                  optional: isOptional === 1,
                  property
              }));
          }
          case 4325395: {
              if (context & 1048576)
                  return expr;
              nextToken(parser, context | 32768);
              const property = parseExpressions(parser, context);
              consume(parser, context, 20);
              return parseMemberOrUpdateExpression(parser, context, finishNode({
                  type: isOptional ? 'OptionalMemberExpression' : 'MemberExpression',
                  optional: isOptional === 1,
                  object: expr,
                  computed: true,
                  property
              }));
          }
          case 131083: {
              const args = parseArguments(parser, context);
              return parseMemberOrUpdateExpression(parser, context, context & 128
                  ? finishNode({
                      type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
                      callee: expr,
                      arguments: args,
                      optional: isOptional === 1,
                      typeParameters: null
                  })
                  : finishNode({
                      type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
                      callee: expr,
                      optional: isOptional === 1,
                      arguments: args
                  }));
          }
          case 16910400: {
              if ((context & 128) === 0)
                  return expr;
              const typeParameters = tryScan(parser, context, function () {
                  nextToken(parser, context);
                  const params = [];
                  while (parser.token !== 16910401) {
                      params.push(parseType(parser, context | 1073741824, 0, 0, 0));
                      if (parser.token !== 16910401) {
                          if (!consumeOpt(parser, context, 18))
                              break;
                      }
                  }
                  if (!consumeOpt(parser, context, 16910401)) {
                      return undefined;
                  }
                  return params && canFollowTypeArgumentsInExpression(parser)
                      ? finishNode({
                          type: 'TypeParameterInstantiation',
                          params
                      })
                      : undefined;
              });
              if (typeParameters === undefined)
                  return expr;
              let node;
              if (parser.token === 131083) {
                  const args = parseArguments(parser, context);
                  node =
                      context & 128
                          ? {
                              type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
                              callee: expr,
                              optional: isOptional === 1,
                              arguments: args,
                              typeParameters
                          }
                          : {
                              type: isOptional ? 'OptionalCallExpression' : 'CallExpression',
                              callee: expr,
                              optional: isOptional === 1,
                              arguments: args
                          };
              }
              else if (parser.token === 131081) {
                  node = parseTaggedTemplateExpression(parser, context, expr, typeParameters);
              }
              return parseMemberOrUpdateExpression(parser, context, node);
          }
          case 33685550: {
              if ((context & 128) === 0 || parser.precedingLineBreak)
                  return expr;
              nextToken(parser, context);
              return parseMemberOrUpdateExpression(parser, context, {
                  type: 'NonNullExpression',
                  expression: expr
              });
          }
          case 131080:
          case 131081:
              return parseMemberOrUpdateExpression(parser, context, parseTaggedTemplateExpression(parser, context, expr, []));
          case 23:
              nextToken(parser, context);
              isOptional = 1;
              optionalChaining = 1;
              if (parser.token & 36864) {
                  const property = parseIdentifier(parser, context);
                  return parseMemberOrUpdateExpression(parser, context, {
                      type: 'OptionalMemberExpression',
                      object: expr,
                      computed: false,
                      property,
                      optional: true
                  }, isOptional, optionalChaining);
              }
              return parseMemberOrUpdateExpression(parser, context, expr, isOptional, optionalChaining);
          default:
              return expr;
      }
  }
  function parseTaggedTemplateExpression(parser, context, expr, typeParameters) {
      return context & 128
          ? {
              type: 'TaggedTemplateExpression',
              typeParameters,
              tag: expr,
              quasi: parser.token === 131080
                  ? parseTemplateLiteral(parser, context)
                  : parseNoSubstitutionTemplate(parser, context | 65536)
          }
          : {
              type: 'TaggedTemplateExpression',
              tag: expr,
              quasi: parser.token === 131080
                  ? parseTemplateLiteral(parser, context)
                  : parseNoSubstitutionTemplate(parser, context | 65536)
          };
  }
  function parseArguments(parser, context) {
      nextToken(parser, context | 32768);
      const args = [];
      if (consumeOpt(parser, context, 16))
          return args;
      while (parser.token !== 16) {
          if (parser.token === 14) {
              args.push(parseSpreadElement(parser, context));
          }
          else {
              args.push(parseExpression(parser, context));
          }
          if (parser.token !== 18)
              break;
          nextToken(parser, context | 32768);
          if (parser.token === 16)
              break;
      }
      consume(parser, context, 16);
      return args;
  }
  function parseSpreadElement(parser, context) {
      context = (context | 134217728) ^ 134217728;
      consume(parser, context | 32768, 14);
      const argument = parseExpression(parser, context);
      return finishNode({
          type: 'SpreadElement',
          argument
      });
  }
  function parseLabelledStatement(parser, context, _t, expr, pos) {
      nextToken(parser, context | 32768);
      const body = (context & 1024) < 1 &&
          (context & 256) < 1 &&
          parser.token === 139353
          ? parseFunctionDeclaration(parser, context, 0, 1, 0, 0, false)
          : parseStatement(parser, context);
      return finishNode({
          type: 'LabeledStatement',
          label: expr,
          body
      });
  }
  function parseExpressionStatement(parser, context, expression) {
      consumeSemicolon(parser, context | 32768);
      return finishNode({
          type: 'ExpressionStatement',
          expression
      });
  }
  function parseFunctionDeclaration(parser, context, flags, origin, isAsync, allowGen, declare) {
      nextToken(parser, context);
      let id = null;
      const isTypescript = context & 128;
      const isGenerator = allowGen && optionalBit(parser, context, 16911156);
      if (parser.token === 131083) {
          if ((flags & 1) < 1)
              report(parser, context, 83, 1, 'Function');
      }
      else {
          validateFunctionName(parser, context | ((context & 3072) << 11), parser.token);
          id = parseIdentifier(parser, context);
      }
      const typeParameters = isTypescript && parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      context =
          ((context | 32243712) ^ 32243712) |
              67108864 |
              ((isAsync * 2 + isGenerator) << 21);
      let params;
      let returnType = null;
      if (isTypescript) {
          params = parseTypeScriptFormalParametersOrFormalList(parser, context);
          returnType =
              parser.token === 21 ? parseTypeOrTypePredicate(parser, context, 0) : null;
      }
      else {
          params = parseFormalParametersOrFormalList(parser, context);
      }
      const body = parseFunctionBody(parser, (context | 8192 | 4096 | 131072) ^
          (8192 | 4096 | 131072), origin);
      if (isTypescript) {
          return finishNode({
              type: body ? 'FunctionDeclaration' : 'DeclareFunction',
              params,
              body,
              async: isAsync === 1,
              generator: isGenerator === 1,
              id,
              typeParameters,
              returnType,
              declare
          });
      }
      return finishNode({
          type: 'FunctionDeclaration',
          params,
          body,
          async: isAsync === 1,
          generator: isGenerator === 1,
          id
      });
  }
  function parseFunctionExpression(parser, context, isAsync) {
      nextToken(parser, context);
      let id = null;
      const isTypescript = context & 128;
      const isGenerator = optionalBit(parser, context, 16911156);
      const generatorAndAsyncFlags = (isAsync * 2 + isGenerator) << 21;
      if ((parser.token & (8192 | 16384 | 36864)) !== 0) {
          validateFunctionName(parser, ((context | 0x1ec0000) ^ 0x1ec0000) | generatorAndAsyncFlags, parser.token);
          id = parseIdentifier(parser, context);
      }
      const typeParameters = isTypescript && parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      context =
          ((context | 32243712) ^ 32243712) |
              67108864 |
              generatorAndAsyncFlags;
      let params;
      let returnType = null;
      if (isTypescript) {
          params = parseTypeScriptFormalParametersOrFormalList(parser, context);
          returnType =
              parser.token === 21 ? parseTypeOrTypePredicate(parser, context, 0) : null;
      }
      else {
          params = parseFormalParametersOrFormalList(parser, context);
      }
      const body = parseFunctionBody(parser, context & ~(0x8001000 | 8192 | 4096 | 131072 | 16384), 0);
      if (isTypescript) {
          return finishNode({
              type: body ? 'FunctionExpression' : 'EmptyBodyFunctionExpression',
              params,
              body,
              async: isAsync === 1,
              generator: isGenerator === 1,
              id,
              typeParameters,
              returnType,
              declare: false
          });
      }
      return finishNode({
          type: 'FunctionExpression',
          params,
          body,
          async: isAsync === 1,
          generator: isGenerator === 1,
          id
      });
  }
  function parseUnionAndIntersectionType(parser, context, type, restrictedTypes, isMappedType, typeAlias) {
      type = parsePostFixTypeOrHigher(parser, context, type);
      if (parser.token === 16909893) {
          const types = [type];
          while (consumeOpt(parser, context, 16909893)) {
              types.push(parseTypeOperatorOrHigher(parser, context, 0, restrictedTypes, isMappedType, typeAlias));
          }
          type = finishNode({
              type: 'IntersectionType',
              types
          });
      }
      if (parser.token === 16909382) {
          const types = [type];
          while (consumeOpt(parser, context, 16909382)) {
              types.push(parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias));
          }
          type = finishNode({
              type: 'UnionType',
              types
          });
      }
      return type;
  }
  function parseTypeFromValue(parser, context, value) {
      let type = primaryTypes[value];
      if (type)
          return { type };
      type = parseIdentifierFromValue(parser, context, value, 0);
      type = parseQualifiedName(parser, context, type);
      return parseTypeReferenceFromExpression(parser, context, type);
  }
  function parseTypeOrTypePredicate(parser, context, restrictedTypes) {
      consumeOpt(parser, context, 21);
      const { token, tokenValue } = parser;
      let type;
      if (parser.token === 37000 || (token & 36864) === 0) {
          type = parseType(parser, context, 0, 0, 0);
      }
      else {
          nextToken(parser, context);
          type = parseIdentifierFromValue(parser, context, tokenValue, 0);
          if (parser.token === 36998 && !parser.precedingLineBreak) {
              type = finishNode({
                  type: 'TypePredicate',
                  assertsModifier: false,
                  parameterName: type,
                  typeAnnotation: parseTypeAnnotation(parser, context, restrictedTypes)
              });
          }
          else {
              type = parseTypeFromValue(parser, context, tokenValue);
              type = parseUnionAndIntersectionType(parser, context, type, restrictedTypes, 0, 0);
              if (parser.precedingLineBreak === 0 && consumeOpt(parser, context, 8278)) {
                  type = parseConditionalType(parser, context, restrictedTypes, 0, 0, type);
              }
          }
      }
      return finishNode({
          type: 'TypeAnnotation',
          typeAnnotation: type
      });
  }
  function parseTypescriptClassDeclaration(parser, context, flags, declare, abstract, exportDecorators = [], decl = false) {
      const decorators = flags & (2 | 1) || decl
          ? exportDecorators
          : parseDecorators(parser, context);
      nextToken(parser, context);
      context =
          (context | 16777216 | 1024 | 134217728) ^
              (134217728 | 16777216);
      let id = null;
      if (((parser.token & 4351) ^ 84) >
          4096) {
          if (isStrictReservedWord(parser, context, parser.token)) {
              report(parser, context, 62);
          }
          id = parseIdentifier(parser, context);
      }
      else {
          if ((flags & 1) < 1)
              report(parser, context, 83, 1, 'Class');
      }
      return parseTypescriptClassDeclarationOrExpression(parser, context, id, decorators, 8, 0, declare, abstract, 'ClassDeclaration', 'ClassImplements');
  }
  function parseTypescriptClassDeclarationOrExpression(parser, context, id, decorators, origin, isExpr, declare, abstract, type, heritage) {
      let superClass = null;
      let superTypeParameters = [];
      const implement = [];
      const typeParameters = parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      let inheritedContext = context;
      if (parser.token === 8278) {
          nextToken(parser, context | 32768);
          inheritedContext |= 524288;
          superClass = parseLeftHandSideExpression(parser, context, 0);
      }
      else {
          inheritedContext = (inheritedContext | 524288) ^ 524288;
      }
      if (parser.token === 16910400)
          superTypeParameters = parseTypeParameterInstantiation(parser, context);
      if (parser.token === 16485) {
          nextToken(parser, context | 32768);
          let delimitedCount = 0;
          while ((parser.token & 110592) > 0) {
              implement.push(parseHeritageClausesOrClassImplements(parser, inheritedContext, heritage));
              delimitedCount++;
              if (parser.token !== 18)
                  break;
              consume(parser, context, 18);
          }
          if (!delimitedCount)
              report(parser, context, 80);
      }
      const body = parseClassMembers(parser, inheritedContext, context, origin, isExpr, abstract, declare);
      return finishNode({
          type,
          id,
          superClass,
          body,
          typeParameters,
          superTypeParameters,
          implements: implement,
          abstract: abstract === 1,
          declare: declare === 1,
          decorators
      });
  }
  function parseClassDeclaration(parser, context, flags) {
      nextToken(parser, context);
      context = (context | 16777216 | 134217728) ^ (134217728 | 16777216);
      let id = null;
      if (((parser.token & 4351) ^ 84) >
          4096) {
          if (isStrictReservedWord(parser, context, parser.token)) {
              report(parser, context, 62);
          }
          id = parseIdentifier(parser, context);
      }
      else {
          if ((flags & 1) < 1)
              report(parser, context, 83, 1, 'Class');
      }
      return parseClassDeclarationOrExpression(parser, context, id, 8, 'ClassDeclaration');
  }
  function parseClassDeclarationOrExpression(parser, context, id, origin, type) {
      let inheritedContext = context | 1024;
      let superClass = null;
      if (parser.token === 8278) {
          nextToken(parser, context | 32768);
          superClass = parseLeftHandSideExpression(parser, context, 0);
          inheritedContext |= 524288;
      }
      else {
          inheritedContext = (inheritedContext | 524288) ^ 524288;
      }
      const body = parseClassBody(parser, inheritedContext, context, origin);
      return finishNode({
          type,
          id,
          superClass,
          body
      });
  }
  function parseTypescriptClassExpression(parser, context) {
      nextToken(parser, context);
      context =
          (context | 16777216 | 1024 | 134217728) ^
              (134217728 | 16777216);
      const decorators = [];
      let id = null;
      if (((parser.token & 0x10ff) ^ 0x54) > 0x1000 && parser.token !== 16485) {
          if (isStrictReservedWord(parser, context, parser.token)) {
              report(parser, context, 62);
          }
          id = parseIdentifier(parser, context);
      }
      return parseTypescriptClassDeclarationOrExpression(parser, context, id, decorators, 0, 1, 0, 0, 'ClassExpression', 'InterfaceHeritage');
  }
  function parseClassExpression(parser, context) {
      let id = null;
      context =
          (context | 16777216 | 1024 | 134217728) ^
              (134217728 | 16777216);
      if (parser.token === 142)
          report(parser, context, 100);
      nextToken(parser, context);
      if (((parser.token & 0x10ff) ^ 0x54) > 0x1000) {
          id = parseIdentifier(parser, context);
      }
      return parseClassDeclarationOrExpression(parser, context, id, 0, 'ClassExpression');
  }
  function parseClassBody(parser, context, inheritedContext, origin) {
      consume(parser, context | 32768, 4325388);
      context = (context | 134217728) ^ 134217728;
      const body = [];
      parser.flags = (parser.flags | 1) ^ 1;
      while (parser.token !== 2097167) {
          if (consumeOpt(parser, context, 2097169)) {
              continue;
          }
          body.push(parseClassElementList(parser, context, inheritedContext, 0));
      }
      consume(parser, origin & 8 ? inheritedContext | 32768 : context, 2097167);
      return finishNode({
          type: 'ClassBody',
          body
      });
  }
  function parseClassMembers(parser, context, inheritedContext, origin, isExpr, isAbstract, isDeclared) {
      consume(parser, context | 32768, 4325388);
      context = (context | 134217728) ^ 134217728;
      let decorators = [];
      parser.flags = (parser.flags | 1) ^ 1;
      const body = [];
      if (isExpr && parser.token === 142)
          report(parser, context, 99);
      while (parser.token !== 2097167) {
          if (consumeOpt(parser, context, 2097169)) {
              continue;
          }
          decorators = parseDecorators(parser, context);
          body.push(parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, 0));
      }
      consume(parser, origin & 8 ? inheritedContext | 32768 : context, 2097167);
      return finishNode({
          type: 'ClassBody',
          body
      });
  }
  function parseClassElementList(parser, context, inheritedContext, modifiers) {
      let kind = 0;
      let key = null;
      const { token } = parser;
      if (parser.token & (8192 | 36864 | 16384)) {
          key = parseIdentifier(parser, context);
          switch (token) {
              case 540779:
                  if ((modifiers & 32) === 0 && parser.token !== 131083) {
                      return parseClassElementList(parser, context, inheritedContext, modifiers | 32);
                  }
                  break;
              case 430190:
                  if (parser.token !== 131083 && parser.precedingLineBreak === 0) {
                      kind |= 16 | (optionalBit(parser, context, 16911156) ? 8 : 0);
                  }
                  break;
              case 4209:
                  if (parser.token !== 131083) {
                      kind |= 256;
                  }
                  break;
              case 4210:
                  if (parser.token !== 131083) {
                      kind |= 512;
                  }
                  break;
              default:
          }
      }
      else if (token === 4325395) {
          kind |= 2;
          key = parseComputedPropertyName(parser, inheritedContext);
      }
      else if ((token & 268435456) === 268435456) {
          key = parseLiteral(parser, context);
      }
      else if (token === 16911156) {
          kind |= 8;
          nextToken(parser, context);
      }
      else {
          report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
      }
      if (kind & (8 | 16 | 768)) {
          if (parser.token & (8192 | 36864 | 16384)) {
              key = parseIdentifier(parser, context);
          }
          else if ((parser.token & 268435456) === 268435456) {
              key = parseLiteral(parser, context);
          }
          else if (parser.token === 4325395) {
              kind |= 2;
              key = parseComputedPropertyName(parser, context);
          }
          else {
              report(parser, context, 0);
          }
      }
      if ((kind & 2) < 1) {
          if (parser.tokenValue === 'constructor') {
              if ((modifiers & 32) < 1 && parser.token === 131083) {
                  if (kind & (768 | 16 | 8)) {
                      report(parser, context, 66, 1, 'accessor');
                  }
                  else if ((context & 524288) < 1) {
                      if (parser.flags & 1)
                          report(parser, context, 67);
                      else
                          parser.flags |= 1;
                  }
              }
              kind |= 64;
          }
      }
      const value = parseMethodDefinition(parser, context, kind);
      return finishNode({
          type: 'MethodDefinition',
          kind: (modifiers & 32) < 1 && kind & 64
              ? 'constructor'
              : kind & 256
                  ? 'get'
                  : kind & 512
                      ? 'set'
                      : 'method',
          static: (modifiers & 32) > 0,
          computed: (kind & 2) > 0,
          key,
          value
      });
  }
  function parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers) {
      let key = null;
      let kind = 0;
      let value;
      let isUnambiguouslyIndexSignature = 0;
      const { token } = parser;
      const isConstructor = token === 4208;
      if (token & (36864 | 8192 | 16384)) {
          key = parseOptionalIdentifier(parser, context);
          switch (token) {
              case 540779: {
                  if ((32 & modifiers) === 0 &&
                      (parser.token & (16384 | 36864) || parser.token === 4325395)) {
                      return parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers | 32);
                  }
                  break;
              }
              case 540776: {
                  if (32 & modifiers)
                      report(parser, context, 38, 0, 'private', 'static');
                  if (16 & modifiers)
                      report(parser, context, 38, 0, 'private', 'readonly');
                  if ((4 & modifiers) === 0 &&
                      (parser.token & (16384 | 36864) || parser.token === 4325395)) {
                      return parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers | 4);
                  }
                  break;
              }
              case 540777: {
                  if (1 & modifiers)
                      report(parser, context, 38, 0, 'protected', 'abstract');
                  if (32 & modifiers)
                      report(parser, context, 38, 0, 'protected', 'static');
                  if (16 & modifiers)
                      report(parser, context, 38, 0, 'protected', 'readonly');
                  if ((8 & modifiers) === 0 &&
                      (parser.token & (16384 | 36864) || parser.token === 4325395)) {
                      return parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers | 8);
                  }
                  break;
              }
              case 540778: {
                  if (1 & modifiers)
                      report(parser, context, 38, 0, 'public', 'abstract');
                  if (32 & modifiers)
                      report(parser, context, 38, 0, 'public', 'static');
                  if (16 & modifiers)
                      report(parser, context, 38, 0, 'public', 'readonly');
                  if (14 & modifiers)
                      report(parser, context, 40, 0, 'Accessibility');
                  if ((2 & modifiers) === 0 &&
                      (parser.token & (16384 | 36864) || parser.token === 4325395)) {
                      return parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers | 2);
                  }
                  break;
              }
              case 561287: {
                  if ((16 & modifiers) === 0 &&
                      parser.token !== 2097169 &&
                      parser.token !== 8388638 &&
                      parser.token !== 2097167 &&
                      parser.token !== 131083) {
                      return parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers | 16);
                  }
                  break;
              }
              case 134779008: {
                  if (!isAbstract && parser.token & 36864)
                      report(parser, context, 41);
                  if ((1 & modifiers) === 0 &&
                      (parser.token & (16384 | 36864) || parser.token === 4325395)) {
                      return parseClassElements(parser, context, inheritedContext, decorators, isAbstract, isDeclared, modifiers | 1);
                  }
                  break;
              }
              case 430190:
                  if (parser.token !== 131083 &&
                      parser.token !== 16910400 &&
                      parser.token !== 21 &&
                      parser.token !== 18 &&
                      parser.token !== 8388638 &&
                      parser.token !== 2097167 &&
                      parser.token !== 2097169 &&
                      !parser.precedingLineBreak) {
                      kind |= 16 | (optionalBit(parser, context, 16911156) ? 8 : 0);
                  }
                  break;
              case 4209:
                  if (parser.token !== 131083 &&
                      parser.token !== 16910400 &&
                      parser.token !== 21 &&
                      parser.token !== 8388638 &&
                      parser.token !== 2097167 &&
                      parser.token !== 2097169) {
                      kind |= 256;
                  }
                  break;
              case 4210:
                  if (parser.token !== 131083 &&
                      parser.token !== 16910400 &&
                      parser.token !== 21 &&
                      parser.token !== 8388638 &&
                      parser.token !== 2097167 &&
                      parser.token !== 2097169) {
                      kind |= 512;
                  }
                  break;
              default:
          }
      }
      else if (token === 4325395) {
          let hasTypeAnnotation = 0;
          nextToken(parser, context);
          if ((parser.token & 524288) === 524288) {
              report(parser, context, 49, 0, 'Accessibility');
          }
          kind |= 2;
          if ((parser.token & 36864) === 36864) {
              const { tokenValue } = parser;
              nextToken(parser, context);
              if (parser.token === 22) {
                  report(parser, context, 50);
              }
              if (parser.token === 21) {
                  isUnambiguouslyIndexSignature = 1;
                  hasTypeAnnotation = 1;
                  let typeAnnotation = [];
                  if (consumeOpt(parser, context, 21)) {
                      if (parser.token & 4194304 || parser.token === 131083) {
                          report(parser, context, 78);
                      }
                      typeAnnotation = parseTypeAnnotationNoConsume(parser, context, 1);
                  }
                  if (parser.token === 18) {
                      report(parser, context, 52);
                  }
                  if (parser.token === 16918578)
                      report(parser, context, 77);
                  key = {
                      type: 'Identifier',
                      name: tokenValue,
                      optional: false,
                      typeAnnotation
                  };
              }
              else {
                  if (parser.token === 18) {
                      report(parser, context, 52);
                  }
                  kind |= 2;
                  key = parseIdentifierFromValue(parser, context, tokenValue, 0);
              }
              if (parser.token !== 20) {
                  key = parseMemberOrUpdateExpression(parser, context, key);
                  key = parseAssignmentExpression(parser, context, key);
              }
          }
          else {
              if (parser.token === 14) {
                  report(parser, context, 53);
              }
              key = parseExpression(parser, context);
          }
          consume(parser, context, 20);
          if (hasTypeAnnotation && parser.token !== 21)
              report(parser, context, 51);
          consumeOpt(parser, context, 22);
      }
      else if ((token & 268435456) === 268435456) {
          key = parseLiteral(parser, context);
      }
      else if (token === 16911156) {
          if (isDeclared)
              report(parser, context, 70);
          kind |= 8;
          nextToken(parser, context);
      }
      else {
          report(parser, context, 0);
      }
      if (kind & (8 | 16 | 768) && parser.token !== 16910400) {
          if (parser.token & (36864 | 16384)) {
              key = parseIdentifier(parser, context);
          }
          else if ((parser.token & 268435456) === 268435456) {
              key = parseLiteral(parser, context);
          }
          else if (parser.token === 4325395) {
              kind |= 2;
              key = parseComputedPropertyName(parser, context);
          }
          else {
              report(parser, context, 0);
          }
      }
      if (isUnambiguouslyIndexSignature) {
          if (modifiers & 32) {
              report(parser, context, 49, 0, 'static');
          }
          if (modifiers & (14 | 1)) {
              report(parser, context, 49, 0, 'Accessibility and abstract');
          }
          consume(parser, context, 21);
          const typeAnnotation = parseType(parser, context, 0, 0, 0);
          return finishNode({
              type: 'IndexSignature',
              parameters: [key],
              typeAnnotation,
              readonly: (kind & 8192) < 1,
              accessibility: null,
              export: false,
              static: false
          });
      }
      if ((kind & 2) < 1) {
          if (parser.tokenValue === 'constructor') {
              if ((modifiers & 32) < 1 && parser.token === 131083) {
                  if (kind & (768 | 16 | 128 | 8)) ;
                  else if ((context & 524288) < 1) {
                      parser.flags |= 1;
                  }
              }
              kind |= 64;
          }
      }
      if (parser.token === 16910400 || parser.token === 131083) {
          if (16 & modifiers)
              report(parser, context, 44);
          value = parseTypeScriptMethodDefinition(parser, context, isConstructor, kind, modifiers, isDeclared);
          return finishNode({
              type: 1 & modifiers ? 'AbstractMethodDefinition' : 'MethodDefinition',
              kind: (modifiers & 32) < 1 && kind & 64
                  ? 'constructor'
                  : kind & 256
                      ? 'get'
                      : kind & 512
                          ? 'set'
                          : 'method',
              static: (modifiers & 32) > 0,
              computed: (kind & 2) > 0,
              key,
              decorators,
              value,
              accessibility: modifiers & 2
                  ? 'public'
                  : modifiers & 4
                      ? 'private'
                      : modifiers & 8
                          ? 'protected'
                          : null,
              typeParameters: null
          });
      }
      return parseClassProperty(parser, context, key, kind, modifiers, decorators);
  }
  function parseClassProperty(parser, context, key, kind, modifiers, decorators) {
      if (kind & (8 | 16)) {
          report(parser, context, kind & 8 ? 45 : 63);
      }
      if ((modifiers & 32) === 0 && kind & 64) {
          report(parser, context, 36);
      }
      const optional = consumeOpt(parser, context, 22);
      const definite = consumeOpt(parser, context, 33685550);
      if (!optional && definite && parser.token !== 21)
          report(parser, context, 48);
      const typeAnnotation = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
      let value = null;
      if (parser.token === 8388638) {
          nextToken(parser, context);
          if (modifiers & 32 && parser.token === 139360)
              report(parser, context, 91);
          value = parseLeftHandSideExpression(parser, context, 1);
          value = parseAssignmentExpression(parser, context, value);
      }
      return finishNode({
          type: modifiers & 1 ? 'AbstractClassProperty' : 'ClassProperty',
          key,
          value: value,
          computed: (kind & 2) > 0,
          static: (modifiers & 32) > 0,
          readonly: (kind & 8192) > 0,
          decorators,
          accessibility: modifiers & 2
              ? 'public'
              : modifiers & 4
                  ? 'private'
                  : modifiers & 8
                      ? 'protected'
                      : null,
          optional,
          definite,
          typeAnnotation
      });
  }
  function parseConstructorFormals(parser, context, declare) {
      consume(parser, context, 131083);
      const params = [];
      let left;
      let hasInitializer = 0;
      while (parser.token !== 16) {
          if (parser.token & (36864 | 16384)) {
              const { token } = parser;
              left = parseBindingIdentifier(parser, context, 0, 1);
              if ((token & 524288) === 524288 &&
                  (parser.token & (16384 | 36864)) > 0) {
                  left = parseParameterProperty(parser, context, token, []);
              }
          }
          else {
              const decorators = parser.token === 142 ? parseDecorators(parser, context | 1048576) : [];
              const { token } = parser;
              if (parser.token === 4325388) {
                  left = parseObjectLiteralOrPattern(parser, context, 1, 1, decorators);
              }
              else if (parser.token === 4325395) {
                  left = parseArrayExpressionOrPattern(parser, context, 1, 1, decorators);
              }
              else if (parser.token === 14) {
                  left = parseSpreadOrRestElement(parser, context, 16, 1, decorators);
              }
              else if ((parser.token & (36864 | 8192 | 16384)) > 0) {
                  left = parseBindingIdentifier(parser, context, 0, 1);
                  left.decorators = decorators;
              }
              else {
                  report(parser, context, 0);
              }
              if ((token & 524288) === 524288 &&
                  (parser.token & (16384 | 36864)) > 0) {
                  left = parseParameterProperty(parser, context, token, decorators);
              }
          }
          if (parser.token === 8388638) {
              nextToken(parser, context | 32768);
              hasInitializer = 1;
              left = finishNode({
                  type: 'AssignmentPattern',
                  left,
                  right: parseExpression(parser, context)
              });
          }
          params.push(left);
          if (parser.token !== 16)
              consume(parser, context, 18);
      }
      consume(parser, context, 16);
      if (parser.token !== 4325388) {
          if (hasInitializer && parser.token !== 4325388)
              report(parser, context, 73);
          if (declare)
              report(parser, context, 68);
      }
      return params;
  }
  function parseParameterProperty(parser, context, token, decorators) {
      if (parser.token === 540779)
          report(parser, context, 55);
      let parameter = null;
      const { tokenValue } = parser;
      const modifiers = (token === 540776 ? 4 : 0) |
          (token === 540778 ? 2 : 0) |
          (token === 540777 ? 8 : 0) |
          (consumeOpt(parser, context, 561287) ? 16 : 0);
      if (parser.token === 16) {
          parameter = parseIdentifierFromValue(parser, context, tokenValue, 1);
      }
      else {
          const { token } = parser;
          parameter = parseBindingIdentifier(parser, context, 0, 1);
          if ((parser.token & (4096 | 8192 | 16384 | 36864)) > 0) {
              parameter = parseBindingIdentifier(parser, context, 0, 1);
          }
          else if ((token & 524288) === 524288) {
              report(parser, context, 59, 0, KeywordDescTable[token & 255]);
          }
      }
      if (parser.token === 8388638) {
          nextToken(parser, context | 32768);
          parameter = finishNode({
              type: 'AssignmentPattern',
              left: parameter,
              right: parseExpression(parser, context)
          });
      }
      return finishNode({
          type: 'ParameterProperty',
          accessibility: modifiers & 2
              ? 'public'
              : modifiers & 4
                  ? 'private'
                  : modifiers & 8
                      ? 'protected'
                      : null,
          readonly: (modifiers & 16) > 0,
          static: false,
          export: false,
          parameter,
          decorators
      });
  }
  function parseTypeScriptFormalParametersOrFormalList(parser, context) {
      const params = [];
      let left;
      context = (context | 134217728) ^ 134217728;
      nextToken(parser, context);
      while (parser.token !== 16) {
          const { tokenValue, token } = parser;
          if ((token & (36864 | 8192 | 16384)) > 0) {
              if ((token & 524288) === 524288) {
                  nextToken(parser, context);
                  if ((parser.token & (36864 | 16384)) > 0) {
                      report(parser, context, 60);
                  }
                  left = parseIdentifierFromValue(parser, context, tokenValue, 1);
              }
              else {
                  left = parseBindingIdentifier(parser, context, 0, 1);
              }
          }
          else {
              const decorators = token === 142 ? parseDecorators(parser, context | 1048576) : [];
              if (parser.token === 4325388) {
                  left = parseObjectLiteralOrPattern(parser, context, 1, 1, decorators);
              }
              else if (parser.token === 4325395) {
                  left = parseArrayExpressionOrPattern(parser, context, 1, 1, decorators);
              }
              else if (parser.token === 14) {
                  left = parseSpreadOrRestElement(parser, context, 16, 1, decorators);
              }
              else if ((parser.token & (36864 | 8192 | 16384)) > 0) {
                  left = parseBindingIdentifier(parser, context, 0, 1);
                  left.decorators = decorators;
              }
              else {
                  report(parser, context, 0);
              }
              reinterpretToPattern(parser, left);
          }
          if (parser.token === 8388638) {
              nextToken(parser, context | 32768);
              const right = parseExpression(parser, context);
              left = finishNode({
                  type: 'AssignmentPattern',
                  left,
                  right
              });
          }
          params.push(left);
          if (parser.token !== 16)
              consume(parser, context, 18);
      }
      consume(parser, context, 16);
      return params;
  }
  function parseFormalParametersOrFormalList(parser, context) {
      const params = [];
      let left;
      context = (context | 134217728) ^ 134217728;
      nextToken(parser, context);
      while (parser.token !== 16) {
          const { token } = parser;
          if ((token & (36864 | 8192 | 16384)) > 0) {
              left = parseIdentifier(parser, context);
          }
          else {
              if (token === 4325388) {
                  left = parseObjectLiteralOrPattern(parser, context, 1, 1, []);
              }
              else if (token === 4325395) {
                  left = parseArrayExpressionOrPattern(parser, context, 1, 1, []);
              }
              else if (token === 14) {
                  left = parseSpreadOrRestElement(parser, context, 16, 1, []);
              }
              else {
                  report(parser, context, 0);
              }
              reinterpretToPattern(parser, left);
          }
          if (parser.token === 8388638) {
              nextToken(parser, context | 32768);
              const right = parseExpression(parser, context);
              left = finishNode({
                  type: 'AssignmentPattern',
                  left,
                  right
              });
          }
          params.push(left);
          if (parser.token !== 16)
              consume(parser, context, 18);
      }
      consume(parser, context, 16);
      return params;
  }
  function parseFunctionBody(parser, context, origin) {
      if (context & 128 && parser.token !== 4325388) {
          if (canParseSemicolon(parser)) {
              consumeSemicolon(parser, context);
              return null;
          }
          report(parser, context, 1, 0, ';');
      }
      consume(parser, context | 32768, 4325388);
      const body = [];
      if (parser.token !== 2097167) {
          while (parser.token === 268566531) {
              if (parser.index - parser.tokenPos < 13 && parser.tokenValue === 'use strict') {
                  if ((parser.token & 2097152) === 2097152 || parser.precedingLineBreak === 0) {
                      context |= 1024;
                  }
              }
              body.push(parseStatementListItem(parser, context, parser.tokenPos));
          }
          while (parser.token !== 2097167) {
              body.push(parseStatementListItem(parser, context));
          }
      }
      consume(parser, origin & (16 | 8) ? context | 32768 : context, 2097167);
      return finishNode({
          type: 'BlockStatement',
          body
      });
  }
  function parseBlock(parser, context) {
      const body = [];
      consume(parser, context | 32768, 4325388);
      while (parser.token !== 2097167) {
          body.push(parseStatementListItem(parser, context, parser.startPos));
      }
      consume(parser, context | 32768, 2097167);
      return finishNode({
          type: 'BlockStatement',
          body
      });
  }
  function parsePrimaryExpression(parser, context, isLHS, inParens) {
      if (parser.token === 430190) {
          return parseAsyncExpression(parser, context, isLHS, 0);
      }
      if (parser.token === 184428)
          return parseYieldExpression(parser, context);
      if ((parser.token & 36864) > 0) {
          if (parser.token === 168047)
              return parseAwaitExpression(parser, context);
          const expr = inParens && context & 128
              ? parseBindingIdentifier(parser, context, 0, 0)
              : parseIdentifier(parser, context);
          if (parser.token === 10) {
              return parseArrowFunctionExpression(parser, context, [expr], null, null, isLHS, 0);
          }
          return expr;
      }
      if ((parser.token & 268435456) === 268435456) {
          return parseLiteral(parser, context);
      }
      if ((parser.token & 67239936) === 67239936) {
          if (!isLHS)
              report(parser, context, 0);
          return parseUpdateExpressionPrefixed(parser, context, 0);
      }
      if ((parser.token & 33685504) === 33685504) {
          if (!isLHS)
              report(parser, context, 0);
          return parseUnaryExpression(parser, context);
      }
      switch (parser.token) {
          case 139269:
          case 139270:
          case 139271:
              return parseNullOrTrueOrFalseLiteral(parser, context);
          case 139360:
              return parseThisExpression(parser, context);
          case 131076:
              return parseRegExpLiteral(parser, context);
          case 139353:
              return parseFunctionExpression(parser, context, 0);
          case 4325388:
              return parseObjectLiteral(parser, context, 0);
          case 4325395:
              return parseArrayLiteral(parser, context, 0);
          case 131083:
              return context & 128
                  ? parseTypescriptParenthesizedExpression(parser, context, isLHS, [], 0)
                  : parseParenthesizedExpression(parser, context, isLHS);
          case 142:
          case 139343:
              return context & 128
                  ? parseTypescriptClassExpression(parser, context)
                  : parseClassExpression(parser, context);
          case 139358:
              return parseSuperExpression(parser, context);
          case 131081:
              return parseNoSubstitutionTemplate(parser, context);
          case 131080:
              return parseTemplateLiteral(parser, context);
          case 139356:
              return parseNewExpression(parser, context);
          case 123:
              return parseBigIntLiteral(parser, context);
          case 139355:
              return parseImportCallOrMetaExpression(parser, context);
          case 16910400:
              return parseJSXOrTypeAssertion(parser, context);
          default:
              if (isValidIdentifier(context, parser.token))
                  return parseIdentifierOrArrow(parser, context);
              report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
              nextToken(parser, context);
      }
  }
  function parseImportCallOrMetaExpression(parser, context) {
      let expr = parseIdentifier(parser, context);
      expr = parseImportExpression(parser, context);
      return parseMemberOrUpdateExpression(parser, context, expr);
  }
  function parseImportExpression(parser, context) {
      consume(parser, context | 32768, 131083);
      if (parser.token === 14)
          report(parser, context, 0);
      const source = parseExpression(parser, context);
      consume(parser, context, 16);
      return finishNode({
          type: 'ImportExpression',
          source
      });
  }
  function parseTypeParameterFromValue(parser, context, value) {
      return finishNode({
          type: 'TypeParameter',
          name: parseIdentifierFromValue(parser, context, value, 1),
          constraint: consumeOpt(parser, context, 8278)
              ? parseType(parser, context, 0, 0, 0)
              : null,
          default: consumeOpt(parser, context | 32768, 8388638)
              ? parseType(parser, context, 0, 0, 0)
              : null
      });
  }
  function parseJSXOrTypeAssertion(parser, context) {
      if (context & 16 && ((parser.token & 36864) | 36998) !== 0) {
          return parseJSXRootElementOrFragment(parser, context, 1);
      }
      if ((context & 128) < 1)
          report(parser, context, 1, 0, '<');
      nextToken(parser, context | 32768);
      const params = [];
      let isTypeParameter = 0;
      while (parser.token !== 16910401) {
          const { token, tokenValue } = parser;
          context = context | 268435456;
          if ((token & (36864 | 8192 | 16384)) !== 0) {
              nextToken(parser, context | 32768);
              if (parser.token === 18 || parser.token === 8278 || parser.token === 8388638) {
                  isTypeParameter = 1;
                  params.push(parseTypeParameterFromValue(parser, context, tokenValue));
                  if (parser.token !== 16910401)
                      consume(parser, context | 32768, 18);
              }
              else if (isTypeParameter) {
                  params.push(parseTypeParameterFromValue(parser, context, tokenValue));
              }
              else {
                  if (consumeOpt(parser, context | 32768, 16910401)) {
                      if (parser.token === 131083) {
                          return parseTypescriptParenthesizedExpression(parser, context, 1, tokenValue, 8);
                      }
                      else {
                          return parseTypeAssertion(parser, context, parseTypeFromValue(parser, context, tokenValue));
                      }
                  }
                  else {
                      let type = parseTypeFromValue(parser, context, parser.tokenValue);
                      type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
                      consume(parser, context | 32768, 16910401);
                      return parser.token === 131083
                          ? parseTypescriptParenthesizedExpression(parser, context, 1, type, 4)
                          : parseTypeAssertion(parser, context, type);
                  }
              }
          }
          else {
              const type = parseType(parser, context, 0, 0, 0);
              consume(parser, context | 32768, 16910401);
              if (parser.token === 131083) {
                  return parseTypescriptParenthesizedExpression(parser, context, 1, type, 4);
              }
              return finishNode({
                  type: 'TypeAssertion',
                  typeAnnotation: type,
                  expression: parsePrimaryExpression(parser, context, 1, 0)
              });
          }
      }
      consume(parser, context | 32768, 16910401);
      if (parser.token !== 131083)
          report(parser, context, 0);
      return parseTypescriptParenthesizedExpression(parser, context, 1, finishNode({
          type: 'TypeParameterDeclaration',
          params
      }), 1);
  }
  function parseTypeAssertion(parser, context, typeAnnotation) {
      return finishNode({
          type: 'TypeAssertion',
          typeAnnotation,
          expression: parsePrimaryExpression(parser, context, 1, 0)
      });
  }
  function parseAsyncExpression(parser, context, isLHS, inNew) {
      let expr = parseIdentifier(parser, context);
      if (parser.precedingLineBreak === 0) {
          if (parser.token === 139353) {
              return parseFunctionExpression(parser, context, 1);
          }
          if ((parser.token & 36864) === 36864) {
              if (!isLHS)
                  report(parser, context, 0);
              expr = parseArrowFunctionExpression(parser, context, [parseIdentifier(parser, context)], null, null, 1, 1);
          }
      }
      let typeParameters = null;
      if (context & 128 && parser.token === 16910400) {
          typeParameters = parseAsyncIdentifierOrParameterInstantiation(parser, context);
          if (typeParameters !== undefined && parser.token !== 131083)
              report(parser, context, 0);
      }
      if (!inNew && parser.token === 131083) {
          expr = parseAsyncArrowOrCallExpression(parser, context, isLHS, typeParameters, expr);
      }
      if (parser.token === 10) {
          return parseArrowFunctionExpression(parser, context, [expr], null, [], 1, 0);
      }
      return expr;
  }
  function parseAwaitExpression(parser, context) {
      if (context & 4194304) {
          nextToken(parser, context | 32768);
          const argument = parseLeftHandSideExpression(parser, context, 1);
          return finishNode({
              type: 'AwaitExpression',
              argument
          });
      }
      return parseIdentifierOrArrow(parser, context);
  }
  function parseYieldExpression(parser, context) {
      if (context & 2097152) {
          nextToken(parser, context | 32768);
          let argument = null;
          let delegate = false;
          if (parser.precedingLineBreak === 0) {
              delegate = consumeOpt(parser, context | 32768, 16911156);
              if (parser.token & 131072 || delegate) {
                  argument = parseExpression(parser, context);
              }
          }
          return finishNode({
              type: 'YieldExpression',
              argument,
              delegate
          });
      }
      return parseIdentifierOrArrow(parser, context);
  }
  function parseIdentifierOrArrow(parser, context) {
      const expr = parseIdentifier(parser, context);
      if (parser.token === 10) {
          return parseArrowFunctionExpression(parser, context, [expr], null, null, 1, 0);
      }
      return expr;
  }
  function parseObjectLiteral(parser, context, skipInitializer) {
      return parseObjectLiteralOrPattern(parser, context, skipInitializer, 0, []);
  }
  function parseObjectLiteralOrPattern(parser, context, skipInitializer, isPattern, decorators) {
      nextToken(parser, context);
      const properties = [];
      context = (context | 134217728) ^ 134217728;
      while (parser.token !== 2097167) {
          const { token } = parser;
          if (token === 14) {
              properties.push(parseSpreadOrRestElement(parser, context, 2097167, 0, []));
          }
          else {
              let state = 0;
              let key = null;
              let value;
              if (token & (8192 | 4096 | 36864 | 16384)) {
                  key = parseIdentifier(parser, context);
                  if (parser.token === 18 || parser.token === 2097167 || parser.token === 8388638) {
                      state |= 4;
                      if (consumeOpt(parser, context | 32768, 8388638)) {
                          const right = parseExpression(parser, context);
                          value = finishNode({
                              type: 'AssignmentPattern',
                              left: key,
                              right
                          });
                      }
                      else {
                          value = key;
                      }
                  }
                  else if (consumeOpt(parser, context | 32768, 21)) {
                      if (parser.token & (8192 | 36864 | 16384)) {
                          value = parsePrimaryExpression(parser, context, 1, 0);
                          value = parseMemberOrUpdateExpression(parser, context, value);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else if (parser.token === 8388638) {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                          else {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                      }
                      else if ((parser.token & 4194304) === 4194304) {
                          value =
                              parser.token === 4325388
                                  ? parseObjectLiteralOrPattern(parser, context, 0, isPattern, decorators)
                                  : parseArrayExpressionOrPattern(parser, context, 0, isPattern, []);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              const { token } = parser;
                              if (token !== 18 && token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                      else {
                          value = parseLeftHandSideExpression(parser, context, 1);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              const { token } = parser;
                              if (token !== 18 && token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                  }
                  else if (parser.token === 4325395) {
                      if (token === 430190)
                          state |= 16;
                      state |=
                          (token === 4209
                              ? 256
                              : token === 4210
                                  ? 512
                                  : 1) | 2;
                      key = parseComputedPropertyName(parser, context);
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if (parser.token & (8192 | 36864 | 16384)) {
                      key = parseIdentifier(parser, context);
                      if (token === 430190)
                          state |= 16;
                      state |=
                          token === 4209
                              ? 256
                              : token === 4210
                                  ? 512
                                  : 1;
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if (parser.token === 131083) {
                      state |= 1;
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if (parser.token === 16911156) {
                      nextToken(parser, context);
                      state |=
                          8 | 1 | (token === 430190 ? 16 : 0);
                      if (parser.token & (8192 | 36864 | 16384)) {
                          key = parseIdentifier(parser, context);
                      }
                      else if ((parser.token & 268435456) === 268435456) {
                          key = parseLiteral(parser, context);
                      }
                      else if (parser.token === 4325395) {
                          state |= 2;
                          key = parseComputedPropertyName(parser, context);
                      }
                      else {
                          report(parser, context, 0);
                      }
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if ((parser.token & 268435456) === 268435456) {
                      if (token === 430190)
                          state |= 16;
                      state |=
                          token === 4209
                              ? 256
                              : token === 4210
                                  ? 512
                                  : 1;
                      key = parseLiteral(parser, context);
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if (context & 128 && parser.token === 16910400) {
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else {
                      report(parser, context, 0);
                  }
              }
              else if ((parser.token & 268435456) === 268435456) {
                  key = parseLiteral(parser, context);
                  if (parser.token === 21) {
                      consume(parser, context | 32768, 21);
                      if (parser.token & (8192 | 36864 | 16384)) {
                          value = parsePrimaryExpression(parser, context, 1, 0);
                          value = parseMemberOrUpdateExpression(parser, context, value);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else if (parser.token === 8388638) {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                          else {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                      }
                      else if ((parser.token & 4194304) === 4194304) {
                          value =
                              parser.token === 4325388
                                  ? parseObjectLiteralOrPattern(parser, context, 0, isPattern, decorators)
                                  : parseArrayExpressionOrPattern(parser, context, 0, isPattern, []);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              if (parser.token !== 18 && parser.token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                              else if (parser.token !== 8388638) ;
                          }
                      }
                      else {
                          value = parseLeftHandSideExpression(parser, context, 1);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              if (parser.token !== 18 && parser.token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                  }
                  else if (parser.token === 131083) {
                      state |= 1;
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if (context & 128 && parser.token === 16910400) {
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else {
                      report(parser, context, 0);
                  }
              }
              else if (parser.token === 4325395) {
                  key = parseComputedPropertyName(parser, context);
                  state |= 2;
                  if (parser.token === 21) {
                      nextToken(parser, context | 32768);
                      if (parser.token & (8192 | 36864 | 16384)) {
                          value = parsePrimaryExpression(parser, context, 1, 0);
                          value = parseMemberOrUpdateExpression(parser, context, value);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else if (parser.token === 8388638) {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                          else {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                      }
                      else if ((parser.token & 4194304) === 4194304) {
                          value =
                              parser.token === 4325388
                                  ? parseObjectLiteralOrPattern(parser, context, 0, isPattern, decorators)
                                  : parseArrayExpressionOrPattern(parser, context, 0, isPattern, []);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              if (parser.token !== 18 && parser.token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                      else {
                          value = parseLeftHandSideExpression(parser, context, 1);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              if (parser.token !== 18 && parser.token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                  }
                  else if (parser.token === 131083) {
                      state |= 1;
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else {
                      report(parser, context, 0);
                  }
              }
              else if (token === 16911156) {
                  consume(parser, context, 16911156);
                  state |= 8;
                  if (parser.token & (8192 | 36864 | 16384)) {
                      key = parseIdentifier(parser, context);
                      state |= 1;
                      if (parser.token === 131083) {
                          value = parseMethodDefinition(parser, context, state);
                      }
                      else if (context & 128 && parser.token === 16910400) {
                          value = parseMethodDefinition(parser, context, state);
                      }
                      else {
                          report(parser, context, 0);
                      }
                  }
                  else if ((parser.token & 268435456) === 268435456) {
                      key = parseLiteral(parser, context);
                      state |= 1;
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else if (parser.token === 4325395) {
                      state |= 2 | 1;
                      key = parseComputedPropertyName(parser, context);
                      value = parseMethodDefinition(parser, context, state);
                  }
                  else {
                      report(parser, context, 0);
                  }
              }
              else {
                  report(parser, context, 0);
              }
              properties.push(finishNode({
                  type: 'Property',
                  key,
                  value,
                  kind: !(state & 768) ? 'init' : state & 512 ? 'set' : 'get',
                  computed: (state & 2) > 0,
                  method: (state & 1) > 0,
                  shorthand: (state & 4) > 0
              }));
          }
          if (parser.token !== 18)
              break;
          nextToken(parser, context);
      }
      consume(parser, context, 2097167);
      let node = null;
      if (context & 128) {
          const optional = !!isPattern && consumeOpt(parser, context, 22);
          const typeAnnotation = isPattern && parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
          node = finishNode({
              type: 'ObjectExpression',
              properties,
              typeAnnotation,
              optional,
              decorators
          });
      }
      else {
          node = finishNode({
              type: 'ObjectExpression',
              properties
          });
      }
      if (!skipInitializer && parser.token & 8388608) {
          return parseArrayOrObjectAssignmentPattern(parser, context, node);
      }
      return node;
  }
  function parseArrayOrObjectAssignmentPattern(parser, context, node) {
      nextToken(parser, context | 32768);
      reinterpretToPattern(parser, node);
      const right = parseExpression(parser, context);
      return finishNode({
          type: 'AssignmentExpression',
          left: node,
          operator: '=',
          right
      });
  }
  function parseComputedPropertyName(parser, context) {
      nextToken(parser, context | 32768);
      let key = parsePrimaryExpression(parser, (context | 134217728) ^ 134217728, 1, 0);
      key = parseMemberOrUpdateExpression(parser, context, key);
      key = parseAssignmentExpression(parser, context, key);
      consume(parser, context, 20);
      return key;
  }
  function parseTypeScriptMethodDefinition(parser, context, isConstructor, kind, modifiers, declare = 0) {
      let body = null;
      let typeParameters = null;
      if (parser.token === 16910400) {
          if (kind & (256 | 512))
              report(parser, context, 0);
          typeParameters = parseTypeParameters(parser, context);
      }
      const modifierFlags = (kind & 64) < 1 ? 31981568 : 14680064;
      context =
          ((context | modifierFlags) ^ modifierFlags) |
              ((kind & 88) << 18) |
              100925440;
      const params = isConstructor && !declare
          ? parseConstructorFormals(parser, context, declare)
          : parseTypescriptMethodFormals(parser, context, kind);
      const returnType = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : null;
      if (parser.token !== 4325388) {
          consumeSemicolon(parser, context);
      }
      else {
          if (declare)
              report(parser, context, 68);
          if (modifiers & 1)
              report(parser, context, kind & 768 ? 46 : 43);
          body = parseFunctionBody(parser, context & ~(0x8001000 | 8192), 0);
      }
      return finishNode({
          type: body ? 'FunctionExpression' : 'EmptyBodyFunctionExpression',
          params,
          body,
          async: (kind & 16) > 0,
          generator: (kind & 8) > 0,
          id: null,
          returnType,
          typeParameters,
          declare: false
      });
  }
  function parseMethodDefinition(parser, context, kind) {
      let body = null;
      let typeParameters = null;
      const isTS = context & 128;
      if (isTS) {
          if (parser.token === 16910400) {
              if (kind & (256 | 512))
                  report(parser, context, 0);
              typeParameters = parseTypeParameters(parser, context);
          }
      }
      const modifierFlags = (kind & 64) < 1 ? 31981568 : 14680064;
      context =
          ((context | modifierFlags) ^ modifierFlags) |
              ((kind & 88) << 18) |
              100925440;
      const params = isTS ? parseTypescriptMethodFormals(parser, context, kind) : parseMethodFormals(parser, context, kind);
      const returnType = isTS && parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : null;
      if (isTS && parser.token !== 4325388) {
          consumeSemicolon(parser, context);
      }
      else {
          body = parseFunctionBody(parser, context & ~(0x8001000 | 8192), 0);
      }
      return isTS
          ? finishNode({
              type: body ? 'FunctionExpression' : 'EmptyBodyFunctionExpression',
              params,
              body,
              async: (kind & 16) > 0,
              generator: (kind & 8) > 0,
              id: null,
              returnType,
              typeParameters,
              declare: false
          })
          : finishNode({
              type: 'FunctionExpression',
              params,
              body,
              async: (kind & 16) > 0,
              generator: (kind & 8) > 0,
              id: null
          });
  }
  function parseTypescriptMethodFormals(parser, context, kind) {
      consume(parser, context, 131083);
      if (parser.token === 16) {
          if (kind & 512) {
              report(parser, context, 74, 1, 'Setter', 'one', '');
          }
          nextToken(parser, context);
          return [];
      }
      let isThisKeyword = 0;
      let params = [];
      let setterArgs = 0;
      let left;
      if (parser.token === 139360) {
          params = [parseBindingIdentifier(parser, context, 1, 1)];
          if (!consumeOpt(parser, context, 18)) {
              nextToken(parser, context);
              return params;
          }
          isThisKeyword++;
      }
      while (parser.token !== 16) {
          if ((parser.token & (16384 | 8192 | 36864)) > 0) {
              if (parser.token === 139360)
                  isThisKeyword++;
              left = parseBindingIdentifier(parser, context, 0, 1);
          }
          else {
              const decorators = parser.token === 142 ? parseDecorators(parser, context | 1048576) : [];
              if (parser.token === 4325388) {
                  left = parseObjectLiteralOrPattern(parser, context, 1, 1, decorators);
              }
              else if (parser.token === 4325395) {
                  left = parseArrayExpressionOrPattern(parser, context, 1, 1, decorators);
              }
              else if (parser.token === 14) {
                  left = parseSpreadOrRestElement(parser, context, 16, 1, decorators);
              }
              else if ((parser.token & (36864 | 8192 | 16384)) > 0) {
                  left = parseBindingIdentifier(parser, context, 0, 1);
                  left.decorators = decorators;
              }
              else {
                  report(parser, context, 0);
              }
              reinterpretToPattern(parser, left);
          }
          if (parser.token === 8388638) {
              nextToken(parser, context | 32768);
              const right = parseExpression(parser, context);
              left = finishNode({
                  type: 'AssignmentPattern',
                  left,
                  right
              });
          }
          setterArgs++;
          params.push(left);
          if (parser.token !== 16)
              consume(parser, context, 18);
      }
      if (isThisKeyword === 0) {
          if (kind & 256) {
              report(parser, context, 74, 1, 'Getter', 'no', 's');
          }
          if (kind & 512 && setterArgs !== 1) {
              report(parser, context, 74, 1, 'Setter', 'one', '');
          }
      }
      consume(parser, context, 16);
      return params;
  }
  function parseMethodFormals(parser, context, kind) {
      consume(parser, context, 131083);
      if (parser.token === 16) {
          if (kind & 512) {
              report(parser, context, 74, 1, 'Setter', 'one', '');
          }
          nextToken(parser, context);
          return [];
      }
      const params = [];
      let setterArgs = 0;
      let left;
      if (kind & 256) {
          report(parser, context, 74, 1, 'Getter', 'no', 's');
      }
      if (kind & 512 && parser.token === 14) {
          report(parser, context, 75);
      }
      while (parser.token !== 16) {
          if ((parser.token & (16384 | 8192 | 36864)) > 0) {
              left = parseIdentifier(parser, context);
          }
          else {
              if (parser.token === 4325388) {
                  left = parseObjectLiteralOrPattern(parser, context, 1, 1, []);
              }
              else if (parser.token === 4325395) {
                  left = parseArrayExpressionOrPattern(parser, context, 1, 1, []);
              }
              else if (parser.token === 14) {
                  left = parseSpreadOrRestElement(parser, context, 16, 0, []);
              }
              else {
                  report(parser, context, 0);
              }
              reinterpretToPattern(parser, left);
          }
          if (parser.token === 8388638) {
              nextToken(parser, context | 32768);
              const right = parseExpression(parser, context);
              left = finishNode({
                  type: 'AssignmentPattern',
                  left,
                  right
              });
          }
          setterArgs++;
          params.push(left);
          if (parser.token !== 16)
              consume(parser, context, 18);
      }
      if (kind & 512 && setterArgs !== 1) {
          report(parser, context, 74, 1, 'Setter', 'one', '');
      }
      consume(parser, context, 16);
      return params;
  }
  function parseSpreadOrRestElement(parser, context, closingToken, allowTypeAnnotation, decorators) {
      nextToken(parser, context | 32768);
      let argument;
      if (parser.token & (8192 | 36864 | 16384)) {
          argument = parsePrimaryExpression(parser, context, 1, 0);
          argument = parseMemberOrUpdateExpression(parser, context, argument);
          if (parser.token !== 18 && parser.token !== closingToken) {
              argument = parseAssignmentExpression(parser, context, argument);
          }
      }
      else if (parser.token === closingToken) {
          report(parser, context, 0);
      }
      else if (parser.token & 4194304) {
          argument =
              parser.token === 4325388
                  ? parseObjectLiteralOrPattern(parser, context, 0, 0, [])
                  : parseArrayExpressionOrPattern(parser, context, 0, 0, []);
          const { token } = parser;
          if (token !== 8388638 && token !== closingToken && token !== 18) {
              argument = parseMemberOrUpdateExpression(parser, context, argument);
              if (parser.token !== 18 && parser.token !== closingToken) {
                  argument = parseAssignmentExpression(parser, context, argument);
              }
          }
      }
      else {
          argument = parseLeftHandSideExpression(parser, context, 1);
          const { token } = parser;
          if (token === 8388638 && token !== closingToken && token !== 18) {
              argument = parseAssignmentExpression(parser, context, argument);
          }
          else {
              if (token === 18) ;
              else if (token !== closingToken) {
                  argument = parseAssignmentExpression(parser, context, argument);
              }
          }
          return finishNode({
              type: 'SpreadElement',
              argument
          });
      }
      if (parser.token !== closingToken) {
          if (consumeOpt(parser, context | 32768, 8388638)) {
              reinterpretToPattern(parser, argument);
              const right = parseExpression(parser, context);
              argument = finishNode({
                  type: 'AssignmentExpression',
                  left: argument,
                  operator: '=',
                  right
              });
          }
      }
      return context & 128 && allowTypeAnnotation
          ? finishNode({
              type: 'SpreadElement',
              argument,
              optional: consumeOpt(parser, context, 22),
              typeAnnotation: allowTypeAnnotation && parser.token === 21
                  ? parseTypeAnnotation(parser, context, 0)
                  : [],
              value: null,
              decorators
          })
          : finishNode({
              type: 'SpreadElement',
              argument
          });
  }
  function parseArrayLiteral(parser, context, skipInitializer) {
      return parseArrayExpressionOrPattern(parser, context, skipInitializer, 0, []);
  }
  function parseArrayExpressionOrPattern(parser, context, skipInitializer, isPattern, decorators) {
      nextToken(parser, context | 32768);
      const elements = [];
      context = (context | 134217728) ^ 134217728;
      while (parser.token !== 20) {
          if (consumeOpt(parser, context | 32768, 18)) {
              elements.push(null);
          }
          else {
              let left;
              const { token } = parser;
              if (token & 36864) {
                  left = parsePrimaryExpression(parser, context, 1, 0);
                  if (consumeOpt(parser, context | 32768, 8388638)) {
                      const right = parseExpression(parser, context);
                      left = finishNode({
                          type: 'AssignmentExpression',
                          operator: '=',
                          left,
                          right
                      });
                  }
                  else {
                      left = parseMemberOrUpdateExpression(parser, context, left);
                      if (parser.token !== 18 && parser.token !== 20) {
                          left = parseAssignmentExpression(parser, context, left);
                      }
                  }
              }
              else if (token & 4194304) {
                  left =
                      parser.token === 4325388
                          ? parseObjectLiteralOrPattern(parser, context, 0, isPattern, [])
                          : parseArrayExpressionOrPattern(parser, context, 0, isPattern, []);
                  if (parser.token === 18 || parser.token === 20) ;
                  else {
                      left = parseMemberOrUpdateExpression(parser, context, left);
                      if (parser.token !== 18 && parser.token !== 20) {
                          left = parseAssignmentExpression(parser, context, left);
                      }
                  }
              }
              else if (token === 14) {
                  left = parseSpreadOrRestElement(parser, context, 20, 0, []);
              }
              else {
                  left = parseLeftHandSideExpression(parser, context, 1);
                  if (parser.token !== 18 && parser.token !== 20) {
                      left = parseAssignmentExpression(parser, context, left);
                  }
              }
              elements.push(left);
              if (consumeOpt(parser, context | 32768, 18)) {
                  if (parser.token === 20)
                      break;
              }
              else
                  break;
          }
      }
      consume(parser, context, 20);
      let node = null;
      if (context & 128) {
          const optional = !!isPattern && consumeOpt(parser, context, 22);
          const typeAnnotation = isPattern && parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
          node = finishNode({
              type: 'ArrayExpression',
              elements,
              typeAnnotation,
              optional,
              decorators
          });
      }
      else {
          node = finishNode({
              type: 'ArrayExpression',
              elements
          });
      }
      if (!skipInitializer && parser.token & 8388608) {
          return parseArrayOrObjectAssignmentPattern(parser, context, node);
      }
      return node;
  }
  function parseParenthesizedExpression(parser, context, isLHS) {
      consumeOpt(parser, context | 32768, 131083);
      context = (context | 134217728) ^ 134217728;
      if (consumeOpt(parser, context, 16)) {
          if (parser.token !== 10)
              report(parser, context, 0);
          if (!isLHS)
              report(parser, context, 0);
          return parseArrowFunctionExpression(parser, context, [], null, null, isLHS, 0);
      }
      let expr;
      let expressions = [];
      let isSequence = 0;
      while (parser.token !== 16) {
          const { token } = parser;
          if (parser.token & (8192 | 36864 | 16384)) {
              expr = parsePrimaryExpression(parser, context, 1, 1);
              if (parser.token === 18 || parser.token === 16) ;
              else {
                  expr = parseMemberOrUpdateExpression(parser, context, expr);
                  if (parser.token !== 18 && parser.token !== 16) {
                      expr = parseAssignmentExpression(parser, context, expr);
                  }
              }
          }
          else if (token & 4194304) {
              expr =
                  parser.token === 4325388
                      ? parseObjectLiteralOrPattern(parser, context, 0, 0, [])
                      : parseArrayExpressionOrPattern(parser, context, 0, 0, []);
              if (parser.token !== 18 && parser.token !== 16) {
                  expr = parseMemberOrUpdateExpression(parser, context, expr);
                  if (parser.token !== 18 && parser.token !== 16) {
                      expr = parseAssignmentExpression(parser, context, expr);
                  }
              }
          }
          else if (token === 14) {
              expr = parseSpreadOrRestElement(parser, context, 16, 1, []);
          }
          else {
              expr = parseExpression(parser, context);
              if (isSequence && (parser.token === 18 || parser.token === 16)) {
                  expressions.push(expr);
              }
              if (parser.token === 18) {
                  if (!isSequence) {
                      isSequence = 1;
                      expressions = [expr];
                  }
              }
              if (isSequence) {
                  while (consumeOpt(parser, context | 32768, 18)) {
                      expressions.push(parseExpression(parser, context));
                  }
                  expr = finishNode({
                      type: 'SequenceExpression',
                      expressions
                  });
              }
              consume(parser, context, 16);
              return expr;
          }
          if (isSequence && (parser.token === 18 || parser.token === 16)) {
              expressions.push(expr);
          }
          if (!consumeOpt(parser, context | 32768, 18))
              break;
          if (!isSequence) {
              isSequence = 1;
              expressions = [expr];
          }
          if (parser.token === 16) {
              break;
          }
      }
      if (isSequence) {
          expr = finishNode({
              type: 'SequenceExpression',
              expressions
          });
      }
      consume(parser, context, 16);
      if (parser.token === 10) {
          return parseArrowFunctionExpression(parser, context, isSequence ? expressions : [expr], null, null, isLHS, 0);
      }
      return expr;
  }
  function parseOptionalNchanged(parser, context, param, isAsync) {
      if (parser.token !== 21 && parser.token !== 18 && parser.token !== 16) {
          const consequent = parseExpression(parser, (context | 134217728 | 536870912) ^ 134217728);
          consume(parser, context | 32768, 21);
          const alternate = parseExpression(parser, context);
          const expr = finishNode({
              type: 'ConditionalExpression',
              test: param[0],
              consequent,
              alternate
          });
          nextToken(parser, context);
          return expr;
      }
      while (consumeOpt(parser, context, 18)) {
          param.push(parser.token === 14
              ? parseSpreadOrRestElement(parser, context, 16, 1, [])
              : parseBindingIdentifier(parser, context, 0, 1));
      }
      if (parser.token === 16) {
          nextToken(parser, context);
          const returnType = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : null;
          return parseArrowFunctionExpression(parser, context, param, [], returnType, 1, isAsync);
      }
  }
  function parseTypescriptParenthesizedExpression(parser, context, isLHS, typeAnnotation, assertion) {
      consumeOpt(parser, context | 32768, 131083);
      context = (context | 134217728) ^ 134217728;
      if (consumeOpt(parser, context, 16)) {
          let returnType = null;
          if (assertion > 0) {
              if (assertion & (4 | 2))
                  report(parser, context, 56);
              if (assertion & 8) {
                  typeAnnotation = finishNode({
                      type: 'TypeParameterDeclaration',
                      params: [parseTypeParameterFromValue(parser, context, typeAnnotation)]
                  });
              }
          }
          if (parser.token === 21) {
              if (context & 536870912) {
                  const returnType = tryScan(parser, context, function () {
                      const returnType = parseTypeAnnotation(parser, context | 1073741824, 0);
                      if (parser.token === 10)
                          return returnType;
                      return undefined;
                  });
                  return returnType
                      ? parseArrowFunctionExpression(parser, context, [], typeAnnotation, returnType, isLHS, 0)
                      : [];
              }
              else {
                  returnType = parseTypeAnnotation(parser, context | 1073741824, 0);
              }
          }
          if (parser.token !== 10)
              report(parser, context, 0);
          if (!isLHS)
              report(parser, context, 0);
          return parseArrowFunctionExpression(parser, context, [], typeAnnotation, returnType, isLHS, 0);
      }
      let expr;
      let expressions = [];
      let isSequence = 0;
      while (parser.token !== 16) {
          const { token } = parser;
          if (parser.token & (8192 | 36864 | 16384)) {
              expr = parsePrimaryExpression(parser, context, 1, 1);
              if (parser.token === 22) {
                  nextToken(parser, context);
                  if (parser.token === 21) {
                      expr.typeAnnotation = parseTypeAnnotation(parser, context, 0);
                  }
                  if (isSequence)
                      expressions.push(expr);
                  return parseOptionalNchanged(parser, context, isSequence ? expressions : [expr], 0);
              }
              if (parser.token === 18 || parser.token === 16) ;
              else {
                  expr = parseMemberOrUpdateExpression(parser, context, expr);
                  if (parser.token !== 18 && parser.token !== 16) {
                      expr = parseAssignmentExpression(parser, context, expr);
                  }
              }
          }
          else if (token & 4194304) {
              expr =
                  parser.token === 4325388
                      ? parseObjectLiteralOrPattern(parser, context, 0, 0, [])
                      : parseArrayExpressionOrPattern(parser, context, 0, 0, []);
              if (parser.token === 21) {
                  expr.typeAnnotation = parseTypeAnnotation(parser, context, 0);
              }
              if (parser.token !== 18 && parser.token !== 16) {
                  expr = parseMemberOrUpdateExpression(parser, context, expr);
                  if (parser.token !== 18 && parser.token !== 16) {
                      expr = parseAssignmentExpression(parser, context, expr);
                  }
              }
          }
          else if (token === 14) {
              expr = parseSpreadOrRestElement(parser, context, 16, 1, []);
          }
          else if (assertion > 0 && parser.token === 131083) {
              let type = parseTypeFromValue(parser, context, typeAnnotation);
              type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
              const expression = parseTypescriptParenthesizedExpression(parser, context, isLHS, typeAnnotation, assertion);
              consume(parser, context, 16);
              return finishNode({
                  type: 'TypeAssertion',
                  typeAnnotation: type,
                  expression
              });
          }
          else {
              expr = parseExpression(parser, context);
              if (isSequence && (parser.token === 18 || parser.token === 16)) {
                  expressions.push(expr);
              }
              if (parser.token === 18) {
                  if (!isSequence) {
                      isSequence = 1;
                      expressions = [expr];
                  }
              }
              if (isSequence) {
                  while (consumeOpt(parser, context | 32768, 18)) {
                      expressions.push(parseExpression(parser, context));
                  }
                  expr = finishNode({
                      type: 'SequenceExpression',
                      expressions
                  });
              }
              consume(parser, context, 16);
              return expr;
          }
          if (isSequence && (parser.token === 18 || parser.token === 16)) {
              expressions.push(expr);
          }
          if (!consumeOpt(parser, context | 32768, 18))
              break;
          if (!isSequence) {
              isSequence = 1;
              expressions = [expr];
          }
          if (parser.token === 16) {
              break;
          }
      }
      if (isSequence) {
          expr = finishNode({
              type: 'SequenceExpression',
              expressions
          });
      }
      consume(parser, context, 16);
      if (context & 536870912 && parser.token === 21) {
          const returnType = tryScan(parser, context, function () {
              const returnType = parseTypeAnnotation(parser, context | 1073741824, 0);
              if (parser.token === 10)
                  return returnType;
              return undefined;
          });
          return returnType
              ? parseArrowFunctionExpression(parser, context, isSequence ? expressions : [expr], typeAnnotation, returnType, isLHS, 0)
              : expr;
      }
      let returnType = null;
      if (parser.token === 21) {
          returnType = parseTypeOrTypePredicate(parser, context | 1073741824, 0);
          if (parser.token !== 10)
              report(parser, context, 0);
      }
      if (parser.token === 10) {
          if (assertion > 0) {
              if (assertion & (4 | 2))
                  report(parser, context, 56);
              if (assertion & 8) {
                  typeAnnotation = finishNode({
                      type: 'TypeParameterDeclaration',
                      params: [parseTypeParameterFromValue(parser, context, typeAnnotation)]
                  });
              }
          }
          return parseArrowFunctionExpression(parser, context, isSequence ? expressions : [expr], typeAnnotation, returnType, isLHS, 0);
      }
      if (assertion > 0) {
          if (assertion & (2 | 1))
              return typeAnnotation;
          if (assertion & 8) {
              typeAnnotation = parseTypeFromValue(parser, context, typeAnnotation);
              typeAnnotation = parseUnionAndIntersectionType(parser, context, typeAnnotation, 0, 0, 0);
          }
          return finishNode({
              type: 'TypeAssertion',
              typeAnnotation,
              expression: expr
          });
      }
      return expr;
  }
  function parseArrowFunctionExpression(parser, context, params, typeParameters, returnType, isLHS, isAsync) {
      consume(parser, context | 32768, 10);
      for (let i = 0; i < params.length; ++i)
          reinterpretToPattern(parser, params[i]);
      context = ((context | 15728640) ^ 15728640) | (isAsync << 22);
      const expression = parser.token !== 4325388;
      if (!isLHS)
          report(parser, context, 0);
      let body;
      if (expression) {
          body = parseExpression(parser, (context | 536870912) ^ 536870912);
      }
      else {
          body = parseFunctionBody(parser, (context | 134221824 | 8192 | 16384 | 536870912) ^
              (134221824 | 8192 | 16384 | 536870912), 16);
          if ((parser.token & 16908288) === 16908288 && parser.precedingLineBreak === 0)
              report(parser, context, 1, 0, KeywordDescTable[parser.token & 255]);
          if ((parser.token & 67239936) === 67239936)
              report(parser, context, 87);
          switch (parser.token) {
              case 13:
              case 4325395:
              case 131081:
              case 22:
                  report(parser, context, 85);
              case 131083:
                  report(parser, context, 86);
              default:
          }
      }
      return context & 128
          ? finishNode({
              type: 'ArrowFunctionExpression',
              body,
              params,
              async: isAsync === 1,
              expression,
              returnType,
              typeParameters
          })
          : finishNode({
              type: 'ArrowFunctionExpression',
              body,
              params,
              async: isAsync === 1,
              expression
          });
  }
  function parseSuperExpression(parser, context) {
      nextToken(parser, context);
      switch (parser.token) {
          case 131083: {
              if ((context & 524288) < 1)
                  report(parser, context, 65);
              break;
          }
          case 4325395:
          case 13: {
              if ((context & 262144) < 1)
                  report(parser, context, 64);
              break;
          }
          default:
              report(parser, context, 1, 1, 'super');
      }
      return finishNode({ type: 'Super' });
  }
  function parseNewExpression(parser, context) {
      const id = parseIdentifier(parser, context | 32768);
      if (consumeOpt(parser, context, 13)) {
          if (context & 67108864 && parser.tokenValue === 'target') {
              return parseMetaProperty(parser, context, id);
          }
          report(parser, context, 76);
      }
      const isTS = context & 128;
      const expr = parsePrimaryExpression(parser, context, 0, 0);
      let typeParameters = null;
      if (isTS && parser.token === 16910400) {
          typeParameters = parseTypeParameterInstantiation(parser, context);
          if (parser.token !== 131083)
              report(parser, context, 0);
      }
      context = (context | 134217728) ^ 134217728;
      const callee = parseMembeExpressionNoCall(parser, context, expr);
      const args = parser.token === 131083 ? parseArguments(parser, context) : [];
      return isTS
          ? finishNode({
              type: 'NewExpression',
              callee,
              arguments: args,
              typeParameters
          })
          : finishNode({
              type: 'NewExpression',
              callee,
              arguments: args
          });
  }
  function parseMetaProperty(parser, context, meta) {
      const property = parseIdentifier(parser, context);
      return finishNode({
          type: 'MetaProperty',
          meta,
          property
      });
  }
  function parseMembeExpressionNoCall(parser, context, expr) {
      const { token } = parser;
      if (token === 13) {
          nextToken(parser, context);
          const property = parseIdentifier(parser, context);
          return parseMembeExpressionNoCall(parser, context, finishNode({
              type: 'MemberExpression',
              object: expr,
              computed: false,
              property
          }));
      }
      else if (token === 4325395) {
          nextToken(parser, context | 32768);
          const property = parseExpressions(parser, context);
          consume(parser, context, 20);
          return parseMembeExpressionNoCall(parser, context, finishNode({
              type: 'MemberExpression',
              object: expr,
              computed: true,
              property
          }));
      }
      else if (token === 131080 || token === 131081) {
          return parseMembeExpressionNoCall(parser, context, {
              type: 'TaggedTemplateExpression',
              tag: expr,
              quasi: parser.token === 131080
                  ? parseTemplateLiteral(parser, context)
                  : parseNoSubstitutionTemplate(parser, context | 65536)
          });
      }
      return expr;
  }
  function parseNoSubstitutionTemplate(parser, context) {
      consume(parser, context, 131081);
      return finishNode({
          type: 'TemplateLiteral',
          expressions: [],
          quasis: [parseTemplateElement(parser, true)]
      });
  }
  function parseTemplateLiteral(parser, context) {
      context = (context | 134217728) ^ 134217728;
      const quasis = [parseTemplateElement(parser, false)];
      consume(parser, context | 32768, 131080);
      const expressions = [parseExpressions(parser, context)];
      while ((parser.token = scanTemplateTail(parser, context)) !== 131081) {
          quasis.push(parseTemplateElement(parser, false));
          consume(parser, context | 32768, 131080);
          expressions.push(parseExpressions(parser, context));
      }
      quasis.push(parseTemplateElement(parser, true));
      consume(parser, context, 131081);
      return finishNode({
          type: 'TemplateLiteral',
          expressions,
          quasis
      });
  }
  function parseTemplateElement(parser, tail) {
      return finishNode({
          type: 'TemplateElement',
          tail,
          value: {
              cooked: parser.tokenValue,
              raw: parser.tokenRaw
          }
      });
  }
  function parseBigIntLiteral(parser, context) {
      const { tokenRaw, tokenValue } = parser;
      nextToken(parser, context);
      return finishNode({
          type: 'BigIntLiteral',
          value: tokenValue,
          bigint: tokenRaw
      });
  }
  function parseUnaryExpression(parser, context) {
      const unaryOperator = parser.token;
      nextToken(parser, context | 32768);
      const arg = parseLeftHandSideExpression(parser, context, 1);
      if (parser.token === 16911415)
          report(parser, context, 0);
      if (context & 1024 && unaryOperator === 33693740) {
          if (arg.type === 'Identifier') {
              report(parser, context, 0);
          }
      }
      return finishNode({
          type: 'UnaryExpression',
          operator: KeywordDescTable[unaryOperator & 255],
          argument: arg,
          prefix: true
      });
  }
  function parseUpdateExpressionPrefixed(parser, context, inNew) {
      if (inNew)
          report(parser, context, 0);
      const { token } = parser;
      nextToken(parser, context | 32768);
      const arg = parseLeftHandSideExpression(parser, context, 1);
      return finishNode({
          type: 'UpdateExpression',
          argument: arg,
          operator: KeywordDescTable[token & 255],
          prefix: true
      });
  }
  function parseLiteral(parser, context) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      return finishNode({
          type: 'Literal',
          value: tokenValue
      });
  }
  function parseIdentifier(parser, context) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      return finishNode({
          type: 'Identifier',
          name: tokenValue
      });
  }
  function parseThisExpression(parser, context) {
      nextToken(parser, context);
      return finishNode({
          type: 'ThisExpression'
      });
  }
  function parseNullOrTrueOrFalseLiteral(parser, context) {
      const raw = KeywordDescTable[parser.token & 255];
      const value = parser.token === 139271 ? null : raw === 'true';
      nextToken(parser, context);
      return finishNode({
          type: 'Literal',
          value
      });
  }
  function parseRegExpLiteral(parser, context) {
      const { tokenRegExp, tokenValue } = parser;
      nextToken(parser, context);
      return finishNode({
          type: 'Literal',
          value: tokenValue,
          regex: tokenRegExp
      });
  }
  function parseTypeParameters(parser, context) {
      const params = [];
      consume(parser, context, 16910400);
      while (parser.token !== 16910401) {
          params.push(parseTypeParameter(parser, context | 268435456));
          if (parser.token !== 16910401) {
              consume(parser, context, 18);
          }
      }
      consume(parser, context, 16910401);
      return finishNode({
          type: 'TypeParameterDeclaration',
          params
      });
  }
  function parseTypeParameter(parser, context) {
      const name = parseBindingIdentifier(parser, context, 0, 0);
      let constraint = null;
      if (consumeOpt(parser, context, 8278)) {
          constraint = parseType(parser, context, 0, 0, 0);
      }
      const default_ = consumeOpt(parser, context | 32768, 8388638)
          ? parseType(parser, context, 0, 0, 0)
          : null;
      return finishNode({
          type: 'TypeParameter',
          name,
          constraint,
          default: default_
      });
  }
  function parseBindingIdentifier(parser, context, requireTypeAnnotation, canBeOptionalParam) {
      const { tokenValue } = parser;
      let definite = false;
      nextToken(parser, context);
      const optional = canBeOptionalParam && consumeOpt(parser, context, 22);
      if (consumeOpt(parser, context, 33685550)) {
          definite = true;
      }
      const typeAnnotation = requireTypeAnnotation || parser.token === 21
          ? parseTypeAnnotation(parser, context, 0)
          : [];
      return finishNode({
          type: 'Identifier',
          name: definite ? tokenValue | 2 : tokenValue,
          optional,
          typeAnnotation
      });
  }
  function parseOptionalIdentifier(parser, context) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      const optional = consumeOpt(parser, context, 22);
      return finishNode({
          type: 'Identifier',
          name: tokenValue,
          optional,
          typeAnnotation: null
      });
  }
  function parseTypeAnnotationNoConsume(parser, context, restrictedTypes) {
      const typeAnnotation = parseType(parser, context, restrictedTypes, 0, 0);
      consumeOpt(parser, context, 2097169);
      return finishNode({
          type: 'TypeAnnotation',
          typeAnnotation
      });
  }
  function parseTypeAnnotation(parser, context, restrictedTypes) {
      nextToken(parser, context);
      const typeAnnotation = parseType(parser, context, restrictedTypes, 0, 0);
      consumeOpt(parser, context, 2097169);
      return finishNode({
          type: 'TypeAnnotation',
          typeAnnotation
      });
  }
  function parseType(parser, context, restrictedTypes, isMappedType, typeAlias) {
      const type = parseUnionType(parser, context, restrictedTypes, isMappedType, typeAlias);
      return parser.precedingLineBreak === 0 && consumeOpt(parser, context, 8278)
          ? parseConditionalType(parser, context, restrictedTypes, isMappedType, typeAlias, type)
          : type;
  }
  function parseConditionalType(parser, context, restrictedTypes, isMappedType, typeAlias, checkType) {
      const extendsType = parseUnionType(parser, context, restrictedTypes, isMappedType, typeAlias);
      consumeOpt(parser, context, 22);
      const trueType = parseType(parser, context, restrictedTypes, isMappedType, typeAlias);
      consumeOpt(parser, context, 21);
      const falseType = parseType(parser, context, restrictedTypes, isMappedType, typeAlias);
      return finishNode({
          type: 'ConditionalType',
          checkType,
          extendsType,
          trueType,
          falseType
      });
  }
  function parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias) {
      const hasLeadingOperator = consumeOpt(parser, context, 16909893);
      let type = parseTypeOperatorOrHigher(parser, context, 0, restrictedTypes, isMappedType, typeAlias);
      if (parser.token === 16909893 || hasLeadingOperator) {
          const types = [type];
          while (consumeOpt(parser, context, 16909893)) {
              types.push(parseTypeOperatorOrHigher(parser, context, 0, restrictedTypes, isMappedType, typeAlias));
          }
          type = finishNode({
              type: 'IntersectionType',
              types
          });
      }
      return type;
  }
  function parseTypeOperatorOrHigher(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias) {
      switch (parser.token) {
          case 561287:
              isReadOnly = 1;
          case 36996:
          case 36997:
              return parseTypeOperator(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias);
          case 37000:
              return parseInferType(parser, context);
          default:
              return parsePostFix(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias);
      }
  }
  function parseTypeOperator(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias) {
      const operator = KeywordDescTable[parser.token & 255];
      nextToken(parser, context);
      return finishNode({
          type: 'TypeOperator',
          operator,
          typeAnnotation: parseTypeOperatorOrHigher(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias)
      });
  }
  function parseInferType(parser, context) {
      nextToken(parser, context);
      const typeParameter = finishNode({
          type: 'TypeParameter',
          name: parseIdentifier(parser, context)
      });
      return finishNode({
          type: 'InferType',
          typeParameter
      });
  }
  function parsePostFix(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias) {
      const type = parseNonArrayType(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias);
      return parsePostFixTypeOrHigher(parser, context, type);
  }
  function parsePostFixTypeOrHigher(parser, context, type) {
      while (parser.precedingLineBreak === 0) {
          switch (parser.token) {
              case 33685550:
                  report(parser, context, 79);
                  break;
              case 4325395: {
                  nextToken(parser, context | 32768);
                  if (consumeOpt(parser, context, 20)) {
                      type = finishNode({
                          type: 'ArrayType',
                          elementType: type
                      });
                  }
                  else {
                      const indexType = parseType(parser, context, 0, 0, 0);
                      consume(parser, context, 20);
                      type = finishNode({
                          type: 'IndexedAccessType',
                          objectType: type,
                          indexType
                      });
                  }
                  break;
              }
              default:
                  return type;
          }
      }
      return type;
  }
  function parseUnionType(parser, context, restrictedTypes, isMappedType, typeAlias) {
      const hasLeadingOperator = consumeOpt(parser, context, 16909382);
      let type = parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias);
      if (parser.token === 16909382 || hasLeadingOperator) {
          if (restrictedTypes)
              report(parser, context, 58);
          const types = [type];
          while (consumeOpt(parser, context, 16909382)) {
              types.push(parseIntersectionType(parser, context, restrictedTypes, isMappedType, typeAlias));
          }
          type = finishNode({
              type: 'UnionType',
              types
          });
      }
      return type;
  }
  function parseEntityName(parser, context) {
      let entity = parseIdentifier(parser, context);
      while (consumeOpt(parser, context, 13)) {
          entity = finishNode({
              type: 'QualifiedName',
              left: entity,
              right: parseIdentifier(parser, context)
          });
      }
      return entity;
  }
  function parseTypeReference(parser, context) {
      const typeName = parseEntityName(parser, context);
      let typeParameters = null;
      if (!parser.precedingLineBreak && parser.token === 16910400) {
          typeParameters = parseTypeParameterInstantiation(parser, context | 268435456);
      }
      return finishNode({
          type: 'TypeReference',
          typeName,
          typeParameters
      });
  }
  function parseNonArrayType(parser, context, isReadOnly, restrictedTypes, isMappedType, typeAlias) {
      const { token, tokenValue } = parser;
      if ((token & (4096 | 16384 | 36864)) !== 0) {
          const type = primaryTypes[tokenValue];
          if (restrictedTypes && (tokenValue !== 'string' && tokenValue !== 'number'))
              report(parser, context, 78);
          if (type) {
              nextToken(parser, context);
              if (isReadOnly && parser.token !== 4325395) {
                  report(parser, context, 37);
              }
              return {
                  type
              };
          }
          if ((context & 1024 && token & 16384) === 16384) {
              report(parser, context, 62);
          }
          return parseTypeReference(parser, context);
      }
      switch (token) {
          case 134357067:
              return parseTypeReference(parser, context);
          case 268566531:
              return parseLiteralTypedNode(parser, context, 0, 'Literal');
          case 268566530:
              return parseLiteralTypedNode(parser, context, 0, 'Literal');
          case 123:
              return parseLiteralTypedNode(parser, context, 0, 'BigIntLiteral');
          case 139270:
          case 139269:
              return parseLiteralTypedNode(parser, context, 1, 'Literal');
          case 50465329:
              return parseSubtractTypeNode(parser, context);
          case 131081:
              return parseTemplateLiteralType(parser, context);
          case 4325388:
              return parseObjectTypeMembers(parser, context, typeAlias);
          case 4325395:
              return parseTupleType(parser, context);
          case 16910400:
              return parseFunctionType(parser, context);
          case 131083:
              return parseFunctionOrConstructorTypeOrParenthesized(parser, context, isMappedType, typeAlias, 'FunctionType');
          case 139271:
              return parseNullOrVoidTypedNode(parser, context, 'NullKeyword');
          case 33693741:
              return parseNullOrVoidTypedNode(parser, context, 'VoidKeyword');
          case 33693739:
              nextToken(parser, context);
              return parser.token === 139355
                  ? parseImportType(parser, context, true)
                  : parseTypeQuery(parser, context);
          case 139356:
              return parseNewAsTypeReferenceOrConstructorType(parser, context, isMappedType, typeAlias);
          case 139360:
              const thisKeyword = parseThisTypeNode(parser, context);
              return parser.token === 36998 && parser.precedingLineBreak === 0
                  ? parseTypePredicate(parser, context, thisKeyword)
                  : thisKeyword;
          case 139355:
              return parseImportType(parser, context, false);
          case 138:
              return parseAssertsTypePredicateOrTypePredicate(parser, context);
          case 16911156:
          case 8388645:
              report(parser, context, 79);
          default:
              if (context & 1073741824 && parser.token !== 16)
                  return undefined;
              report(parser, context, (context & 1024 && token & 16384) === 16384
                  ? 62
                  : 56);
      }
  }
  function parseFunctionType(parser, context) {
      const typeParameters = parseTypeParameters(parser, context);
      if (context & 1073741824 && parser.token !== 131083)
          return undefined;
      consume(parser, context, 131083);
      const params = parseFunctionTypeParams(parser, context);
      consume(parser, context, 16);
      consume(parser, context, 10);
      const returnType = parseTypeAnnotationNoConsume(parser, context, 0);
      return finishNode({
          type: 'FunctionType',
          params,
          returnType,
          typeParameters
      });
  }
  function parseNewAsTypeReferenceOrConstructorType(parser, context, isMappedType, typeAlias) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      return parser.token === 131083
          ? parseFunctionOrConstructorTypeOrParenthesized(parser, context, isMappedType, typeAlias, 'ConstructorType')
          : parseTypeReferenceFromExpression(parser, context, parseIdentifierFromValue(parser, context, tokenValue, 0));
  }
  function parseImportType(parser, context, isTypeOf) {
      nextToken(parser, context);
      consume(parser, context, 131083);
      const parameter = parseType(parser, context, 0, 0, 0);
      consume(parser, context, 16);
      const qualifier = consumeOpt(parser, context, 13) ? parseEntityName(parser, context) : null;
      const typeParameters = parser.precedingLineBreak === 0 && parser.token === 16910400
          ? parseTypeParameterInstantiation(parser, context)
          : null;
      return finishNode({
          type: 'ImportType',
          qualifier,
          parameter,
          isTypeOf,
          typeParameters
      });
  }
  function parseTemplateLiteralType(parser, context) {
      const templateNode = parseNoSubstitutionTemplate(parser, context);
      return finishNode({
          type: 'LiteralType',
          literal: templateNode
      });
  }
  function parseSubtractTypeNode(parser, context) {
      const expr = parseIdentifier(parser, context);
      if (parser.token !== 268566530 && parser.token !== 123)
          return parseTypeReferenceFromExpression(parser, context, expr);
      const literal = finishNode({
          type: 'UnaryExpression',
          operator: '-',
          prefix: true,
          argument: {
              type: 'Literal',
              value: parser.tokenValue
          }
      });
      nextToken(parser, context);
      return finishNode({
          type: 'LiteralType',
          literal
      });
  }
  function parseTypeQuery(parser, context) {
      const exprName = parseEntityName(parser, context);
      return finishNode({
          type: 'TypeQuery',
          exprName
      });
  }
  function parseThisTypeNode(parser, context) {
      consume(parser, context, 139360);
      return finishNode({
          type: 'ThisType'
      });
  }
  function parseTypePredicate(parser, context, parameterName) {
      const typeAnnotation = parseTypeAnnotation(parser, context, 0);
      return finishNode({
          type: 'TypePredicate',
          assertsModifier: false,
          parameterName,
          typeAnnotation
      });
  }
  function parseLiteralTypedNode(parser, context, isBoolean, type) {
      const { tokenValue } = parser;
      const literal = {
          type,
          value: isBoolean && type === 'Literal' ? tokenValue === 'true' : tokenValue
      };
      nextToken(parser, context);
      return finishNode({
          type: 'LiteralType',
          literal
      });
  }
  function parseNullOrVoidTypedNode(parser, context, type) {
      nextToken(parser, context);
      return finishNode({
          type
      });
  }
  function parseFunctionOrConstructorTypeOrParenthesized(parser, context, isMappedType, typeAlias, astType) {
      nextToken(parser, context);
      let isGroupedType = 0;
      let hasParams = 0;
      let type = null;
      if (parser.token !== 16 && parser.token !== 14) {
          hasParams = 1;
          if (parser.token & (8192 | 36864 | 16384)) {
              if (isMappedType || (parser.token === 33693739 || parser.token === 37000)) {
                  type = parseType(parser, context, 0, 0, 0);
                  isGroupedType = 1;
              }
              else {
                  const { tokenValue } = parser;
                  nextToken(parser, context);
                  if (parser.token === 22 || parser.token === 21) {
                      type = parseIdentifierFromValue(parser, context, tokenValue, 1);
                  }
                  else {
                      if (consumeOpt(parser, context, 16)) {
                          if (consumeOpt(parser, context, 10)) {
                              return finishNode({
                                  type: astType,
                                  params: [parseIdentifierFromValue(parser, context, tokenValue, 0)],
                                  returnType: parseTypeAnnotationNoConsume(parser, context, 0),
                                  typeParameters: null
                              });
                          }
                          return finishNode({
                              type: 'ParenthesizedType',
                              typeAnnotation: {
                                  type: primaryTypes[tokenValue]
                              }
                          });
                      }
                      else {
                          type = parseTypeFromValue(parser, context, tokenValue);
                          type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
                          isGroupedType = 1;
                      }
                  }
              }
          }
          else {
              hasParams = 1;
              if ((parser.token & 4194304) === 4194304) {
                  type =
                      parser.token === 4325395
                          ? parseArrayExpressionOrPattern(parser, context, 1, 1, [])
                          : parseObjectTypeMembers(parser, context, typeAlias | 1);
                  type = parseUnionAndIntersectionType(parser, context, type, 0, 0, 0);
                  reinterpretToPattern(parser, type);
              }
              else {
                  type = parseType(parser, context, 0, 0, 0);
              }
              if (consumeOpt(parser, context, 16)) {
                  if ((context & 1073741824) === 0 && consumeOpt(parser, context, 10)) {
                      const returnType = parseTypeAnnotationNoConsume(parser, context, 0);
                      return finishNode({
                          type: astType,
                          params: [type],
                          returnType,
                          typeParameters: null
                      });
                  }
                  reinterpretToTypeLiteral(type);
                  return finishNode({
                      type: 'ParenthesizedType',
                      typeAnnotation: type
                  });
              }
          }
      }
      if (isGroupedType) {
          if (context & 1073741824 && parser.token !== 16)
              return undefined;
          consume(parser, context, 16);
          if (parser.token === 10) {
              report(parser, context, 0);
          }
          return finishNode({
              type: 'ParenthesizedType',
              typeAnnotation: type
          });
      }
      const params = parser.token === 14 ? [parseRestElement(parser, context)] : [];
      if (hasParams)
          params.push(type);
      if (consumeOpt(parser, context, 18)) {
          while (parser.token !== 16) {
              params.push(parseFunctionTypeParam(parser, context));
              if (parser.token !== 16) {
                  consume(parser, context, 18);
              }
          }
      }
      if (context & 1073741824 && parser.token !== 16)
          return undefined;
      consume(parser, context, 16);
      if (context & 1073741824 && parser.token !== 10)
          return undefined;
      consume(parser, context, 10);
      const returnType = parseTypeOrTypePredicate(parser, context, 0);
      return finishNode({
          type: astType,
          params,
          returnType,
          typeParameters: null
      });
  }
  function parseIdentifierFromValue(parser, context, name, allowAnnotations) {
      const optional = allowAnnotations ? consumeOpt(parser, context, 22) : false;
      const typeAnnotation = allowAnnotations && parser.token === 21
          ? parseTypeAnnotation(parser, context, 0)
          : [];
      return finishNode({
          type: 'Identifier',
          name,
          optional,
          typeAnnotation
      });
  }
  function parseRestElement(parser, context) {
      consume(parser, context | 32768, 14);
      const argument = parseExpression(parser, context);
      const optional = consumeOpt(parser, context, 22);
      const typeAnnotation = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
      return finishNode({
          type: 'RestElement',
          argument,
          typeAnnotation,
          optional,
          decorators: []
      });
  }
  function parseQualifiedName(parser, context, entity) {
      while (consumeOpt(parser, context, 13)) {
          entity = finishNode({
              type: 'QualifiedName',
              left: entity,
              right: parseIdentifier(parser, context)
          });
      }
      return entity;
  }
  function parseTypeReferenceFromExpression(parser, context, expr) {
      let typeParameters = null;
      const typeName = parseQualifiedName(parser, context, expr);
      if (!parser.precedingLineBreak && parser.token === 16910400) {
          typeParameters = parseTypeParameterInstantiation(parser, context);
      }
      return finishNode({
          type: 'TypeReference',
          typeName,
          typeParameters
      });
  }
  function parseTupleType(parser, context) {
      const types = [];
      consume(parser, context, 4325395);
      let prevIsOptional = 0;
      let seenRest = 0;
      while (parser.token !== 20) {
          let element;
          if (parser.token === 14) {
              seenRest = 1;
              nextToken(parser, context);
              element = finishNode({
                  type: 'RestType',
                  typeAnnotation: parseType(parser, context, 0, 0, 0)
              });
          }
          else {
              element = parseType(parser, context, 0, 0, 0);
              if (parser.token === 22) {
                  nextToken(parser, context);
                  prevIsOptional = 1;
                  element = finishNode({
                      type: 'OptionalType',
                      typeAnnotation: element
                  });
              }
              else {
                  if (prevIsOptional)
                      report(parser, context, 81);
                  if (seenRest)
                      report(parser, context, 82);
              }
          }
          types.push(element);
          if (parser.token === 20) {
              break;
          }
          consume(parser, context, 18);
      }
      consume(parser, context, 20);
      return finishNode({
          type: 'TupleType',
          elementTypes: types
      });
  }
  function parseFunctionTypeParams(parser, context) {
      const params = [];
      while (parser.token !== 16) {
          params.push(parseFunctionTypeParam(parser, context));
          if (parser.token !== 16) {
              consume(parser, context, 18);
          }
      }
      return params;
  }
  function parseFunctionTypeParam(parser, context) {
      if (parser.token === 14)
          return parseRestElement(parser, context);
      if ((parser.token & 4194304) === 4194304) {
          const name = parser.token === 4325388
              ? parseObjectLiteralOrPattern(parser, context, 0, 1, [])
              : parseArrayExpressionOrPattern(parser, context, 0, 1, []);
          reinterpretToPattern(parser, name);
          return name;
      }
      return parseBindingIdentifier(parser, context, 0, 1);
  }
  function parseObjectTypeMembers(parser, context, typeAlias) {
      let optional = false;
      let key;
      let isReadOnly = false;
      let isStatic = false;
      let isUnambiguouslyIndexSignature = 0;
      const members = [];
      consume(parser, context, 4325388);
      while (parser.token !== 2097167) {
          const { token } = parser;
          if (token === 50465329 || token === 50465328) {
              nextToken(parser, context);
              if (parser.token !== 561287) {
                  report(parser, context, 35);
              }
              nextToken(parser, context);
              isReadOnly = KeywordDescTable[token & 255];
          }
          else if (token === 561287) {
              nextToken(parser, context);
              isReadOnly = true;
          }
          isStatic = consumeOpt(parser, context, 540779);
          if (parser.token === 4325395) {
              nextToken(parser, context);
              if (parser.token === 20)
                  report(parser, context, 50);
              let hasTypeAnnotation = 0;
              if (parser.token & 524288) {
                  report(parser, context, parser.token === 134779008 ? 61 : 60);
              }
              let id;
              if ((parser.token & (8192 | 36864)) > 0) {
                  const { tokenValue } = parser;
                  nextToken(parser, context);
                  if (parser.token === 22) {
                      report(parser, context, 50);
                  }
                  if (parser.token === 33685550) {
                      report(parser, context, 77);
                  }
                  if (parser.token === 16918578) {
                      const mapped = parseMappedType(parser, context, tokenValue, isReadOnly);
                      consume(parser, context, 2097167);
                      return mapped;
                  }
                  const optional = consumeOpt(parser, context, 22);
                  if (parser.token === 21) {
                      if (isStatic)
                          report(parser, context, 57, 0, 'an index signature');
                      isUnambiguouslyIndexSignature = 1;
                      hasTypeAnnotation = 1;
                      let typeAnnotation = [];
                      if (consumeOpt(parser, context, 21)) {
                          if (parser.token & 4194304 || parser.token === 131083) {
                              report(parser, context, 78);
                          }
                          typeAnnotation = parseTypeAnnotationNoConsume(parser, context, 1);
                      }
                      id = finishNode({
                          type: 'Identifier',
                          name: tokenValue,
                          optional,
                          typeAnnotation
                      });
                  }
                  else {
                      if (parser.token === 18)
                          report(parser, context, 52);
                      id = parseIdentifierFromValue(parser, context, tokenValue, 0);
                      if (parser.token !== 20) {
                          id = parseMemberOrUpdateExpression(parser, context, id);
                          id = parseAssignmentExpression(parser, context, id);
                      }
                  }
                  id = parseMemberOrUpdateExpression(parser, context, id);
              }
              consume(parser, context, 20);
              if (hasTypeAnnotation && parser.token !== 21)
                  report(parser, context, 51);
              if (!isUnambiguouslyIndexSignature) {
                  optional = consumeOpt(parser, context, 22);
                  members.push(parser.token === 16910400 || parser.token === 131083
                      ? parseObjectTypeMembersMethod(parser, context, isReadOnly, optional, id)
                      : parsePropertySignature(parser, context, optional, isReadOnly, id));
              }
              else {
                  consume(parser, context, 21);
                  const typeAnnotation = parseType(parser, context, 0, 0, typeAlias);
                  members.push(finishNode({
                      type: 'IndexSignature',
                      parameters: [id],
                      typeAnnotation,
                      readonly: false,
                      accessibility: null,
                      export: false,
                      static: false
                  }));
              }
          }
          else if (parser.token === 131083 || parser.token === 16910400) {
              members.push(parseCallSignatureDeclaration(parser, context));
              typeAlias = (typeAlias | 1) ^ 1;
          }
          else if (parser.token === 139356) {
              members.push(parseConstructSignatureDeclaration(parser, context));
              typeAlias = (typeAlias | 1) ^ 1;
          }
          else if (typeAlias & 1) {
              if (parser.token === 14) {
                  members.push(parseSpreadOrRestElement(parser, context, 2097167, 0, []));
              }
              else {
                  let value;
                  let isShortHand = false;
                  key = parseObjectPropertyKey(parser, context);
                  const { token } = parser;
                  if (token === 18 || token === 2097167 || token === 8388638) {
                      isShortHand = true;
                      if (consumeOpt(parser, context | 32768, 8388638)) {
                          const right = parseExpression(parser, context);
                          value = finishNode({
                              type: 'AssignmentPattern',
                              left: key,
                              right
                          });
                      }
                      else {
                          value = key;
                      }
                  }
                  else if (token === 21) {
                      nextToken(parser, context);
                      if (parser.token & (8192 | 36864 | 16384)) {
                          value = parsePrimaryExpression(parser, context, 1, 0);
                          value = parseMemberOrUpdateExpression(parser, context, value);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else if (parser.token === 8388638) {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                          else {
                              value = parseAssignmentExpression(parser, context, value);
                          }
                      }
                      else if ((parser.token & 4194304) === 4194304) {
                          value =
                              parser.token === 4325388
                                  ? parseObjectLiteralOrPattern(parser, context, 0, 1, [])
                                  : parseArrayExpressionOrPattern(parser, context, 0, 1, []);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              const { token } = parser;
                              if (token !== 18 && token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                      else {
                          value = parseLeftHandSideExpression(parser, context, 1);
                          if (parser.token === 18 || parser.token === 2097167) ;
                          else {
                              value = parseMemberOrUpdateExpression(parser, context, value);
                              const { token } = parser;
                              if (token !== 18 && token !== 2097167) {
                                  value = parseAssignmentExpression(parser, context, value);
                              }
                          }
                      }
                  }
                  members.push(finishNode({
                      type: 'Property',
                      key,
                      value,
                      kind: 'init',
                      computed: false,
                      method: false,
                      shorthand: isShortHand
                  }));
              }
          }
          else {
              key = parseObjectPropertyKey(parser, context);
              optional = consumeOpt(parser, context, 22);
              if (parser.token === 16910400 || parser.token === 131083) {
                  members.push(parseObjectTypeMembersMethod(parser, context, isReadOnly, optional, key));
              }
              else {
                  if (typeAlias & 2 && parser.token === 8388638) {
                      report(parser, context, 56);
                  }
                  members.push(parsePropertySignature(parser, context, optional, isReadOnly, key));
              }
          }
          if (!consumeOpt(parser, context, 18)) {
              consumeSemicolon(parser, context);
          }
      }
      consume(parser, context, 2097167);
      if (typeAlias & 1) {
          const optional = consumeOpt(parser, context, 22);
          const typeAnnotation = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
          return finishNode({
              type: 'ObjectExpression',
              properties: members,
              typeAnnotation,
              optional,
              decorators: []
          });
      }
      return finishNode({
          type: 'TypeLiteral',
          members
      });
  }
  function parseMappedType(parser, context, name, readonly) {
      const typeParameter = parseMappedTypeParameter(parser, context, name);
      consume(parser, context, 20);
      let optional = consumeOpt(parser, context, 22);
      if (!optional) {
          if (parser.token === 50465328 || parser.token === 50465329) {
              optional = KeywordDescTable[parser.token & 255];
              nextToken(parser, context);
              consumeOpt(parser, context, 22);
          }
      }
      const typeAnnotation = consumeOpt(parser, context, 21)
          ? parseType(parser, context, 0, 0, 0)
          : [];
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'MappedType',
          typeAnnotation,
          typeParameter,
          readonly,
          optional
      });
  }
  function parseMappedTypeParameter(parser, context, value) {
      const name = parseIdentifierFromValue(parser, context, value, 0);
      consume(parser, context, 16918578);
      const constraint = parseType(parser, context, 0, 1, 0);
      return finishNode({
          type: 'TypeParameter',
          name,
          constraint,
          default: null
      });
  }
  function parseObjectTypeMembersMethod(parser, context, isStatic, optional, key) {
      const params = [];
      let typeParameters = null;
      if (parser.token === 16910400) {
          typeParameters = parseTypeParameters(parser, context);
      }
      consume(parser, context, 131083);
      while (parser.token !== 16) {
          params.push(parseFunctionTypeParam(parser, context));
          if (parser.token !== 16) {
              consume(parser, context, 18);
          }
      }
      consume(parser, context, 16);
      const returnType = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : null;
      consumeOpt(parser, context, 2097169);
      return finishNode({
          type: 'MethodSignature',
          key,
          optional,
          static: isStatic,
          computed: false,
          params,
          returnType,
          readonly: false,
          typeParameters,
          accessibility: null,
          export: false
      });
  }
  function parsePropertySignature(parser, context, optional, isReadOnly, key) {
      const typeAnnotation = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
      consumeOpt(parser, context, 2097169);
      const initializer = consumeOpt(parser, context | 32768, 8388638)
          ? parseExpression(parser, context)
          : null;
      return finishNode({
          type: 'PropertySignature',
          key,
          optional,
          computed: false,
          readonly: isReadOnly,
          typeAnnotation,
          initializer,
          static: false,
          export: false,
          accessibility: null
      });
  }
  function parseCallSignatureDeclaration(parser, context) {
      const params = [];
      const typeParameters = parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      consume(parser, context, 131083);
      while (parser.token !== 16) {
          params.push(parseFunctionTypeParam(parser, context));
          if (parser.token !== 16) {
              consume(parser, context, 18);
          }
      }
      consume(parser, context, 16);
      consumeOpt(parser, context, 2097169);
      const returnType = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : null;
      consumeOpt(parser, context, 2097169);
      return finishNode({
          type: 'CallSignatureDeclaration',
          params,
          returnType,
          typeParameters
      });
  }
  function parseConstructSignatureDeclaration(parser, context) {
      nextToken(parser, context);
      const params = [];
      const typeParameters = parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      consume(parser, context, 131083);
      while (parser.token !== 16) {
          params.push(parseFunctionTypeParam(parser, context));
          if (parser.token !== 16) {
              consume(parser, context, 18);
          }
      }
      consume(parser, context, 16);
      consumeOpt(parser, context, 2097169);
      const returnType = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : null;
      return finishNode({
          type: 'ConstructSignatureDeclaration',
          params,
          returnType,
          typeParameters
      });
  }
  function parseObjectPropertyKey(parser, context) {
      const { token, tokenValue } = parser;
      nextToken(parser, context);
      if ((token & (36864 | 8192 | 16384 | 268435456)) === 0)
          report(parser, context, 35);
      return (token & 268435456) === 268435456
          ? finishNode({
              type: 'Literal',
              value: tokenValue
          })
          : parseIdentifierFromValue(parser, context, tokenValue, 0);
  }
  function parseClassDeclarationOrIdentifier(parser, context, token, abstract, declare) {
      if (parser.token === 142)
          report(parser, context, 100);
      const expr = parseIdentifier(parser, context);
      if (parser.token !== 139343)
          return parseExpressionOrLabelledStatement(parser, context, expr, token);
      return parseTypescriptClassDeclaration(parser, context, 0, declare, abstract);
  }
  function parseTypeAliasOrIdentifier(parser, context, token, declare) {
      const expr = parseIdentifier(parser, context);
      if (parser.precedingLineBreak || (parser.token & 36864) === 0) {
          return parseExpressionOrLabelledStatement(parser, context, expr, token);
      }
      return parseTypeAlias(parser, context, declare);
  }
  function parseTypeAlias(parser, context, declare) {
      const id = parseIdentifier(parser, context);
      const typeParameters = parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      consume(parser, context, 8388638);
      const typeAnnotation = parseType(parser, context, 0, 0, 2);
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'TypeAliasDeclaration',
          id,
          typeAnnotation,
          declare: declare === 1,
          typeParameters
      });
  }
  function parseInterfaceOrIdentifier(parser, context, token, declare) {
      const expr = parseIdentifier(parser, context);
      if (parser.precedingLineBreak || (parser.token & 36864) === 0) {
          if (context & 1024)
              report(parser, context, 0);
          return parseExpressionOrLabelledStatement(parser, context, expr, token);
      }
      return parseInterfaceDeclaration(parser, context, declare);
  }
  function parseInterfaceDeclaration(parser, context, declare) {
      const id = parseIdentifier(parser, context);
      const typeParameters = parser.token === 16910400 ? parseTypeParameters(parser, context) : null;
      const heritage = [];
      if (consumeOpt(parser, context, 8278)) {
          while (parser.token !== 0) {
              heritage.push(parseHeritageClausesOrClassImplements(parser, context, 'InterfaceHeritage'));
              if (parser.token !== 18) {
                  break;
              }
              consume(parser, context, 18);
          }
      }
      const body = parseInterfaceBody(parser, context);
      return finishNode({
          type: 'InterfaceDeclaration',
          body,
          id,
          typeParameters,
          extends: heritage,
          implements: [],
          decorators: [],
          abstract: false,
          declare: declare === 1
      });
  }
  function parseIndexSignature(parser, context, isStatic, readonly) {
      let hasTypeAnnotation = 0;
      let isUnambiguouslyIndexSignature = 0;
      const parameters = [];
      nextToken(parser, context);
      if ((parser.token & 524288) === 524288) {
          report(parser, context, 49, 0, 'Accessibility');
      }
      let left;
      while (parser.token !== 20) {
          if ((parser.token & 36864) === 36864) {
              const { tokenValue } = parser;
              nextToken(parser, context);
              if (parser.token === 22) {
                  report(parser, context, 50);
              }
              if (parser.token === 33685550) {
                  report(parser, context, 77);
              }
              if (parser.token === 21) {
                  if (isStatic)
                      report(parser, context, 57, 0, 'an index signature');
                  isUnambiguouslyIndexSignature = 1;
                  hasTypeAnnotation = 1;
                  let typeAnnotation = [];
                  if (consumeOpt(parser, context, 21)) {
                      if (parser.token & 4194304 || parser.token === 131083) {
                          report(parser, context, 78);
                      }
                      typeAnnotation = parseTypeAnnotationNoConsume(parser, context, 1);
                  }
                  left = finishNode({
                      type: 'Identifier',
                      name: tokenValue,
                      optional: false,
                      typeAnnotation
                  });
              }
              else {
                  if (isStatic)
                      report(parser, context, 57, 0, 'a type member');
                  if (parser.token === 16918578)
                      report(parser, context, 77);
                  if (parser.token === 18) {
                      report(parser, context, 52);
                  }
                  left = parseIdentifierFromValue(parser, context, tokenValue, 0);
                  left = parseMemberOrUpdateExpression(parser, context, left);
                  left = parseAssignmentExpression(parser, context, left);
              }
          }
          else {
              if (parser.token === 33685550) {
                  report(parser, context, 77);
              }
              left = parseExpression(parser, context);
          }
          parameters.push(left);
          if (parser.token !== 20) {
              consume(parser, context, 18);
          }
      }
      consume(parser, context, 20);
      if (parser.token === 16910400 || parser.token === 131083) {
          return parseObjectTypeMembersMethod(parser, context, isStatic, true, parameters[0]);
      }
      if (hasTypeAnnotation && parser.token !== 21)
          report(parser, context, 51);
      const optional = consumeOpt(parser, context, 22);
      const typeAnnotation = parser.token === 21 ? parseTypeAnnotation(parser, context, 0) : [];
      return isUnambiguouslyIndexSignature
          ? finishNode({
              type: 'IndexSignature',
              parameters: parameters,
              typeAnnotation,
              readonly: false,
              accessibility: null,
              export: false,
              static: false
          })
          : finishNode({
              type: 'PropertySignature',
              key: parameters[0],
              optional,
              computed: true,
              readonly,
              typeAnnotation,
              initializer: null,
              static: false,
              export: false,
              accessibility: null
          });
  }
  function parseInterfaceBody(parser, context) {
      consume(parser, context, 4325388);
      const body = [];
      while (parser.token !== 2097167) {
          let isReadOnlyAsIdent = 0;
          let key = null;
          if (parser.token === 561287) {
              const { tokenValue } = parser;
              nextToken(parser, context);
              if (parser.token === 22 || parser.token === 21) {
                  key = parseIdentifierFromValue(parser, context, tokenValue, 0);
                  isReadOnlyAsIdent = 1;
              }
          }
          const isReadOnly = consumeOpt(parser, context, 561287);
          const isStatic = consumeOpt(parser, context, 540779) && parser.token !== 131083;
          if (parser.token === 4325395) {
              body.push(parseIndexSignature(parser, context, isStatic, isReadOnly));
          }
          else {
              if (isStatic)
                  report(parser, context, 57, 0, 'a type member');
              if (parser.token === 131083 || parser.token === 16910400) {
                  body.push(parseCallSignatureDeclaration(parser, context));
              }
              else if (parser.token === 139356) {
                  body.push(parseConstructSignatureDeclaration(parser, context));
              }
              else {
                  if (!isReadOnlyAsIdent)
                      key = parseObjectPropertyKey(parser, context);
                  const isOptional = consumeOpt(parser, context, 22);
                  if (parser.token === 16910400 || parser.token === 131083) {
                      body.push(parseObjectTypeMembersMethod(parser, context, isReadOnly, isOptional, key));
                  }
                  else {
                      body.push(parsePropertySignature(parser, context, isOptional, isReadOnly, key));
                  }
              }
              if (parser.token !== 2097167)
                  consumeOpt(parser, context, 18);
          }
      }
      if (parser.token !== 2097167)
          report(parser, context, 0);
      consume(parser, context, 2097167);
      return finishNode({
          type: 'InterfaceBody',
          body
      });
  }
  function parseHeritageClausesOrClassImplements(parser, context, type) {
      const expression = parseEntityName(parser, context);
      const typeParameters = parser.token === 16910400 ? parseTypeParameterInstantiation(parser, context) : null;
      return finishNode({
          type,
          expression,
          typeParameters
      });
  }
  function parseConstEnumOrVariableStatement(parser, context, declare) {
      nextToken(parser, context);
      if (consumeOpt(parser, context, 134226044)) {
          return parseEnumDeclaration(parser, context, declare, 1);
      }
      const declarations = parseVariableDeclarationList(parser, context, 16, declare ? 128 : 0);
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'VariableDeclaration',
          kind: 'const',
          declare: declare === 1,
          declarations
      });
  }
  function parseEnumDeclaration(parser, context, declare, isConst) {
      const id = parseIdentifier(parser, context);
      consume(parser, context, 4325388);
      const members = [];
      while (parser.token !== 2097167) {
          members.push(parseEnumMembers(parser, context));
          if (parser.token === 2097167) {
              break;
          }
          consume(parser, context, 18);
      }
      consume(parser, context, 2097167);
      return finishNode({
          type: 'EnumDeclaration',
          const: isConst === 1,
          declare: declare === 1,
          modifiers: [],
          decorators: [],
          members,
          id
      });
  }
  function parseEnumDeclarationOrIdentifier(parser, context, token, declare, isConst) {
      const expr = parseIdentifier(parser, context);
      if (parser.precedingLineBreak || (parser.token & 36864) === 0) {
          return parseExpressionOrLabelledStatement(parser, context, expr, token);
      }
      const id = parseIdentifier(parser, context);
      consume(parser, context, 4325388);
      const members = [];
      while (parser.token !== 2097167) {
          members.push(parseEnumMembers(parser, context));
          if (parser.token === 2097167) {
              break;
          }
          consume(parser, context, 18);
      }
      consume(parser, context, 2097167);
      return finishNode({
          type: 'EnumDeclaration',
          const: isConst === 1,
          declare: declare === 1,
          modifiers: [],
          decorators: [],
          members,
          id
      });
  }
  function parseEnumMembers(parser, context) {
      let id = null;
      if (parser.token & (4096 | 8192 | 36864)) {
          id = parseIdentifier(parser, context);
      }
      else {
          switch (parser.token) {
              case 268566531:
                  id = parseLiteral(parser, context);
                  break;
              case 268566530:
                  report(parser, context, 72);
              default:
                  report(parser, context, 71);
          }
      }
      if (parser.token === 268566530 || parser.token === 123) ;
      const initializer = consumeOpt(parser, context, 8388638) ? parseExpression(parser, context) : null;
      return finishNode({
          type: 'EnumMember',
          id: id,
          initializer
      });
  }
  function parseNamespaceOrIdentifier(parser, context, token, declare) {
      const expr = parseIdentifier(parser, context);
      if (parser.precedingLineBreak || (parser.token & 36864) === 0) {
          return parseExpressionOrLabelledStatement(parser, context, expr, token);
      }
      return parseModuleDeclaration(parser, context, declare);
  }
  function parseModuleDeclaration(parser, context, declare) {
      const id = parseIdentifier(parser, context);
      let body;
      if (consumeOpt(parser, context, 13)) {
          body = parseModuleDeclaration(parser, context, declare);
      }
      else {
          body = parseModuleBlock(parser, context);
      }
      consumeSemicolon(parser, context);
      return finishNode({
          type: 'ModuleDeclaration',
          id,
          body,
          global: false,
          declare: declare === 1,
          modifiers: []
      });
  }
  function parseModuleBlock(parser, context) {
      const body = [];
      consume(parser, context | 32768, 4325388);
      while (parser.token & 430080) {
          body.push(parseDeclarationList(parser, context, 1, 0, false));
      }
      consume(parser, context, 2097167);
      return finishNode({
          type: 'ModuleBlock',
          body
      });
  }
  function parseGlobalModuleDeclarationOrIdentifier(parser, context, token, declare) {
      const id = parseIdentifier(parser, context);
      if (parser.precedingLineBreak || parser.token !== 4325388) {
          if (context & 1024)
              report(parser, context, 0);
          return parseExpressionOrLabelledStatement(parser, context, id, token);
      }
      const body = parser.token === 4325388 ? parseModuleBlock(parser, context) : null;
      if (!body)
          consumeSemicolon(parser, context);
      return finishNode({
          type: 'ModuleDeclaration',
          id,
          body,
          global: true,
          declare: declare === 1,
          modifiers: []
      });
  }
  function parseModuleDeclarationOrIdentifier(parser, context, token, declare) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      let body = null;
      let id;
      if (parser.precedingLineBreak ||
          (parser.token !== 268566531 && (parser.token & 36864) === 0)) {
          if (context & 1024)
              report(parser, context, 0);
          return parseExpressionOrLabelledStatement(parser, context, parseIdentifierFromValue(parser, context, tokenValue, 0), token);
      }
      if (parser.token === 268566531) {
          id = parseLiteral(parser, context);
          if (parser.token === 4325388) {
              body = parseModuleBlock(parser, context);
          }
          else {
              consumeSemicolon(parser, context);
          }
          return finishNode({
              type: 'ModuleDeclaration',
              id,
              body: body,
              global: false,
              declare: declare === 1,
              modifiers: []
          });
      }
      return parseModuleDeclaration(parser, context, declare);
  }
  function parseTypeParameterInstantiation(parser, context) {
      const params = [];
      consume(parser, context, 16910400);
      return parseTypeParameterInstantiationOrHigher(parser, context, params);
  }
  function parseTypeParameterInstantiationOrHigher(parser, context, params) {
      while (parser.token !== 16910401) {
          params.push(parseType(parser, context, 0, 0, 0));
          if (parser.token !== 16910401) {
              if (parser.token !== 18 && context & 1073741824)
                  return undefined;
              consume(parser, context, 18);
          }
      }
      consume(parser, context, 16910401);
      return finishNode({
          type: 'TypeParameterInstantiation',
          params
      });
  }
  function parseJSXFragment(parser, context, inJSXChild) {
      return finishNode({
          type: 'JSXFragment',
          openingFragment: parseJSXOpeningFragment(parser),
          children: parseJSXChildren(parser, context),
          closingFragment: parseJSXClosingFragment(parser, context, inJSXChild)
      });
  }
  function parseJSXOpeningElement(context, name, attributes, selfClosing, typeParameters) {
      return context & 128
          ? finishNode({
              type: 'JSXOpeningElement',
              name,
              attributes,
              selfClosing,
              typeParameters
          })
          : finishNode({
              type: 'JSXOpeningElement',
              name,
              attributes,
              selfClosing
          });
  }
  function parseJSXRootElementOrFragment(parser, context, inJSXChild) {
      nextToken(parser, context);
      if (parser.token === 16910401)
          return parseJSXFragment(parser, context, inJSXChild);
      let closingElement = null;
      let children = [];
      const tagName = parseJSXElementName(parser, context);
      const typeParameters = context & 16 && parser.token === 16910400
          ? parseTypeParameterInstantiation(parser, context)
          : null;
      const attributes = parseJSXAttributes(parser, context);
      const selfClosing = parser.token === 16911158;
      if (parser.token === 16910401) {
          scanJSXToken(parser);
      }
      else {
          consume(parser, context, 16911158);
          if (inJSXChild) {
              consume(parser, context, 16910401);
          }
          else {
              scanJSXToken(parser);
          }
      }
      const openingElement = parseJSXOpeningElement(context, tagName, attributes, selfClosing, typeParameters);
      if (!selfClosing) {
          children = parseJSXChildren(parser, context);
          closingElement = parseJSXClosingElement(parser, context, inJSXChild);
          const close = isEqualTagName(closingElement.name);
          if (isEqualTagName(openingElement.name) !== close) {
              report(parser, context, 92, 0, close);
          }
      }
      return finishNode({
          type: 'JSXElement',
          children,
          openingElement,
          closingElement
      });
  }
  function parseJSXClosingElement(parser, context, inJSXChild) {
      consume(parser, context, 26);
      const name = parseJSXElementName(parser, context);
      if (inJSXChild) {
          consume(parser, context, 16910401);
      }
      else {
          parser.token = scanJSXToken(parser);
      }
      return finishNode({
          type: 'JSXClosingElement',
          name
      });
  }
  function parseJSXAttributes(parser, context) {
      const attributes = [];
      while (parser.token !== 16911158 && parser.token !== 16910401) {
          attributes.push(parseJsxAttribute(parser, context));
      }
      return attributes;
  }
  function parseJSXElementName(parser, context) {
      scanJSXIdentifier(parser);
      let key = parseJSXIdentifier(parser, context);
      if (parser.token === 21)
          return parseJSXNamespacedName(parser, context, key);
      while (consumeOpt(parser, context, 13)) {
          scanJSXIdentifier(parser);
          key = parseJSXMemberExpression(parser, context, key);
      }
      return key;
  }
  function parseJSXMemberExpression(parser, context, object) {
      const property = parseJSXIdentifier(parser, context);
      return finishNode({
          type: 'JSXMemberExpression',
          object,
          property
      });
  }
  function parseJSXOpeningFragment(parser) {
      scanJSXToken(parser);
      return finishNode({
          type: 'JSXOpeningFragment'
      });
  }
  function parseJSXClosingFragment(parser, context, inJSXChild) {
      consume(parser, context, 26);
      if (inJSXChild) {
          consume(parser, context, 16910401);
      }
      else {
          consume(parser, context, 16910401);
      }
      return finishNode({
          type: 'JSXClosingFragment'
      });
  }
  function parseJSXChildren(parser, context) {
      const children = [];
      while (parser.token !== 26) {
          parser.index = parser.tokenPos = parser.startPos;
          parser.column = parser.endColumn = parser.startColumn;
          parser.line = parser.endLine = parser.startLine;
          scanJSXToken(parser);
          children.push(parseJSXChild(parser, context));
      }
      return children;
  }
  function parseJSXChild(parser, context) {
      switch (parser.token) {
          case 141:
              return parseJSXText(parser);
          case 4325388:
              return parseJSXExpressionContainer(parser, context, 0, 0);
          default:
              if (parser.token !== 16910400)
                  report(parser, context, 0);
              return parseJSXRootElementOrFragment(parser, context, 0);
      }
  }
  function parseJSXText(parser) {
      scanJSXToken(parser);
      return finishNode({
          type: 'JSXText',
          value: parser.tokenValue
      });
  }
  function parseJSXExpressionContainer(parser, context, inJSXChild, isAttr) {
      nextToken(parser, context);
      if (parser.token === 14)
          return parseJSXSpreadChild(parser, context);
      let expression = null;
      if (parser.token === 2097167) {
          if (isAttr)
              report(parser, context, 94);
          expression = parseJSXEmptyExpression();
      }
      else {
          expression = parseExpression(parser, context);
      }
      if (inJSXChild) {
          consume(parser, context, 2097167);
      }
      else {
          scanJSXToken(parser);
      }
      return finishNode({
          type: 'JSXExpressionContainer',
          expression: expression
      });
  }
  function parseJSXSpreadChild(parser, context) {
      consume(parser, context, 14);
      const expression = parseExpression(parser, context);
      consume(parser, context, 2097167);
      return finishNode({
          type: 'JSXSpreadChild',
          expression
      });
  }
  function parseJSXEmptyExpression() {
      return finishNode({
          type: 'JSXEmptyExpression'
      });
  }
  function parseJSXIdentifier(parser, context) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      return finishNode({
          type: 'JSXIdentifier',
          name: tokenValue
      });
  }
  function parseJsxAttribute(parser, context) {
      if (parser.token === 4325388)
          return parseJSXSpreadAttribute(parser, context);
      scanJSXIdentifier(parser);
      let value = null;
      let name = parseJSXIdentifier(parser, context);
      if (parser.token === 21) {
          name = parseJSXNamespacedName(parser, context, name);
      }
      if (parser.token === 8388638) {
          const token = scanJSXAttributeValue(parser, context);
          switch (token) {
              case 268566531:
                  value = parseLiteral(parser, context);
                  break;
              case 16910400:
                  value = parseJSXRootElementOrFragment(parser, context, 1);
                  break;
              case 4325388:
                  value = parseJSXExpressionContainer(parser, context, 1, 1);
                  break;
              default:
                  report(parser, context, 93);
          }
      }
      return finishNode({
          type: 'JSXAttribute',
          value,
          name
      });
  }
  function parseJSXSpreadAttribute(parser, context) {
      nextToken(parser, context);
      consume(parser, context, 14);
      const expression = parseExpression(parser, context);
      consume(parser, context, 2097167);
      return finishNode({
          type: 'JSXSpreadAttribute',
          argument: expression
      });
  }
  function parseJSXNamespacedName(parser, context, namespace) {
      consume(parser, context, 21);
      const name = parseJSXIdentifier(parser, context);
      return finishNode({
          type: 'JSXNamespacedName',
          namespace,
          name
      });
  }
  function parseDecorators(parser, context) {
      const list = [];
      while (consumeOpt(parser, context, 142)) {
          list.push(parseDecoratorList(parser, context));
      }
      return list;
  }
  function parseDecoratorList(parser, context) {
      let expression = parsePrimaryExpression(parser, context, 0, 0);
      expression = parseMemberOrUpdateExpression(parser, context, expression);
      return finishNode({
          type: 'Decorator',
          expression
      });
  }
  function parseAssertsTypePredicateOrTypePredicate(parser, context) {
      const { tokenValue } = parser;
      nextToken(parser, context);
      if (parser.precedingLineBreak === 0) {
          const parameterName = parser.token === 139360 ? parseThisExpression(parser, context) : parseIdentifier(parser, context);
          const typeAnnotation = consumeOpt(parser, context, 36998)
              ? parseType(parser, context, 0, 0, 0)
              : null;
          return finishNode({
              type: 'TypePredicate',
              assertsModifier: true,
              parameterName,
              typeAnnotation
          });
      }
      return parseTypeReferenceFromExpression(parser, context, parseIdentifierFromValue(parser, context, tokenValue, 0));
  }

  function parseScript(source, options, onError) {
      return parseSource(source, options, 0, onError);
  }
  function parseModule(source, options, onError) {
      return parseSource(source, options, 1024 | 2048, onError);
  }
  function parseTSModule(source, options, onError) {
      return parseSource(source, options, 1024 | 2048 | 128, onError);
  }
  function parseTSScript(source, options, onError) {
      return parseSource(source, options, 128, onError);
  }
  const version = '0.1.60';

  exports.ESTree = estree;
  exports.parseModule = parseModule;
  exports.parseScript = parseScript;
  exports.parseTSModule = parseTSModule;
  exports.parseTSScript = parseTSScript;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

});
