import { Comment, Node } from './estree';
import { Token } from './token';
export declare const enum Context {
    Empty = 0,
    OptionsNext = 1,
    OptionsRanges = 2,
    OptionsLoc = 4,
    OptionsDirectives = 8,
    OptionsJSX = 16,
    OptionsGlobalReturn = 32,
    OptionsRaw = 64,
    OptionsTS = 128,
    DisableWebCompat = 256,
    OptionsIdentifierPattern = 512,
    Strict = 1024,
    Module = 2048,
    InSwitch = 4096,
    InGlobal = 8192,
    InClass = 16384,
    AllowRegExp = 32768,
    TaggedTemplate = 65536,
    InIteration = 131072,
    SuperProperty = 262144,
    SuperCall = 524288,
    InYieldContext = 2097152,
    InAwaitContext = 4194304,
    InArgumentList = 8388608,
    InConstructor = 16777216,
    InMethod = 33554432,
    AllowNewTarget = 67108864,
    DisallowIn = 134217728,
    InTSTypes = 268435456,
    Conditional = 536870912,
    Speculative = 1073741824,
    InDecoratorContext = 1048576
}
export declare const enum ModifierKind {
    None = 0,
    Abstract = 1,
    Public = 2,
    Private = 4,
    Protected = 8,
    Readonly = 16,
    Static = 32,
    Accessibility = 14
}
export declare const enum TypeAssertionState {
    None = 0,
    TypeParameter = 1,
    TypeAssertion = 2,
    Unfinished = 4,
    UnKnown = 8
}
export declare const enum TypeAliasState {
    None = 0,
    Pattern = 1,
    TypeMember = 2
}
export declare const enum Flags {
    Empty = 0,
    HasConstructor = 1
}
export declare const enum PropertyKind {
    None = 0,
    Method = 1,
    Computed = 2,
    Shorthand = 4,
    Generator = 8,
    Async = 16,
    Static = 32,
    Constructor = 64,
    ClassField = 128,
    Getter = 256,
    Setter = 512,
    Extends = 1024,
    Literal = 2048,
    Abstract = 4096,
    Readonly = 8192,
    GetSet = 768
}
export declare const enum BindingKind {
    None = 0,
    ArgumentList = 1,
    Empty = 2,
    Variable = 4,
    Let = 8,
    Const = 16,
    Class = 32,
    FunctionLexical = 64,
    FunctionStatement = 128,
    CatchPattern = 256,
    CatchIdentifier = 512,
    CatchIdentifierOrPattern = 768,
    LexicalOrFunction = 68,
    LexicalBinding = 248
}
export declare const enum Origin {
    None = 0,
    Statement = 1,
    BlockStatement = 2,
    TopLevel = 4,
    Declaration = 8,
    Arrow = 16,
    ForStatement = 32,
    Export = 64,
    Declare = 128
}
export declare const enum ClassAndFunctionFlags {
    None = 0,
    Hoisted = 1,
    Export = 2
}
export declare const enum TypeScriptMadness {
    Definite = 2
}
export interface Options {
    onComment?: CommentCallback;
    onError?: ErrorCallback;
    next?: boolean;
    ts?: boolean;
    module?: boolean;
    ranges?: boolean;
    jsx?: boolean;
    raw?: boolean;
    loc?: boolean;
    directives?: boolean;
    globalReturn?: boolean;
    impliedStrict?: boolean;
    disableWebCompat?: boolean;
    identifierPattern?: boolean;
}
export declare type CommentCallback = void | Comment[] | ((type: string, value: string, start: number, end: number) => any);
export declare type ErrorCallback = void | {
    (message: string, index: number, line: number, column: number, early: 0 | 1): void;
};
export interface ParserState {
    source: string;
    onComment: CommentCallback | undefined;
    onError: ErrorCallback | undefined;
    startPos: number;
    tokenPos: number;
    startColumn: number;
    startLine: number;
    endLine: number;
    endColumn: number;
    flags: Flags;
    index: number;
    line: number;
    column: number;
    length: number;
    uid: number;
    precedingLineBreak: 0 | 1;
    token: Token;
    tokenValue: any;
    tokenRaw: string;
    tokenRegExp: void | {
        pattern: string;
        flags: string;
    };
    nextCodePoint: number;
}
export declare function consume(parser: ParserState, context: Context, t: Token): boolean;
export declare function consumeOpt(parser: ParserState, context: Context, t: Token): boolean;
export declare function optionalBit(parser: ParserState, context: Context, t: Token): 0 | 1;
export declare function canParseSemicolon(parser: ParserState): true | 0 | 1;
export declare function consumeSemicolon(parser: ParserState, context: Context): boolean;
export declare function reinterpretToPattern(state: ParserState, node: any): void;
export declare function isValidIdentifier(context: Context, t: Token): boolean;
export declare function reinterpretToTypeLiteral(node: any): void;
export declare function lookAhead<T>(parser: ParserState, context: Context, callback: (parser: ParserState, context: Context) => T): T;
export declare function tryScan<T>(parser: ParserState, context: Context, callback: (parser: ParserState, context: Context) => T): T;
export declare function speculationHelper<T>(parser: ParserState, context: Context, callback: (parser: ParserState, context: Context) => T, isLookahead: boolean): T;
export declare function canFollowTypeArgumentsInExpression(parser: ParserState): boolean;
export declare function isStrictReservedWord(parser: ParserState, context: Context, t: Token): boolean;
export declare function validateFunctionName(parser: ParserState, context: Context, t: Token): void;
export declare function finishNode<T extends Node>(node: T): T;
//# sourceMappingURL=common.d.ts.map