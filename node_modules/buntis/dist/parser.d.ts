import { Token } from './token';
import * as ESTree from './estree';
import { Context, Origin, BindingKind, CommentCallback, ErrorCallback, ParserState, PropertyKind, Options, ModifierKind, TypeAssertionState, TypeAliasState, ClassAndFunctionFlags } from './common';
export declare function create(source: string, onError?: ErrorCallback, onComment?: CommentCallback): ParserState;
export declare function parseSource(source: string, options: Options | void, context: Context, onError?: ErrorCallback): ESTree.Program;
export declare function parseDeclarations(parser: ParserState, context: Context): ESTree.DeclarationStatement[];
export declare function parseDeclarationList(parser: ParserState, context: Context, isModule: 0 | 1, declare: 0 | 1, isExport: boolean): any;
export declare function parseStatementList(parser: ParserState, context: Context): any;
export declare function parseStatementListItem(parser: ParserState, context: Context, pos: number): any;
export declare function parseAsyncArrowOrAsyncFunctionDeclaration(parser: ParserState, context: Context): any;
export declare function parseAsyncIdentifierOrParameterInstantiation(parser: ParserState, context: Context): ESTree.TypeParameterInstantiation | void;
export declare function parseAsyncArrowOrCallExpression(parser: ParserState, context: Context, isLHS: 0 | 1, typeParameters: any, callee: ESTree.Identifier | void): any;
export declare function parseModuleItemList(parser: ParserState, context: Context): any;
export declare function parseModuleItem(parser: ParserState, context: Context): any;
export declare function parseImportCallDeclaration(parser: ParserState, context: Context): ESTree.ExpressionStatement;
export declare function parseExportAssignment(parser: ParserState, context: Context): any;
export declare function parseExportNamedDeclaration(parser: ParserState, context: Context): {
    type: "ExportNamedDeclaration";
    declaration: any;
    specifiers: never[];
    source: null;
};
export declare function parseNamespaceExportDeclaration(parser: ParserState, context: Context): {
    type: "NamespaceExportDeclaration";
    id: any;
};
export declare function parseTypeScriptExportDeclaration(parser: ParserState, context: Context, decrorators: ESTree.Decorator[]): any;
export declare function parseModuleOrNamespaceDeclaration(parser: ParserState, context: Context): any;
export declare function parseExternalModuleReference(parser: ParserState, context: Context): any;
export declare function parseExportDefaultDeclaration(parser: ParserState, context: Context, decorators?: ESTree.Decorator[]): any;
export declare function parseExportDeclaration(parser: ParserState, context: Context): any;
export declare function parseStatement(parser: ParserState, context: Context, pos: number): any;
export declare function parseExpressionOrLabelledStatement(parser: ParserState, context: Context, expr: any, token: Token, pos: number): any;
export declare function parseReturnStatement(parser: ParserState, context: Context): ESTree.ReturnStatement;
export declare function parseEmptyStatement(parser: ParserState, context: Context): ESTree.EmptyStatement;
export declare function parseThrowStatement(parser: ParserState, context: Context): any;
export declare function parseIfStatement(parser: ParserState, context: Context): ESTree.IfStatement;
export declare function parseForStatement(parser: ParserState, context: Context): ESTree.ForStatement | ESTree.ForInStatement | ESTree.ForOfStatement;
export declare function parseConsequentOrAlternative(parser: ParserState, context: Context): ESTree.Statement | ESTree.FunctionDeclaration;
export declare function parseSwitchStatement(parser: ParserState, context: Context): ESTree.SwitchStatement;
export declare function parseWhileStatement(parser: ParserState, context: Context): ESTree.WhileStatement;
export declare function parseIterationStatementBody(parser: ParserState, context: Context): ESTree.Statement;
export declare function parseContinueStatement(parser: ParserState, context: Context): ESTree.ContinueStatement;
export declare function parseBreakStatement(parser: ParserState, context: Context): ESTree.BreakStatement;
export declare function parseWithStatement(parser: ParserState, context: Context): ESTree.WithStatement;
export declare function parseDebuggerStatement(parser: ParserState, context: Context): ESTree.DebuggerStatement;
export declare function parseTryStatement(parser: ParserState, context: Context): ESTree.TryStatement;
export declare function parseCatchBlock(parser: ParserState, context: Context): ESTree.CatchClause;
export declare function parseDoWhileStatement(parser: ParserState, context: Context): ESTree.DoWhileStatement;
export declare function parseLexicalDeclaration(parser: ParserState, context: Context, kind: BindingKind, origin: Origin): ESTree.VariableDeclaration;
export declare function parseVariableStatement(parser: ParserState, context: Context, origin: Origin): ESTree.VariableDeclaration;
export declare function parseVariableDeclarationList(parser: ParserState, context: Context, kind: BindingKind, origin: Origin): ESTree.VariableDeclarator[];
export declare function parseVariableDeclaration(parser: ParserState, context: Context, kind: BindingKind, origin: Origin): ESTree.VariableDeclarator;
export declare function parseBindingPattern(parser: ParserState, context: Context): any;
export declare function parseSequenceExpression(parser: ParserState, context: Context, expr: any): ESTree.SequenceExpression;
export declare function parseExpression(parser: ParserState, context: Context): any;
export declare function parseExpressions(parser: ParserState, context: Context): ESTree.Expression;
export declare function parseLeftHandSideExpression(parser: ParserState, context: Context, isLHS: 0 | 1): any;
export declare function parseAssignmentExpression(parser: ParserState, context: Context, left: any): ESTree.Expression;
export declare function parseConditionalExpression(parser: ParserState, context: Context, test: ESTree.Expression): ESTree.Expression;
export declare function parseBinaryExpression(parser: ParserState, context: Context, minPrec: number, operator: Token, left: any): ESTree.Expression;
export declare function parseMemberOrUpdateExpression(parser: ParserState, context: Context, expr: any, isOptional?: 0 | 1, optionalChaining?: 0 | 1): any;
export declare function parseTaggedTemplateExpression(parser: ParserState, context: Context, expr: any, typeParameters: any): any;
export declare function parseArguments(parser: ParserState, context: Context): any[];
export declare function parseSpreadElement(parser: ParserState, context: Context): ESTree.SpreadElement;
export declare function parseLabelledStatement(parser: ParserState, context: Context, _t: Token, expr: any, pos: number): ESTree.LabeledStatement;
export declare function parseExpressionStatement(parser: ParserState, context: Context, expression: any): ESTree.ExpressionStatement;
export declare function parseFunctionDeclaration(parser: ParserState, context: Context, flags: ClassAndFunctionFlags, origin: Origin, isAsync: 0 | 1, allowGen: 0 | 1, declare: boolean): ESTree.FunctionDeclaration | ESTree.DeclareFunction;
export declare function parseFunctionExpression(parser: ParserState, context: Context, isAsync: 0 | 1): any;
export declare function parseTypeFromNonArray(parser: ParserState, context: Context, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): ESTree.IntersectionType | ESTree.UnionType;
export declare function parseUnionAndIntersectionType(parser: ParserState, context: Context, type: any, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): ESTree.IntersectionType | ESTree.UnionType;
export declare function parseTypeFromValue(parser: ParserState, context: Context, value: string): ESTree.TypeReference | {
    type: any;
};
export declare function parseTypeOrTypePredicate(parser: ParserState, context: Context, restrictedTypes: 0 | 1): any;
export declare function parseTypescriptClassDeclaration(parser: ParserState, context: Context, flags: ClassAndFunctionFlags, declare: 0 | 1, abstract: 0 | 1, exportDecorators?: never[], decl?: boolean): ESTree.ClassDeclaration;
export declare function parseTypescriptClassDeclarationOrExpression(parser: ParserState, context: Context, id: ESTree.Identifier, decorators: ESTree.Decorator[], origin: Origin, isExpr: 0 | 1, declare: 0 | 1, abstract: 0 | 1, type: 'ClassDeclaration' | 'ClassExpression', heritage: 'ClassImplements' | 'InterfaceHeritage'): ESTree.ClassDeclaration | ESTree.ClassExpression;
export declare function parseClassDeclaration(parser: ParserState, context: Context, flags: ClassAndFunctionFlags): ESTree.ClassDeclaration;
export declare function parseClassDeclarationOrExpression(parser: ParserState, context: Context, id: any, origin: Origin, type: 'ClassDeclaration' | 'ClassExpression'): ESTree.ClassDeclaration | ESTree.ClassExpression;
export declare function parseTypescriptClassExpression(parser: ParserState, context: Context): ESTree.ClassExpression;
export declare function parseClassExpression(parser: ParserState, context: Context): any;
export declare function parseClassBody(parser: ParserState, context: Context, inheritedContext: Context, origin: Origin): ESTree.ClassBody;
export declare function parseClassMembers(parser: ParserState, context: Context, inheritedContext: Context, origin: Origin, isExpr: 0 | 1, isAbstract: 0 | 1, isDeclared: 0 | 1): ESTree.ClassBody;
export declare function parseClassElementList(parser: ParserState, context: Context, inheritedContext: Context, modifiers: ModifierKind): any;
export declare function parseClassElements(parser: ParserState, context: Context, inheritedContext: Context, decorators: any, isAbstract: 0 | 1, isDeclared: 0 | 1, modifiers: ModifierKind): any;
export declare function parseClassProperty(parser: ParserState, context: Context, key: ESTree.Identifier | ESTree.Literal, kind: PropertyKind, modifiers: ModifierKind, decorators: ESTree.Decorator[]): ESTree.ClassProperty;
export declare function parseConstructorFormals(parser: ParserState, context: Context, declare: 0 | 1): ESTree.Parameter[];
export declare function parseParameterProperty(parser: ParserState, context: Context, token: Token, decorators: any): ESTree.ParameterProperty;
export declare function parseTypeScriptFormalParametersOrFormalList(parser: ParserState, context: Context): ESTree.Parameter[];
export declare function parseFormalParametersOrFormalList(parser: ParserState, context: Context): ESTree.Parameter[];
export declare function parseFunctionBody(parser: ParserState, context: Context, origin: Origin): ESTree.BlockStatement | null;
export declare function parseBlock(parser: ParserState, context: Context): ESTree.BlockStatement;
export declare function parsePrimaryExpression(parser: ParserState, context: Context, isLHS: 0 | 1, inParens: 0 | 1): any;
export declare function parseImportCallOrMetaExpression(parser: ParserState, context: Context): ESTree.ImportExpression;
export declare function parseImportExpression(parser: ParserState, context: Context): ESTree.ImportExpression;
export declare function parseTypeParameterFromValue(parser: ParserState, context: Context, value: string): ESTree.TypeParameter;
export declare function parseJSXOrTypeAssertion(parser: ParserState, context: Context): ESTree.TypeParameterDeclaration | ESTree.TypeAssertion | ESTree.JSXElement | ESTree.JSXFragment;
export declare function parseTypeAssertion(parser: ParserState, context: Context, typeAnnotation: any): ESTree.TypeAssertion;
export declare function parseAsyncExpression(parser: ParserState, context: Context, isLHS: 0 | 1, inNew: 0 | 1): ESTree.FunctionExpression | ESTree.ArrowFunctionExpression | ESTree.CallExpression | ESTree.Identifier;
export declare function parseAwaitExpression(parser: ParserState, context: Context): ESTree.AwaitExpression | ESTree.Identifier | ESTree.ArrowFunctionExpression;
export declare function parseYieldExpression(parser: ParserState, context: Context): ESTree.YieldExpression | ESTree.Identifier | ESTree.ArrowFunctionExpression;
export declare function parseIdentifierOrArrow(parser: ParserState, context: Context): ESTree.Identifier | ESTree.ArrowFunctionExpression;
export declare function parseObjectLiteral(parser: ParserState, context: Context, skipInitializer: 0 | 1): any;
export declare function parseObjectLiteralOrPattern(parser: ParserState, context: Context, skipInitializer: 0 | 1, isPattern: 0 | 1, decorators: ESTree.Decorator[]): any;
export declare function parseArrayOrObjectAssignmentPattern(parser: ParserState, context: Context, node: any): ESTree.AssignmentExpression;
export declare function parseComputedPropertyName(parser: ParserState, context: Context): ESTree.Expression;
export declare function parseTypeScriptMethodDefinition(parser: ParserState, context: Context, isConstructor: boolean, kind: PropertyKind, modifiers: ModifierKind, declare?: 0 | 1): ESTree.FunctionExpression | ESTree.EmptyBodyFunctionExpression;
export declare function parseMethodDefinition(parser: ParserState, context: Context, kind: PropertyKind): any;
export declare function parseTypescriptMethodFormals(parser: ParserState, context: Context, kind: PropertyKind): ESTree.Parameter[];
export declare function parseMethodFormals(parser: ParserState, context: Context, kind: PropertyKind): ESTree.Parameter[];
export declare function parseSpreadOrRestElement(parser: ParserState, context: Context, closingToken: Token, allowTypeAnnotation: 0 | 1, decorators: ESTree.Decorator[]): any;
export declare function parseArrayLiteral(parser: ParserState, context: Context, skipInitializer: 0 | 1): any;
export declare function parseArrayExpressionOrPattern(parser: ParserState, context: Context, skipInitializer: 0 | 1, isPattern: 0 | 1, decorators: ESTree.Decorator[]): ESTree.ArrayExpression | ESTree.ArrayPattern | ESTree.AssignmentExpression;
export declare function parseParenthesizedExpression(parser: ParserState, context: Context, isLHS: 0 | 1): any;
export declare function parseOptionalNchanged(parser: ParserState, context: Context, param: any, isAsync: any): any;
export declare function parseTypescriptParenthesizedExpression(parser: ParserState, context: Context, isLHS: 0 | 1, typeAnnotation: any[], assertion: TypeAssertionState): any;
export declare function parseArrowFunctionExpression(parser: ParserState, context: Context, params: any, typeParameters: any, returnType: any, isLHS: 0 | 1, isAsync: 0 | 1): ESTree.ArrowFunctionExpression;
export declare function parseSuperExpression(parser: ParserState, context: Context): ESTree.Super;
export declare function parseNewExpression(parser: ParserState, context: Context): ESTree.NewExpression | ESTree.MetaProperty;
export declare function parseMetaProperty(parser: ParserState, context: Context, meta: ESTree.Identifier): ESTree.MetaProperty;
export declare function parseMembeExpressionNoCall(parser: ParserState, context: Context, expr: any): ESTree.MemberExpression;
export declare function parseNoSubstitutionTemplate(parser: ParserState, context: Context): ESTree.TemplateLiteral;
export declare function parseTemplateLiteral(parser: ParserState, context: Context): ESTree.TemplateLiteral;
export declare function parseTemplateElement(parser: ParserState, tail: boolean): ESTree.TemplateElement;
export declare function parseBigIntLiteral(parser: ParserState, context: Context): any;
export declare function parseUnaryExpression(parser: ParserState, context: Context): ESTree.UnaryExpression;
export declare function parseUpdateExpressionPrefixed(parser: ParserState, context: Context, inNew: 0 | 1): any;
export declare function parseLiteral(parser: ParserState, context: Context): any;
export declare function parseIdentifier(parser: ParserState, context: Context): any;
export declare function parseThisExpression(parser: ParserState, context: Context): any;
export declare function parseNullOrTrueOrFalseLiteral(parser: ParserState, context: Context): any;
export declare function parseRegExpLiteral(parser: ParserState, context: Context): any;
export declare function parseTypeParameters(parser: ParserState, context: Context): ESTree.TypeParameterDeclaration | never[];
export declare function parseTypeParameter(parser: ParserState, context: Context): ESTree.TypeParameter;
export declare function parseBindingIdentifier(parser: ParserState, context: Context, requireTypeAnnotation: 0 | 1, canBeOptionalParam: 0 | 1): ESTree.Identifier;
export declare function parseOptionalIdentifier(parser: ParserState, context: Context): ESTree.Identifier;
export declare function parseTypeAnnotationNoConsume(parser: ParserState, context: Context, restrictedTypes: 0 | 1): any;
export declare function parseTypeAnnotation(parser: ParserState, context: Context, restrictedTypes: 0 | 1): any;
export declare function parseType(parser: ParserState, context: Context, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): any;
export declare function parseConditionalType(parser: ParserState, context: Context, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState, checkType: ESTree.TypeNode): ESTree.ConditionalType;
export declare function parseIntersectionType(parser: ParserState, context: Context, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): any;
export declare function parseTypeOperatorOrHigher(parser: ParserState, context: Context, isReadOnly: 0 | 1, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): ESTree.InferType | ESTree.TypeOperator | ESTree.IndexedAccessType | ESTree.ArrayType;
export declare function parseTypeOperator(parser: ParserState, context: Context, isReadOnly: 0 | 1, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): ESTree.TypeOperator;
export declare function parseInferType(parser: ParserState, context: Context): any;
export declare function parsePostFix(parser: ParserState, context: Context, isReadOnly: 0 | 1, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): ESTree.IndexedAccessType | ESTree.ArrayType;
export declare function parsePostFixTypeOrHigher(parser: ParserState, context: Context, type: any): ESTree.IndexedAccessType | ESTree.ArrayType;
export declare function parseUnionType(parser: ParserState, context: Context, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): ESTree.UnionType;
export declare function parseEntityName(parser: ParserState, context: Context): ESTree.QualifiedName;
export declare function parseTypeReference(parser: ParserState, context: Context): ESTree.TypeReference;
export declare function parseNonArrayType(parser: ParserState, context: Context, isReadOnly: 0 | 1, restrictedTypes: 0 | 1, isMappedType: 0 | 1, typeAlias: TypeAliasState): any;
export declare function parseFunctionType(parser: ParserState, context: Context): any;
export declare function parseNewAsTypeReferenceOrConstructorType(parser: ParserState, context: Context, isMappedType: 0 | 1, typeAlias: TypeAliasState): any;
export declare function parseImportType(parser: ParserState, context: Context, isTypeOf: boolean): ESTree.ImportType;
export declare function parseTemplateLiteralType(parser: ParserState, context: Context): ESTree.LiteralType;
export declare function parseSubtractTypeNode(parser: ParserState, context: Context): any;
export declare function parseTypeQuery(parser: ParserState, context: Context): ESTree.TypeQuery;
export declare function parseThisTypeNode(parser: ParserState, context: Context): ESTree.ThisType;
export declare function parseTypePredicate(parser: ParserState, context: Context, parameterName: any): ESTree.TypePredicate;
export declare function parseLiteralTypedNode(parser: ParserState, context: Context, isBoolean: 0 | 1, type: 'Literal' | 'Literal' | 'BigIntLiteral'): ESTree.LiteralType;
export declare function parseNullOrVoidTypedNode(parser: ParserState, context: Context, type: 'NullKeyword' | 'VoidKeyword'): ESTree.NullKeyword | ESTree.VoidKeyword;
export declare function parseFunctionOrConstructorTypeOrParenthesized(parser: ParserState, context: Context, isMappedType: 0 | 1, typeAlias: TypeAliasState, astType: 'ParenthesizedType' | 'FunctionType' | 'ConstructorType'): ESTree.ParenthesizedType | ESTree.FunctionType | any;
export declare function parseIdentifierFromValue(parser: ParserState, context: Context, name: string, allowAnnotations: 0 | 1): {
    type: "Identifier";
    name: string;
    optional: boolean;
    typeAnnotation: any;
};
export declare function parseRestElement(parser: ParserState, context: Context): any;
export declare function parseQualifiedName(parser: ParserState, context: Context, entity: any): ESTree.QualifiedName;
export declare function parseTypeReferenceFromExpression(parser: ParserState, context: Context, expr: any): ESTree.TypeReference;
export declare function parseTupleType(parser: ParserState, context: Context): ESTree.TupleType;
export declare function parseFunctionTypeParams(parser: ParserState, context: Context): (ESTree.ObjectPattern | ESTree.ArrayPattern | ESTree.Identifier)[];
export declare function parseFunctionTypeParam(parser: ParserState, context: Context): ESTree.ObjectPattern | ESTree.ArrayPattern | ESTree.Identifier;
export declare function parseObjectTypeMembers(parser: ParserState, context: Context, typeAlias: TypeAliasState): any;
export declare function parseMappedType(parser: ParserState, context: Context, name: string, readonly: boolean | '-' | '+'): ESTree.MappedType;
export declare function parseMappedTypeParameter(parser: ParserState, context: Context, value: string): ESTree.TypeParameter;
export declare function parseObjectTypeMembersMethod(parser: ParserState, context: Context, isStatic: any, optional: boolean, key: ESTree.Identifier | ESTree.Literal): ESTree.MethodSignature;
export declare function parsePropertySignature(parser: ParserState, context: Context, optional: boolean, isReadOnly: boolean | '+' | '-', key: any): ESTree.PropertySignature;
export declare function parseCallSignatureDeclaration(parser: ParserState, context: Context): ESTree.CallSignatureDeclaration;
export declare function parseConstructSignatureDeclaration(parser: ParserState, context: Context): ESTree.ConstructSignatureDeclaration;
export declare function parseObjectPropertyKey(parser: ParserState, context: Context): ESTree.Identifier | ESTree.Literal;
export declare function parseClassDeclarationOrIdentifier(parser: ParserState, context: Context, token: Token, abstract: 0 | 1, declare: 0 | 1): ESTree.Identifier | ESTree.ClassDeclaration;
export declare function parseTypeAliasOrIdentifier(parser: ParserState, context: Context, token: Token, declare: 0 | 1): ESTree.TypeAliasDeclaration | ESTree.Identifier;
export declare function parseTypeAlias(parser: ParserState, context: Context, declare: 0 | 1): ESTree.TypeAliasDeclaration;
export declare function parseInterfaceOrIdentifier(parser: ParserState, context: Context, token: Token, declare: 0 | 1): ESTree.Identifier | ESTree.InterfaceDeclaration;
export declare function parseInterfaceDeclaration(parser: ParserState, context: Context, declare: 0 | 1): ESTree.InterfaceDeclaration;
export declare function parseIndexSignature(parser: ParserState, context: Context, isStatic: boolean, readonly: boolean): any;
export declare function parseInterfaceBody(parser: ParserState, context: Context): ESTree.InterfaceBody;
export declare function parseHeritageClausesOrClassImplements(parser: ParserState, context: Context, type: 'InterfaceHeritage' | 'ClassImplements'): ESTree.InterfaceHeritage | ESTree.ClassImplements;
export declare function parseConstEnumOrVariableStatement(parser: ParserState, context: Context, declare: 0 | 1): ESTree.VariableDeclaration | ESTree.EnumDeclaration;
export declare function parseEnumDeclaration(parser: ParserState, context: Context, declare: 0 | 1, isConst: 0 | 1): ESTree.EnumDeclaration;
export declare function parseEnumDeclarationOrIdentifier(parser: ParserState, context: Context, token: Token, declare: 0 | 1, isConst: 0 | 1): ESTree.EnumDeclaration;
export declare function parseEnumMembers(parser: ParserState, context: Context): ESTree.EnumMember;
export declare function parseNamespaceOrIdentifier(parser: ParserState, context: Context, token: Token, declare: 0 | 1): ESTree.ModuleDeclaration | ESTree.Expression;
export declare function parseModuleDeclaration(parser: ParserState, context: Context, declare: any): any;
export declare function parseStatementListBlock(parser: ParserState, context: Context): ESTree.ModuleBlock;
export declare function parseModuleBlock(parser: ParserState, context: Context): ESTree.ModuleBlock;
export declare function parseGlobalModuleDeclarationOrIdentifier(parser: ParserState, context: Context, token: Token, declare: 0 | 1): any;
export declare function parseModuleDeclarationOrIdentifier(parser: ParserState, context: Context, token: Token, declare: 0 | 1): any;
export declare function parseTypeParameterInstantiation(parser: ParserState, context: Context): any;
export declare function parseTypeParameterInstantiationOrHigher(parser: ParserState, context: Context, params: any[]): any;
export declare function parseJSXFragment(parser: ParserState, context: Context, inJSXChild: 0 | 1): any;
export declare function parseJSXOpeningElement(context: Context, name: string, attributes: (ESTree.JSXAttribute | ESTree.JSXSpreadAttribute)[], selfClosing: any, typeParameters: any): ESTree.JSXOpeningElement;
export declare function parseJSXRootElementOrFragment(parser: ParserState, context: Context, inJSXChild: 0 | 1): ESTree.JSXElement | ESTree.JSXFragment;
export declare function parseJSXClosingElement(parser: ParserState, context: Context, inJSXChild: 0 | 1): ESTree.JSXClosingElement;
export declare function parseJSXAttributes(parser: ParserState, context: Context): (ESTree.JSXAttribute | ESTree.JSXSpreadAttribute)[];
export declare function parseJSXElementName(parser: ParserState, context: Context): any;
export declare function parseJSXMemberExpression(parser: ParserState, context: Context, object: ESTree.JSXIdentifier | ESTree.JSXMemberExpression): ESTree.JSXMemberExpression;
export declare function parseJSXOpeningFragment(parser: ParserState): ESTree.JSXOpeningFragment;
export declare function parseJSXClosingFragment(parser: ParserState, context: Context, inJSXChild: 0 | 1): ESTree.JSXClosingFragment;
export declare function parseJSXChildren(parser: ParserState, context: Context): ESTree.JSXChild[];
export declare function parseJSXChild(parser: ParserState, context: Context): ESTree.JSXExpression | ESTree.JSXText | ESTree.JSXElement | ESTree.JSXFragment;
export declare function parseJSXText(parser: ParserState): ESTree.JSXText;
export declare function parseJSXExpressionContainer(parser: ParserState, context: Context, inJSXChild: 0 | 1, isAttr: 0 | 1): ESTree.JSXExpressionContainer | ESTree.JSXSpreadChild;
export declare function parseJSXSpreadChild(parser: ParserState, context: Context): ESTree.JSXSpreadChild;
export declare function parseJSXEmptyExpression(): ESTree.JSXEmptyExpression;
export declare function parseJSXIdentifier(parser: ParserState, context: Context): ESTree.JSXIdentifier;
export declare function parseJsxAttribute(parser: ParserState, context: Context): ESTree.JSXAttribute | ESTree.JSXSpreadAttribute;
export declare function parseJSXSpreadAttribute(parser: ParserState, context: Context): ESTree.JSXSpreadAttribute;
export declare function parseJSXNamespacedName(parser: ParserState, context: Context, namespace: ESTree.JSXIdentifier | ESTree.JSXMemberExpression): ESTree.JSXNamespacedName;
export declare function parseDecorators(parser: ParserState, context: Context): ESTree.Decorator[];
export declare function parseDecoratorList(parser: ParserState, context: Context): ESTree.Decorator;
export declare function parseAssertsTypePredicateOrTypePredicate(parser: ParserState, context: Context): ESTree.TypeReference | {
    type: "TypePredicate";
    assertsModifier: true;
    parameterName: any;
    typeAnnotation: any;
};
//# sourceMappingURL=parser.d.ts.map